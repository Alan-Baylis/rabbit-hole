(function () {
  'use strict';

  var Action = {

    CONFIGURE: "worker.config",
    TEST: "worker.test"

  };

  var workerCode = "!function(){\"use strict\";var t=function(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")},n=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),e=function t(n,e,i){null===n&&(n=Function.prototype);var a=Object.getOwnPropertyDescriptor(n,e);if(void 0===a){var r=Object.getPrototypeOf(n);return null===r?void 0:t(r,e,i)}if(\"value\"in a)return a.value;var s=a.get;if(void 0!==s)return s.call(i)},i=function(t,n){if(\"function\"!=typeof n&&null!==n)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof n);t.prototype=Object.create(n&&n.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(t,n):t.__proto__=n)},a=function(t,n){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!n||\"object\"!=typeof n&&\"function\"!=typeof n?t:n},r=function(t){if(Array.isArray(t)){for(var n=0,e=Array(t.length);n<t.length;n++)e[n]=t[n];return e}return Array.from(t)},s=(function(){function e(){t(this,e)}n(e,[{key:\"serialize\",value:function(){throw new Error(\"Serializable#serialise method not implemented!\")}}])}(),function(){function e(){t(this,e)}n(e,[{key:\"deserialize\",value:function(t){throw new Error(\"Deserializable#deserialise method not implemented!\")}}])}(),function(){function e(){t(this,e)}n(e,[{key:\"dispose\",value:function(){throw new Error(\"Disposable#dispose method not implemented!\")}}])}(),function(){function e(){t(this,e)}n(e,[{key:\"createTransferList\",value:function(){throw new Error(\"TransferableContainer#createTransferList method not implemented!\")}}])}(),function(){function e(){t(this,e),this.elements=[],this.head=0}return n(e,[{key:\"add\",value:function(t){this.elements.push(t)}},{key:\"peek\",value:function(){return this.elements.length>0?this.elements[this.head]:void 0}},{key:\"poll\",value:function(){var t=this.elements,n=t.length,e=void 0;return n>0&&(e=t[this.head++],2*this.head>=n&&(this.elements=t.slice(this.head),this.head=0)),e}},{key:\"clear\",value:function(){this.elements=[],this.head=0}},{key:\"size\",get:function(){return this.elements.length-this.head}},{key:\"empty\",get:function(){return 0===this.elements.length}}]),e}()),o=function n(e){t(this,n),this.type=e,this.target=null},l=function(){function e(){t(this,e),this.listenerFunctions=new Map,this.listenerObjects=new Map}return n(e,[{key:\"addEventListener\",value:function(t,n){var e=\"function\"==typeof n?this.listenerFunctions:this.listenerObjects;e.has(t)?e.get(t).add(n):e.set(t,new Set([n]))}},{key:\"removeEventListener\",value:function(t,n){var e=\"function\"==typeof n?this.listenerFunctions:this.listenerObjects,i=void 0;e.has(t)&&((i=e.get(t)).delete(n),0===i.size&&e.delete(t))}},{key:\"dispatchEvent\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this,e=n.listenerFunctions,i=n.listenerObjects,a=void 0;if(t.target=n,e.has(t.type)){a=e.get(t.type);var r=!0,s=!1,o=void 0;try{for(var l,u=a[Symbol.iterator]();!(r=(l=u.next()).done);r=!0)l.value.call(n,t)}catch(t){s=!0,o=t}finally{try{!r&&u.return&&u.return()}finally{if(s)throw o}}}if(i.has(t.type)){a=i.get(t.type);var h=!0,c=!1,d=void 0;try{for(var v,m=a[Symbol.iterator]();!(h=(v=m.next()).done);h=!0)v.value.handleEvent(t)}catch(t){c=!0,d=t}finally{try{!h&&m.return&&m.return()}finally{if(c)throw d}}}}}]),e}(),u={UNION:\"csg.union\",DIFFERENCE:\"csg.difference\",INTERSECTION:\"csg.intersection\",DENSITY_FUNCTION:\"csg.densityfunction\"},h=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.x=n,this.y=i,this.z=a}return n(e,[{key:\"set\",value:function(t,n,e){return this.x=t,this.y=n,this.z=e,this}},{key:\"copy\",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}},{key:\"clone\",value:function(){return new this.constructor(this.x,this.y,this.z)}},{key:\"fromArray\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this}},{key:\"toArray\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t}},{key:\"setFromSpherical\",value:function(t){var n=Math.sin(t.phi)*t.radius;return this.x=n*Math.sin(t.theta),this.y=Math.cos(t.phi)*t.radius,this.z=n*Math.cos(t.theta),this}},{key:\"setFromCylindrical\",value:function(t){return this.x=t.radius*Math.sin(t.theta),this.y=t.y,this.z=t.radius*Math.cos(t.theta),this}},{key:\"setFromMatrixColumn\",value:function(t,n){return this.fromArray(t.elements,4*n)}},{key:\"setFromMatrixPosition\",value:function(t){var n=t.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}},{key:\"setFromMatrixScale\",value:function(t){var n=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=n,this.y=e,this.z=i,this}},{key:\"add\",value:function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}},{key:\"addScalar\",value:function(t){return this.x+=t,this.y+=t,this.z+=t,this}},{key:\"addVectors\",value:function(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this}},{key:\"addScaledVector\",value:function(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this}},{key:\"sub\",value:function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}},{key:\"subScalar\",value:function(t){return this.x-=t,this.y-=t,this.z-=t,this}},{key:\"subVectors\",value:function(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this}},{key:\"multiply\",value:function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}},{key:\"multiplyScalar\",value:function(t){return this.x*=t,this.y*=t,this.z*=t,this}},{key:\"multiplyVectors\",value:function(t,n){return this.x=t.x*n.x,this.y=t.y*n.y,this.z=t.z*n.z,this}},{key:\"divide\",value:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}},{key:\"divideScalar\",value:function(t){return this.x/=t,this.y/=t,this.z/=t,this}},{key:\"crossVectors\",value:function(t,n){var e=t.x,i=t.y,a=t.z,r=n.x,s=n.y,o=n.z;return this.x=i*o-a*s,this.y=a*r-e*o,this.z=e*s-i*r,this}},{key:\"cross\",value:function(t){return this.crossVectors(this,t)}},{key:\"transformDirection\",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.elements;return this.x=a[0]*n+a[4]*e+a[8]*i,this.y=a[1]*n+a[5]*e+a[9]*i,this.z=a[2]*n+a[6]*e+a[10]*i,this.normalize()}},{key:\"applyMatrix3\",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.elements;return this.x=a[0]*n+a[3]*e+a[6]*i,this.y=a[1]*n+a[4]*e+a[7]*i,this.z=a[2]*n+a[5]*e+a[8]*i,this}},{key:\"applyMatrix4\",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.elements;return this.x=a[0]*n+a[4]*e+a[8]*i+a[12],this.y=a[1]*n+a[5]*e+a[9]*i+a[13],this.z=a[2]*n+a[6]*e+a[10]*i+a[14],this}},{key:\"applyQuaternion\",value:function(t){var n=this.x,e=this.y,i=this.z,a=t.x,r=t.y,s=t.z,o=t.w,l=o*n+r*i-s*e,u=o*e+s*n-a*i,h=o*i+a*e-r*n,c=-a*n-r*e-s*i;return this.x=l*o+c*-a+u*-s-h*-r,this.y=u*o+c*-r+h*-a-l*-s,this.z=h*o+c*-s+l*-r-u*-a,this}},{key:\"negate\",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}},{key:\"dot\",value:function(t){return this.x*t.x+this.y*t.y+this.z*t.z}},{key:\"reflect\",value:function(t){arguments.length>1&&void 0!==arguments[1]?arguments[1]:new e;var n=t.x,i=t.y,a=t.z;return this.sub(t.multiplyScalar(2*this.dot(t))),t.set(n,i,a),this}},{key:\"angleTo\",value:function(t){var n=this.dot(t)/Math.sqrt(this.lengthSquared()*t.lengthSquared());return Math.acos(Math.min(Math.max(n,-1),1))}},{key:\"manhattanLength\",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}},{key:\"lengthSquared\",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:\"length\",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:\"manhattanDistanceTo\",value:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}},{key:\"distanceToSquared\",value:function(t){var n=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return n*n+e*e+i*i}},{key:\"distanceTo\",value:function(t){return Math.sqrt(this.distanceToSquared(t))}},{key:\"normalize\",value:function(){return this.divideScalar(this.length())}},{key:\"setLength\",value:function(t){return this.normalize().multiplyScalar(t)}},{key:\"min\",value:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}},{key:\"max\",value:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}},{key:\"clamp\",value:function(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this}},{key:\"floor\",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}},{key:\"ceil\",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}},{key:\"round\",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}},{key:\"lerp\",value:function(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this}},{key:\"lerpVectors\",value:function(t,n,e){return this.subVectors(n,t).multiplyScalar(e).add(t)}},{key:\"equals\",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}}]),e}(),c=new h,d=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h(1/0,1/0,1/0),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h(-1/0,-1/0,-1/0);t(this,e),this.min=n,this.max=i}return n(e,[{key:\"set\",value:function(t,n){return this.min.copy(t),this.max.copy(n),this}},{key:\"copy\",value:function(t){return this.min.copy(t.min),this.max.copy(t.max),this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"makeEmpty\",value:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}},{key:\"isEmpty\",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}},{key:\"getCenter\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h;return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:\"getSize\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h;return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}},{key:\"getBoundingSphere\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new m;return this.getCenter(t.center),t.radius=.5*this.getSize(c).length(),t}},{key:\"expandByPoint\",value:function(t){return this.min.min(t),this.max.max(t),this}},{key:\"expandByVector\",value:function(t){return this.min.sub(t),this.max.add(t),this}},{key:\"expandByScalar\",value:function(t){return this.min.addScalar(-t),this.max.addScalar(t),this}},{key:\"setFromPoints\",value:function(t){var n=void 0,e=void 0;for(this.min.set(0,0,0),this.max.set(0,0,0),n=0,e=t.length;n<e;++n)this.expandByPoint(t[n]);return this}},{key:\"setFromCenterAndSize\",value:function(t,n){var e=c.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(e),this.max.copy(t).add(e),this}},{key:\"clampPoint\",value:function(t){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h).copy(t).clamp(this.min,this.max)}},{key:\"distanceToPoint\",value:function(t){return c.copy(t).clamp(this.min,this.max).sub(t).length()}},{key:\"translate\",value:function(t){return this.min.add(t),this.max.add(t),this}},{key:\"intersect\",value:function(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}},{key:\"union\",value:function(t){return this.min.min(t.min),this.max.max(t.max),this}},{key:\"containsPoint\",value:function(t){var n=this.min,e=this.max;return t.x>=n.x&&t.y>=n.y&&t.z>=n.z&&t.x<=e.x&&t.y<=e.y&&t.z<=e.z}},{key:\"containsBox\",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return n.x<=i.x&&a.x<=e.x&&n.y<=i.y&&a.y<=e.y&&n.z<=i.z&&a.z<=e.z}},{key:\"intersectsBox\",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return a.x>=n.x&&a.y>=n.y&&a.z>=n.z&&i.x<=e.x&&i.y<=e.y&&i.z<=e.z}},{key:\"intersectsSphere\",value:function(t){return this.clampPoint(t.center,c).distanceToSquared(t.center)<=t.radius*t.radius}},{key:\"intersectsPlane\",value:function(t){var n=void 0,e=void 0;return t.normal.x>0?(n=t.normal.x*this.min.x,e=t.normal.x*this.max.x):(n=t.normal.x*this.max.x,e=t.normal.x*this.min.x),t.normal.y>0?(n+=t.normal.y*this.min.y,e+=t.normal.y*this.max.y):(n+=t.normal.y*this.max.y,e+=t.normal.y*this.min.y),t.normal.z>0?(n+=t.normal.z*this.min.z,e+=t.normal.z*this.max.z):(n+=t.normal.z*this.max.z,e+=t.normal.z*this.min.z),n<=t.constant&&e>=t.constant}},{key:\"equals\",value:function(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}]),e}(),v=new d,m=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.center=n,this.radius=i}return n(e,[{key:\"set\",value:function(t,n){return this.center.copy(t),this.radius=n,this}},{key:\"copy\",value:function(t){return this.center.copy(t.center),this.radius=t.radius,this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"setFromPoints\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.setFromPoints(t).getCenter(this.center),e=0,i=void 0,a=void 0;for(i=0,a=t.length;i<a;++i)e=Math.max(e,n.distanceToSquared(t[i]));return this.radius=Math.sqrt(e),this}},{key:\"getBoundingBox\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new d;return t.set(this.center,this.center),t.expandByScalar(this.radius),t}},{key:\"isEmpty\",value:function(){return this.radius<=0}},{key:\"translate\",value:function(t){return this.center.add(t),this}},{key:\"clampPoint\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.center.distanceToSquared(t);return n.copy(t),e>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}},{key:\"distanceToPoint\",value:function(t){return t.distanceTo(this.center)-this.radius}},{key:\"containsPoint\",value:function(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}},{key:\"intersectsSphere\",value:function(t){var n=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=n*n}},{key:\"intersectsBox\",value:function(t){return t.intersectsSphere(this)}},{key:\"intersectsPlane\",value:function(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}},{key:\"equals\",value:function(t){return t.center.equals(this.center)&&t.radius===this.radius}}]),e}(),y=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.x=n,this.y=i}return n(e,[{key:\"set\",value:function(t,n){return this.x=t,this.y=n,this}},{key:\"copy\",value:function(t){return this.x=t.x,this.y=t.y,this}},{key:\"clone\",value:function(){return new this.constructor(this.x,this.y)}},{key:\"fromArray\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this}},{key:\"toArray\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t}},{key:\"add\",value:function(t){return this.x+=t.x,this.y+=t.y,this}},{key:\"addScalar\",value:function(t){return this.x+=t,this.y+=t,this}},{key:\"addVectors\",value:function(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this}},{key:\"addScaledVector\",value:function(t,n){return this.x+=t.x*n,this.y+=t.y*n,this}},{key:\"sub\",value:function(t){return this.x-=t.x,this.y-=t.y,this}},{key:\"subScalar\",value:function(t){return this.x-=t,this.y-=t,this}},{key:\"subVectors\",value:function(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this}},{key:\"multiply\",value:function(t){return this.x*=t.x,this.y*=t.y,this}},{key:\"multiplyScalar\",value:function(t){return this.x*=t,this.y*=t,this}},{key:\"divide\",value:function(t){return this.x/=t.x,this.y/=t.y,this}},{key:\"divideScalar\",value:function(t){return this.x/=t,this.y/=t,this}},{key:\"applyMatrix3\",value:function(t){var n=this.x,e=this.y,i=t.elements;return this.x=i[0]*n+i[3]*e+i[6],this.y=i[1]*n+i[4]*e+i[7],this}},{key:\"dot\",value:function(t){return this.x*t.x+this.y*t.y}},{key:\"manhattanLength\",value:function(){return Math.abs(this.x)+Math.abs(this.y)}},{key:\"lengthSquared\",value:function(){return this.x*this.x+this.y*this.y}},{key:\"length\",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y)}},{key:\"manhattanDistanceTo\",value:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}},{key:\"distanceToSquared\",value:function(t){var n=this.x-t.x,e=this.y-t.y;return n*n+e*e}},{key:\"distanceTo\",value:function(t){return Math.sqrt(this.distanceToSquared(t))}},{key:\"normalize\",value:function(){return this.divideScalar(this.length())}},{key:\"setLength\",value:function(t){return this.normalize().multiplyScalar(t)}},{key:\"min\",value:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}},{key:\"max\",value:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}},{key:\"clamp\",value:function(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this}},{key:\"floor\",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}},{key:\"ceil\",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}},{key:\"round\",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},{key:\"negate\",value:function(){return this.x=-this.x,this.y=-this.y,this}},{key:\"angle\",value:function(){var t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t}},{key:\"lerp\",value:function(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this}},{key:\"lerpVectors\",value:function(t,n,e){return this.subVectors(n,t).multiplyScalar(e).add(t)}},{key:\"rotateAround\",value:function(t,n){var e=Math.cos(n),i=Math.sin(n),a=this.x-t.x,r=this.y-t.y;return this.x=a*e-r*i+t.x,this.y=a*i+r*e+t.y,this}},{key:\"equals\",value:function(t){return t.x===this.x&&t.y===this.y}},{key:\"width\",get:function(){return this.x},set:function(t){return this.x=t}},{key:\"height\",get:function(){return this.y},set:function(t){return this.y=t}}]),e}(),f=new y,p=(function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new y(1/0,1/0),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new y(-1/0,-1/0);t(this,e),this.min=n,this.max=i}n(e,[{key:\"set\",value:function(t,n){return this.min.copy(t),this.max.copy(n),this}},{key:\"copy\",value:function(t){return this.min.copy(t.min),this.max.copy(t.max),this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"makeEmpty\",value:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}},{key:\"isEmpty\",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y}},{key:\"getCenter\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new y;return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:\"getSize\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new y;return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}},{key:\"getBoundingSphere\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new m;return this.getCenter(t.center),t.radius=.5*this.getSize(f).length(),t}},{key:\"expandByPoint\",value:function(t){return this.min.min(t),this.max.max(t),this}},{key:\"expandByVector\",value:function(t){return this.min.sub(t),this.max.add(t),this}},{key:\"expandByScalar\",value:function(t){return this.min.addScalar(-t),this.max.addScalar(t),this}},{key:\"setFromPoints\",value:function(t){var n=void 0,e=void 0;for(this.min.set(0,0),this.max.set(0,0),n=0,e=t.length;n<e;++n)this.expandByPoint(t[n]);return this}},{key:\"setFromCenterAndSize\",value:function(t,n){var e=f.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(e),this.max.copy(t).add(e),this}},{key:\"clampPoint\",value:function(t){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:new y).copy(t).clamp(this.min,this.max)}},{key:\"distanceToPoint\",value:function(t){return f.copy(t).clamp(this.min,this.max).sub(t).length()}},{key:\"translate\",value:function(t){return this.min.add(t),this.max.add(t),this}},{key:\"intersect\",value:function(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}},{key:\"union\",value:function(t){return this.min.min(t.min),this.max.max(t.max),this}},{key:\"containsPoint\",value:function(t){var n=this.min,e=this.max;return t.x>=n.x&&t.y>=n.y&&t.x<=e.x&&t.y<=e.y}},{key:\"containsBox\",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return n.x<=i.x&&a.x<=e.x&&n.y<=i.y&&a.y<=e.y}},{key:\"intersectsBox\",value:function(t){var n=this.min,e=this.max,i=t.min,a=t.max;return a.x>=n.x&&a.y>=n.y&&i.x<=e.x&&i.y<=e.y}},{key:\"equals\",value:function(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}])}(),function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.radius=n,this.theta=i,this.y=a}n(e,[{key:\"set\",value:function(t,n,e){return this.radius=t,this.theta=n,this.y=e,this}},{key:\"copy\",value:function(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"setFromVector3\",value:function(t){return this.radius=Math.sqrt(t.x*t.x+t.z*t.z),this.theta=Math.atan2(t.x,t.z),this.y=t.y,this}}])}(),function(){function e(){t(this,e),this.elements=new Float32Array([1,0,0,0,1,0,0,0,1])}return n(e,[{key:\"set\",value:function(t,n,e,i,a,r,s,o,l){var u=this.elements;return u[0]=t,u[3]=n,u[6]=e,u[1]=i,u[4]=a,u[7]=r,u[2]=s,u[5]=o,u[8]=l,this}},{key:\"identity\",value:function(){return this.set(1,0,0,0,1,0,0,0,1),this}},{key:\"copy\",value:function(t){var n=t.elements,e=this.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}},{key:\"clone\",value:function(){return(new this.constructor).fromArray(this.elements)}},{key:\"fromArray\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<9;++i)e[i]=t[i+n];return this}},{key:\"toArray\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<9;++i)t[i+n]=e[i];return t}},{key:\"multiplyMatrices\",value:function(t,n){var e=t.elements,i=n.elements,a=this.elements,r=e[0],s=e[3],o=e[6],l=e[1],u=e[4],h=e[7],c=e[2],d=e[5],v=e[8],m=i[0],y=i[3],f=i[6],p=i[1],x=i[4],g=i[7],k=i[2],z=i[5],b=i[8];return a[0]=r*m+s*p+o*k,a[3]=r*y+s*x+o*z,a[6]=r*f+s*g+o*b,a[1]=l*m+u*p+h*k,a[4]=l*y+u*x+h*z,a[7]=l*f+u*g+h*b,a[2]=c*m+d*p+v*k,a[5]=c*y+d*x+v*z,a[8]=c*f+d*g+v*b,this}},{key:\"multiply\",value:function(t){return this.multiplyMatrices(this,t)}},{key:\"premultiply\",value:function(t){return this.multiplyMatrices(t,this)}},{key:\"multiplyScalar\",value:function(t){var n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=t,n[4]*=t,n[7]*=t,n[2]*=t,n[5]*=t,n[8]*=t,this}},{key:\"determinant\",value:function(){var t=this.elements,n=t[0],e=t[1],i=t[2],a=t[3],r=t[4],s=t[5],o=t[6],l=t[7],u=t[8];return n*r*u-n*s*l-e*a*u+e*s*o+i*a*l-i*r*o}},{key:\"getInverse\",value:function(t){var n=t.elements,e=this.elements,i=n[0],a=n[1],r=n[2],s=n[3],o=n[4],l=n[5],u=n[6],h=n[7],c=n[8],d=c*o-l*h,v=l*u-c*s,m=h*s-o*u,y=i*d+a*v+r*m,f=void 0;return 0!==y?(f=1/y,e[0]=d*f,e[1]=(r*h-c*a)*f,e[2]=(l*a-r*o)*f,e[3]=v*f,e[4]=(c*i-r*u)*f,e[5]=(r*s-l*i)*f,e[6]=m*f,e[7]=(a*u-h*i)*f,e[8]=(o*i-a*s)*f):(console.error(\"Can't invert matrix, determinant is zero\",t),this.identity()),this}},{key:\"transpose\",value:function(){var t=this.elements,n=void 0;return n=t[1],t[1]=t[3],t[3]=n,n=t[2],t[2]=t[6],t[6]=n,n=t[5],t[5]=t[7],t[7]=n,this}},{key:\"scale\",value:function(t,n){var e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=n,e[4]*=n,e[7]*=n,this}},{key:\"rotate\",value:function(t){var n=Math.cos(t),e=Math.sin(t),i=this.elements,a=i[0],r=i[3],s=i[6],o=i[1],l=i[4],u=i[7];return i[0]=n*a+e*o,i[3]=n*r+e*l,i[6]=n*s+e*u,i[1]=-e*a+n*o,i[4]=-e*r+n*l,i[7]=-e*s+n*u,this}},{key:\"translate\",value:function(t,n){var e=this.elements;return e[0]+=t*e[2],e[3]+=t*e[5],e[6]+=t*e[8],e[1]+=n*e[2],e[4]+=n*e[5],e[7]+=n*e[8],this}},{key:\"equals\",value:function(t){var n=this.elements,e=t.elements,i=!0,a=void 0;for(a=0;i&&a<9;++a)n[a]!==e[a]&&(i=!1);return i}}]),e}()),x=\"XYZ\",g=\"YZX\",k=\"ZXY\",z=\"XZY\",b=\"YXZ\",w=\"ZYX\",M=new h,S=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;t(this,e),this.x=n,this.y=i,this.z=a,this.w=r}return n(e,[{key:\"set\",value:function(t,n,e,i){return this.x=t,this.y=n,this.z=e,this.w=i,this}},{key:\"copy\",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}},{key:\"clone\",value:function(){return new this.constructor(this.x,this.y,this.z,this.w)}},{key:\"fromArray\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.w=t[n+3],this}},{key:\"toArray\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.w,t}},{key:\"setFromEuler\",value:function(t){var n=t.x,e=t.y,i=t.z,a=Math.cos,r=Math.sin,s=a(n/2),o=a(e/2),l=a(i/2),u=r(n/2),h=r(e/2),c=r(i/2);switch(t.order){case x:this.x=u*o*l+s*h*c,this.y=s*h*l-u*o*c,this.z=s*o*c+u*h*l,this.w=s*o*l-u*h*c;break;case b:this.x=u*o*l+s*h*c,this.y=s*h*l-u*o*c,this.z=s*o*c-u*h*l,this.w=s*o*l+u*h*c;break;case k:this.x=u*o*l-s*h*c,this.y=s*h*l+u*o*c,this.z=s*o*c+u*h*l,this.w=s*o*l-u*h*c;break;case w:this.x=u*o*l-s*h*c,this.y=s*h*l+u*o*c,this.z=s*o*c-u*h*l,this.w=s*o*l+u*h*c;break;case g:this.x=u*o*l+s*h*c,this.y=s*h*l+u*o*c,this.z=s*o*c-u*h*l,this.w=s*o*l-u*h*c;break;case z:this.x=u*o*l-s*h*c,this.y=s*h*l-u*o*c,this.z=s*o*c+u*h*l,this.w=s*o*l+u*h*c}return this}},{key:\"setFromAxisAngle\",value:function(t,n){var e=n/2,i=Math.sin(e);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(e),this}},{key:\"setFromRotationMatrix\",value:function(t){var n=t.elements,e=n[0],i=n[4],a=n[8],r=n[1],s=n[5],o=n[9],l=n[2],u=n[6],h=n[10],c=e+s+h,d=void 0;return c>0?(d=.5/Math.sqrt(c+1),this.w=.25/d,this.x=(u-o)*d,this.y=(a-l)*d,this.z=(r-i)*d):e>s&&e>h?(d=2*Math.sqrt(1+e-s-h),this.w=(u-o)/d,this.x=.25*d,this.y=(i+r)/d,this.z=(a+l)/d):s>h?(d=2*Math.sqrt(1+s-e-h),this.w=(a-l)/d,this.x=(i+r)/d,this.y=.25*d,this.z=(o+u)/d):(d=2*Math.sqrt(1+h-e-s),this.w=(r-i)/d,this.x=(a+l)/d,this.y=(o+u)/d,this.z=.25*d),this}},{key:\"setFromUnitVectors\",value:function(t,n){var e=t.dot(n)+1;return e<1e-6?(e=0,Math.abs(t.x)>Math.abs(t.z)?M.set(-t.y,t.x,0):M.set(0,-t.z,t.y)):M.crossVectors(t,n),this.x=M.x,this.y=M.y,this.z=M.z,this.w=e,this.normalize()}},{key:\"invert\",value:function(){return this.conjugate().normalize()}},{key:\"conjugate\",value:function(){return this.x*=-1,this.y*=-1,this.z*=-1,this}},{key:\"lengthSquared\",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}},{key:\"length\",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}},{key:\"normalize\",value:function(){var t=this.length(),n=void 0;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=1):(n=1/t,this.x=this.x*n,this.y=this.y*n,this.z=this.z*n,this.w=this.w*n),this}},{key:\"dot\",value:function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}},{key:\"multiplyQuaternions\",value:function(t,n){var e=t.x,i=t.y,a=t.z,r=t.w,s=n.x,o=n.y,l=n.z,u=n.w;return this.x=e*u+r*s+i*l-a*o,this.y=i*u+r*o+a*s-e*l,this.z=a*u+r*l+e*o-i*s,this.w=r*u-e*s-i*o-a*l,this}},{key:\"multiply\",value:function(t){return this.multiplyQuaternions(this,t)}},{key:\"premultiply\",value:function(t){return this.multiplyQuaternions(t,this)}},{key:\"slerp\",value:function(t,n){var e=this.x,i=this.y,a=this.z,r=this.w,s=void 0,o=void 0,l=void 0,u=void 0,h=void 0;if(1===n)this.copy(t);else if(n>0){if((s=r*t.w+e*t.x+i*t.y+a*t.z)<0?(this.w=-t.w,this.x=-t.x,this.y=-t.y,this.z=-t.z,s=-s):this.copy(t),s>=1)return this.w=r,this.x=e,this.y=i,this.z=a,this;if(o=Math.sqrt(1-s*s),Math.abs(o)<.001)return this.w=.5*(r+this.w),this.x=.5*(e+this.x),this.y=.5*(i+this.y),this.z=.5*(a+this.z),this;l=Math.atan2(o,s),u=Math.sin((1-n)*l)/o,h=Math.sin(n*l)/o,this.w=r*u+this.w*h,this.x=e*u+this.x*h,this.y=i*u+this.y*h,this.z=a*u+this.z*h}return this}},{key:\"equals\",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}],[{key:\"slerp\",value:function(t,n){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new e,a=arguments[3];return i.copy(t).slerp(n,a)}},{key:\"slerpFlat\",value:function(t,n,e,i,a,r,s){var o=a[r],l=a[r+1],u=a[r+2],h=a[r+3],c=e[i],d=e[i+1],v=e[i+2],m=e[i+3],y=void 0,f=void 0,p=void 0,x=void 0,g=void 0,k=void 0,z=void 0,b=void 0;m===h&&c===o&&d===l&&v===u||(y=1-s,k=(x=c*o+d*l+v*u+m*h)>=0?1:-1,(g=1-x*x)>Number.EPSILON&&(p=Math.sqrt(g),z=Math.atan2(p,x*k),y=Math.sin(y*z)/p,s=Math.sin(s*z)/p),c=c*y+o*(b=s*k),d=d*y+l*b,v=v*y+u*b,m=m*y+h*b,y===1-s&&(c*=f=1/Math.sqrt(c*c+d*d+v*v+m*m),d*=f,v*=f,m*=f)),t[n]=c,t[n+1]=d,t[n+2]=v,t[n+3]=m}}]),e}();function C(t,n,e){return Math.max(Math.min(t,e),n)}var O=new p,D=new S,P=(function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.x=n,this.y=i,this.z=a,this.order=e.defaultOrder}n(e,[{key:\"set\",value:function(t,n,e,i){return this.x=t,this.y=n,this.z=e,this.order=e,this}},{key:\"copy\",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.order=t.order,this}},{key:\"clone\",value:function(){return new this.constructor(this.x,this.y,this.z,this.order)}},{key:\"fromArray\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.order=t[n+3],this}},{key:\"toArray\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.order,t}},{key:\"toVector3\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).set(this.x,this.y,this.z)}},{key:\"setFromRotationMatrix\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.order,e=t.elements,i=e[0],a=e[4],r=e[8],s=e[1],o=e[5],l=e[9],u=e[2],h=e[6],c=e[10];switch(n){case x:this.y=Math.asin(C(r,-1,1)),Math.abs(r)<.99999?(this.x=Math.atan2(-l,c),this.z=Math.atan2(-a,i)):(this.x=Math.atan2(h,o),this.z=0);break;case b:this.x=Math.asin(-C(l,-1,1)),Math.abs(l)<.99999?(this.y=Math.atan2(r,c),this.z=Math.atan2(s,o)):(this.y=Math.atan2(-u,i),this.z=0);break;case k:this.x=Math.asin(C(h,-1,1)),Math.abs(h)<.99999?(this.y=Math.atan2(-u,c),this.z=Math.atan2(-a,o)):(this.y=0,this.z=Math.atan2(s,i));break;case w:this.y=Math.asin(-C(u,-1,1)),Math.abs(u)<.99999?(this.x=Math.atan2(h,c),this.z=Math.atan2(s,i)):(this.x=0,this.z=Math.atan2(-a,o));break;case g:this.z=Math.asin(C(s,-1,1)),Math.abs(s)<.99999?(this.x=Math.atan2(-l,o),this.y=Math.atan2(-u,i)):(this.x=0,this.y=Math.atan2(r,c));break;case z:this.z=Math.asin(-C(a,-1,1)),Math.abs(a)<.99999?(this.x=Math.atan2(h,o),this.y=Math.atan2(r,i)):(this.x=Math.atan2(-l,c),this.y=0)}return this.order=n,this}},{key:\"setFromQuaternion\",value:function(t,n){return O.makeRotationFromQuaternion(t),this.setFromRotationMatrix(O,n)}},{key:\"setFromVector3\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.order;return this.set(t.x,t.y,t.z,n)}},{key:\"reorder\",value:function(t){return D.setFromEuler(this),this.setFromQuaternion(D,t)}},{key:\"equals\",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.order===this.order}}],[{key:\"defaultOrder\",get:function(){return x}}])}(),new h),A=new h,_=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h(1,0,0),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.normal=n,this.constant=i}return n(e,[{key:\"set\",value:function(t,n){return this.normal.copy(t),this.constant=n,this}},{key:\"setComponents\",value:function(t,n,e,i){return this.normal.set(t,n,e),this.constant=i,this}},{key:\"copy\",value:function(t){return this.normal.copy(t.normal),this.constant=t.constant,this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"setFromNormalAndCoplanarPoint\",value:function(t,n){return this.normal.copy(t),this.constant=-n.dot(this.normal),this}},{key:\"setFromCoplanarPoints\",value:function(t,n,e){var i=P.subVectors(e,n).cross(A.subVectors(t,n)).normalize();return this.setFromNormalAndCoplanarPoint(i,P),this}},{key:\"normalize\",value:function(){var t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}},{key:\"negate\",value:function(){return this.normal.negate(),this.constant=-this.constant,this}},{key:\"distanceToPoint\",value:function(t){return this.normal.dot(t)+this.constant}},{key:\"distanceToSphere\",value:function(t){return this.distanceToPoint(t.center)-t.radius}},{key:\"projectPoint\",value:function(t,n){return n.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}},{key:\"coplanarPoint\",value:function(t){return t.copy(this.normal).multiplyScalar(-this.constant)}},{key:\"translate\",value:function(t){return this.constant-=t.dot(this.normal),this}},{key:\"intersectLine\",value:function(t,n){var e=t.delta(P),i=this.normal.dot(e);if(0===i)0===this.distanceToPoint(t.start)&&n.copy(t.start);else{var a=-(t.start.dot(this.normal)+this.constant)/i;a>=0&&a<=1&&n.copy(e).multiplyScalar(a).add(t.start)}return n}},{key:\"intersectsLine\",value:function(t){var n=this.distanceToPoint(t.start),e=this.distanceToPoint(t.end);return n<0&&e>0||e<0&&n>0}},{key:\"intersectsBox\",value:function(t){return t.intersectsPlane(this)}},{key:\"intersectsSphere\",value:function(t){return t.intersectsPlane(this)}},{key:\"equals\",value:function(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}]),e}(),q=new h,I=new h,E=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new _,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new _,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new _,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new _,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new _,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:new _;t(this,e),this.planes=[n,i,a,r,s,o]}return n(e,[{key:\"set\",value:function(t,n,e,i,a,r){var s=this.planes;return s[0].copy(t),s[1].copy(n),s[2].copy(e),s[3].copy(i),s[4].copy(a),s[5].copy(r),this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"copy\",value:function(t){var n=this.planes,e=void 0;for(e=0;e<6;++e)n[e].copy(t.planes[e]);return this}},{key:\"setFromMatrix\",value:function(t){var n=this.planes,e=t.elements,i=e[0],a=e[1],r=e[2],s=e[3],o=e[4],l=e[5],u=e[6],h=e[7],c=e[8],d=e[9],v=e[10],m=e[11],y=e[12],f=e[13],p=e[14],x=e[15];return n[0].setComponents(s-i,h-o,m-c,x-y).normalize(),n[1].setComponents(s+i,h+o,m+c,x+y).normalize(),n[2].setComponents(s+a,h+l,m+d,x+f).normalize(),n[3].setComponents(s-a,h-l,m-d,x-f).normalize(),n[4].setComponents(s-r,h-u,m-v,x-p).normalize(),n[5].setComponents(s+r,h+u,m+v,x+p).normalize(),this}},{key:\"intersectsSphere\",value:function(t){var n=this.planes,e=t.center,i=-t.radius,a=!0,r=void 0;for(r=0;r<6;++r)if(n[r].distanceToPoint(e)<i){a=!1;break}return a}},{key:\"intersectsBox\",value:function(t){var n=this.planes,e=t.min,i=t.max,a=!0,r=void 0,s=void 0,o=void 0,l=void 0;for(r=0;r<6;++r)if(l=n[r],q.x=l.normal.x>0?e.x:i.x,I.x=l.normal.x>0?i.x:e.x,q.y=l.normal.y>0?e.y:i.y,I.y=l.normal.y>0?i.y:e.y,q.z=l.normal.z>0?e.z:i.z,I.z=l.normal.z>0?i.z:e.z,s=l.distanceToPoint(q),o=l.distanceToPoint(I),s<0&&o<0){a=!1;break}return a}},{key:\"containsPoint\",value:function(t){var n=this.planes,e=!0,i=void 0;for(i=0;i<6;++i)if(n[i].distanceToPoint(t)<0){e=!1;break}return e}}]),e}(),T=new h,V=new h,F=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.start=n,this.end=i}return n(e,[{key:\"set\",value:function(t,n){return this.start.copy(t),this.end.copy(n),this}},{key:\"copy\",value:function(t){return this.start.copy(t.start),this.end.copy(t.end),this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"getCenter\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).addVectors(this.start,this.end).multiplyScalar(.5)}},{key:\"delta\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.end,this.start)}},{key:\"lengthSquared\",value:function(){return this.start.distanceToSquared(this.end)}},{key:\"length\",value:function(){return this.start.distanceTo(this.end)}},{key:\"at\",value:function(t,n){return this.delta(n).multiplyScalar(t).add(this.start)}},{key:\"closestPointToPointParameter\",value:function(t,n){T.subVectors(t,this.start),V.subVectors(this.end,this.start);var e=V.dot(V),i=V.dot(T);return n?Math.min(Math.max(i/e,0),1):i/e}},{key:\"closestPointToPoint\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new h,i=this.closestPointToPointParameter(t,n);return this.delta(e).multiplyScalar(i).add(this.start)}},{key:\"equals\",value:function(t){return t.start.equals(this.start)&&t.end.equals(this.end)}}]),e}(),R=new h,U=new h,L=new h,B=function(){function e(){t(this,e),this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return n(e,[{key:\"set\",value:function(t,n,e,i,a,r,s,o,l,u,h,c,d,v,m,y){var f=this.elements;return f[0]=t,f[4]=n,f[8]=e,f[12]=i,f[1]=a,f[5]=r,f[9]=s,f[13]=o,f[2]=l,f[6]=u,f[10]=h,f[14]=c,f[3]=d,f[7]=v,f[11]=m,f[15]=y,this}},{key:\"identity\",value:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}},{key:\"copy\",value:function(t){var n=t.elements,e=this.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}},{key:\"clone\",value:function(){return(new this.constructor).fromArray(this.elements)}},{key:\"fromArray\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<16;++i)e[i]=t[i+n];return this}},{key:\"toArray\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.elements,i=void 0;for(i=0;i<16;++i)t[i+n]=e[i];return t}},{key:\"getMaxScaleOnAxis\",value:function(){var t=this.elements,n=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(n,e,i))}},{key:\"copyPosition\",value:function(t){var n=this.elements,e=t.elements;return n[12]=e[12],n[13]=e[13],n[14]=e[14],this}},{key:\"setPosition\",value:function(t){var n=this.elements;return n[12]=t.x,n[13]=t.y,n[14]=t.z,this}},{key:\"extractBasis\",value:function(t,n,e){return t.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}},{key:\"makeBasis\",value:function(t,n,e){return this.set(t.x,n.x,e.x,0,t.y,n.y,e.y,0,t.z,n.z,e.z,0,0,0,0,1),this}},{key:\"extractRotation\",value:function(t){var n=this.elements,e=t.elements,i=1/R.setFromMatrixColumn(t,0).length(),a=1/R.setFromMatrixColumn(t,1).length(),r=1/R.setFromMatrixColumn(t,2).length();return n[0]=e[0]*i,n[1]=e[1]*i,n[2]=e[2]*i,n[4]=e[4]*a,n[5]=e[5]*a,n[6]=e[6]*a,n[8]=e[8]*r,n[9]=e[9]*r,n[10]=e[10]*r,this}},{key:\"makeRotationFromEuler\",value:function(t){var n=this.elements,e=t.x,i=t.y,a=t.z,r=Math.cos(e),s=Math.sin(e),o=Math.cos(i),l=Math.sin(i),u=Math.cos(a),h=Math.sin(a),c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,p=void 0,M=void 0,S=void 0,C=void 0,O=void 0,D=void 0;switch(t.order){case x:c=r*u,d=r*h,v=s*u,m=s*h,n[0]=o*u,n[4]=-o*h,n[8]=l,n[1]=d+v*l,n[5]=c-m*l,n[9]=-s*o,n[2]=m-c*l,n[6]=v+d*l,n[10]=r*o;break;case b:y=o*u,f=o*h,p=l*u,M=l*h,n[0]=y+M*s,n[4]=p*s-f,n[8]=r*l,n[1]=r*h,n[5]=r*u,n[9]=-s,n[2]=f*s-p,n[6]=M+y*s,n[10]=r*o;break;case k:y=o*u,f=o*h,p=l*u,M=l*h,n[0]=y-M*s,n[4]=-r*h,n[8]=p+f*s,n[1]=f+p*s,n[5]=r*u,n[9]=M-y*s,n[2]=-r*l,n[6]=s,n[10]=r*o;break;case w:c=r*u,d=r*h,v=s*u,m=s*h,n[0]=o*u,n[4]=v*l-d,n[8]=c*l+m,n[1]=o*h,n[5]=m*l+c,n[9]=d*l-v,n[2]=-l,n[6]=s*o,n[10]=r*o;break;case g:S=r*o,C=r*l,O=s*o,D=s*l,n[0]=o*u,n[4]=D-S*h,n[8]=O*h+C,n[1]=h,n[5]=r*u,n[9]=-s*u,n[2]=-l*u,n[6]=C*h+O,n[10]=S-D*h;break;case z:S=r*o,C=r*l,O=s*o,D=s*l,n[0]=o*u,n[4]=-h,n[8]=l*u,n[1]=S*h+D,n[5]=r*u,n[9]=C*h-O,n[2]=O*h-C,n[6]=s*u,n[10]=D*h+S}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}},{key:\"makeRotationFromQuaternion\",value:function(t){var n=this.elements,e=t.x,i=t.y,a=t.z,r=t.w,s=e+e,o=i+i,l=a+a,u=e*s,h=e*o,c=e*l,d=i*o,v=i*l,m=a*l,y=r*s,f=r*o,p=r*l;return n[0]=1-(d+m),n[4]=h-p,n[8]=c+f,n[1]=h+p,n[5]=1-(u+m),n[9]=v-y,n[2]=c-f,n[6]=v+y,n[10]=1-(u+d),n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}},{key:\"lookAt\",value:function(t,n,e){var i=this.elements,a=R,r=U,s=L;return s.subVectors(t,n),0===s.lengthSquared()&&(s.z=1),s.normalize(),a.crossVectors(e,s),0===a.lengthSquared()&&(1===Math.abs(e.z)?s.x+=1e-4:s.z+=1e-4,s.normalize(),a.crossVectors(e,s)),a.normalize(),r.crossVectors(s,a),i[0]=a.x,i[4]=r.x,i[8]=s.x,i[1]=a.y,i[5]=r.y,i[9]=s.y,i[2]=a.z,i[6]=r.z,i[10]=s.z,this}},{key:\"multiplyMatrices\",value:function(t,n){var e=this.elements,i=t.elements,a=n.elements,r=i[0],s=i[4],o=i[8],l=i[12],u=i[1],h=i[5],c=i[9],d=i[13],v=i[2],m=i[6],y=i[10],f=i[14],p=i[3],x=i[7],g=i[11],k=i[15],z=a[0],b=a[4],w=a[8],M=a[12],S=a[1],C=a[5],O=a[9],D=a[13],P=a[2],A=a[6],_=a[10],q=a[14],I=a[3],E=a[7],T=a[11],V=a[15];return e[0]=r*z+s*S+o*P+l*I,e[4]=r*b+s*C+o*A+l*E,e[8]=r*w+s*O+o*_+l*T,e[12]=r*M+s*D+o*q+l*V,e[1]=u*z+h*S+c*P+d*I,e[5]=u*b+h*C+c*A+d*E,e[9]=u*w+h*O+c*_+d*T,e[13]=u*M+h*D+c*q+d*V,e[2]=v*z+m*S+y*P+f*I,e[6]=v*b+m*C+y*A+f*E,e[10]=v*w+m*O+y*_+f*T,e[14]=v*M+m*D+y*q+f*V,e[3]=p*z+x*S+g*P+k*I,e[7]=p*b+x*C+g*A+k*E,e[11]=p*w+x*O+g*_+k*T,e[15]=p*M+x*D+g*q+k*V,this}},{key:\"multiply\",value:function(t){return this.multiplyMatrices(this,t)}},{key:\"premultiply\",value:function(t){return this.multiplyMatrices(t,this)}},{key:\"multiplyScalar\",value:function(t){var n=this.elements;return n[0]*=t,n[4]*=t,n[8]*=t,n[12]*=t,n[1]*=t,n[5]*=t,n[9]*=t,n[13]*=t,n[2]*=t,n[6]*=t,n[10]*=t,n[14]*=t,n[3]*=t,n[7]*=t,n[11]*=t,n[15]*=t,this}},{key:\"determinant\",value:function(){var t=this.elements,n=t[0],e=t[4],i=t[8],a=t[12],r=t[1],s=t[5],o=t[9],l=t[13],u=t[2],h=t[6],c=t[10],d=t[14],v=n*s,m=n*o,y=n*l,f=e*r,p=e*o,x=e*l,g=i*r,k=i*s,z=i*l,b=a*r,w=a*s,M=a*o;return t[3]*(M*h-z*h-w*c+x*c+k*d-p*d)+t[7]*(m*d-y*c+b*c-g*d+z*u-M*u)+t[11]*(y*h-v*d-b*h+f*d+w*u-x*u)+t[15]*(-k*u-m*h+v*c+g*h-f*c+p*u)}},{key:\"getInverse\",value:function(t){var n=this.elements,e=t.elements,i=e[0],a=e[1],r=e[2],s=e[3],o=e[4],l=e[5],u=e[6],h=e[7],c=e[8],d=e[9],v=e[10],m=e[11],y=e[12],f=e[13],p=e[14],x=e[15],g=d*p*h-f*v*h+f*u*m-l*p*m-d*u*x+l*v*x,k=y*v*h-c*p*h-y*u*m+o*p*m+c*u*x-o*v*x,z=c*f*h-y*d*h+y*l*m-o*f*m-c*l*x+o*d*x,b=y*d*u-c*f*u-y*l*v+o*f*v+c*l*p-o*d*p,w=i*g+a*k+r*z+s*b,M=void 0;return 0!==w?(M=1/w,n[0]=g*M,n[1]=(f*v*s-d*p*s-f*r*m+a*p*m+d*r*x-a*v*x)*M,n[2]=(l*p*s-f*u*s+f*r*h-a*p*h-l*r*x+a*u*x)*M,n[3]=(d*u*s-l*v*s-d*r*h+a*v*h+l*r*m-a*u*m)*M,n[4]=k*M,n[5]=(c*p*s-y*v*s+y*r*m-i*p*m-c*r*x+i*v*x)*M,n[6]=(y*u*s-o*p*s-y*r*h+i*p*h+o*r*x-i*u*x)*M,n[7]=(o*v*s-c*u*s+c*r*h-i*v*h-o*r*m+i*u*m)*M,n[8]=z*M,n[9]=(y*d*s-c*f*s-y*a*m+i*f*m+c*a*x-i*d*x)*M,n[10]=(o*f*s-y*l*s+y*a*h-i*f*h-o*a*x+i*l*x)*M,n[11]=(c*l*s-o*d*s-c*a*h+i*d*h+o*a*m-i*l*m)*M,n[12]=b*M,n[13]=(c*f*r-y*d*r+y*a*v-i*f*v-c*a*p+i*d*p)*M,n[14]=(y*l*r-o*f*r-y*a*u+i*f*u+o*a*p-i*l*p)*M,n[15]=(o*d*r-c*l*r+c*a*u-i*d*u-o*a*v+i*l*v)*M):(console.error(\"Can't invert matrix, determinant is zero\",t),this.identity()),this}},{key:\"transpose\",value:function(){var t=this.elements,n=void 0;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,this}},{key:\"scale\",value:function(t,n,e){var i=this.elements;return i[0]*=t,i[4]*=n,i[8]*=e,i[1]*=t,i[5]*=n,i[9]*=e,i[2]*=t,i[6]*=n,i[10]*=e,i[3]*=t,i[7]*=n,i[11]*=e,this}},{key:\"makeScale\",value:function(t,n,e){return this.set(t,0,0,0,0,n,0,0,0,0,e,0,0,0,0,1),this}},{key:\"makeTranslation\",value:function(t,n,e){return this.set(1,0,0,t,0,1,0,n,0,0,1,e,0,0,0,1),this}},{key:\"makeRotationX\",value:function(t){var n=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,n,-e,0,0,e,n,0,0,0,0,1),this}},{key:\"makeRotationY\",value:function(t){var n=Math.cos(t),e=Math.sin(t);return this.set(n,0,e,0,0,1,0,0,-e,0,n,0,0,0,0,1),this}},{key:\"makeRotationZ\",value:function(t){var n=Math.cos(t),e=Math.sin(t);return this.set(n,-e,0,0,e,n,0,0,0,0,1,0,0,0,0,1),this}},{key:\"makeRotationAxis\",value:function(t,n){var e=Math.cos(n),i=Math.sin(n),a=1-e,r=t.x,s=t.y,o=t.z,l=a*r,u=a*s;return this.set(l*r+e,l*s-i*o,l*o+i*s,0,l*s+i*o,u*s+e,u*o-i*r,0,l*o-i*s,u*o+i*r,a*o*o+e,0,0,0,0,1),this}},{key:\"makeShear\",value:function(t,n,e){return this.set(1,n,e,0,t,1,e,0,t,n,1,0,0,0,0,1),this}},{key:\"compose\",value:function(t,n,e){return this.makeRotationFromQuaternion(n),this.scale(e.x,e.y,e.z),this.setPosition(t),this}},{key:\"decompose\",value:function(t,n,e){var i=this.elements,a=i[0],r=i[1],s=i[2],o=i[4],l=i[5],u=i[6],h=i[8],c=i[9],d=i[10],v=this.determinant(),m=R.set(a,r,s).length()*(v<0?-1:1),y=R.set(o,l,u).length(),f=R.set(h,c,d).length(),p=1/m,x=1/y,g=1/f;return t.x=i[12],t.y=i[13],t.z=i[14],i[0]*=p,i[1]*=p,i[2]*=p,i[4]*=x,i[5]*=x,i[6]*=x,i[8]*=g,i[9]*=g,i[10]*=g,n.setFromRotationMatrix(this),i[0]=a,i[1]=r,i[2]=s,i[4]=o,i[5]=l,i[6]=u,i[8]=h,i[9]=c,i[10]=d,e.x=m,e.y=y,e.z=f,this}},{key:\"makePerspective\",value:function(t,n,e,i,a,r){var s=this.elements,o=2*a/(n-t),l=2*a/(e-i),u=(n+t)/(n-t),h=(e+i)/(e-i),c=-(r+a)/(r-a),d=-2*r*a/(r-a);return s[0]=o,s[4]=0,s[8]=u,s[12]=0,s[1]=0,s[5]=l,s[9]=h,s[13]=0,s[2]=0,s[6]=0,s[10]=c,s[14]=d,s[3]=0,s[7]=0,s[11]=-1,s[15]=0,this}},{key:\"makeOrthographic\",value:function(t,n,e,i,a,r){var s=this.elements,o=1/(n-t),l=1/(e-i),u=1/(r-a),h=(n+t)*o,c=(e+i)*l,d=(r+a)*u;return s[0]=2*o,s[4]=0,s[8]=0,s[12]=-h,s[1]=0,s[5]=2*l,s[9]=0,s[13]=-c,s[2]=0,s[6]=0,s[10]=-2*u,s[14]=-d,s[3]=0,s[7]=0,s[11]=0,s[15]=1,this}},{key:\"equals\",value:function(t){var n=this.elements,e=t.elements,i=!0,a=void 0;for(a=0;i&&a<16;++a)n[a]!==e[a]&&(i=!1);return i}}]),e}(),$=[new h,new h,new h,new h],N=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.origin=n,this.direction=i}return n(e,[{key:\"set\",value:function(t,n){return this.origin.copy(t),this.direction.copy(n),this}},{key:\"copy\",value:function(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"at\",value:function(t){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h).copy(this.direction).multiplyScalar(t).add(this.origin)}},{key:\"lookAt\",value:function(t){return this.direction.copy(t).sub(this.origin).normalize(),this}},{key:\"recast\",value:function(t){return this.origin.copy(this.at(t,$[0])),this}},{key:\"closestPointToPoint\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=n.subVectors(t,this.origin).dot(this.direction);return e>=0?n.copy(this.direction).multiplyScalar(e).add(this.origin):n.copy(this.origin)}},{key:\"distanceSquaredToPoint\",value:function(t){var n=$[0].subVectors(t,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(t):$[0].copy(this.direction).multiplyScalar(n).add(this.origin).distanceToSquared(t)}},{key:\"distanceToPoint\",value:function(t){return Math.sqrt(this.distanceSquaredToPoint(t))}},{key:\"distanceToPlane\",value:function(t){var n=t.normal.dot(this.direction),e=0!==n?-(this.origin.dot(t.normal)+t.constant)/n:0===t.distanceToPoint(this.origin)?0:-1;return e>=0?e:null}},{key:\"distanceSquaredToSegment\",value:function(t,n,e,i){var a=$[0].copy(t).add(n).multiplyScalar(.5),r=$[1].copy(n).sub(t).normalize(),s=$[2].copy(this.origin).sub(a),o=.5*t.distanceTo(n),l=-this.direction.dot(r),u=s.dot(this.direction),h=-s.dot(r),c=s.lengthSq(),d=Math.abs(1-l*l),v=void 0,m=void 0,y=void 0,f=void 0,p=void 0;return d>0?(m=l*u-h,y=o*d,(v=l*h-u)>=0?m>=-y?m<=y?p=(v*=f=1/d)*(v+l*(m*=f)+2*u)+m*(l*v+m+2*h)+c:(m=o,p=-(v=Math.max(0,-(l*m+u)))*v+m*(m+2*h)+c):(m=-o,p=-(v=Math.max(0,-(l*m+u)))*v+m*(m+2*h)+c):m<=-y?p=-(v=Math.max(0,-(-l*o+u)))*v+(m=v>0?-o:Math.min(Math.max(-o,-h),o))*(m+2*h)+c:m<=y?(v=0,p=(m=Math.min(Math.max(-o,-h),o))*(m+2*h)+c):p=-(v=Math.max(0,-(l*o+u)))*v+(m=v>0?o:Math.min(Math.max(-o,-h),o))*(m+2*h)+c):(m=l>0?-o:o,p=-(v=Math.max(0,-(l*m+u)))*v+m*(m+2*h)+c),void 0!==e&&e.copy(this.direction).multiplyScalar(v).add(this.origin),void 0!==i&&i.copy(r).multiplyScalar(m).add(a),p}},{key:\"intersectSphere\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=$[0].subVectors(t.center,this.origin),i=e.dot(this.direction),a=e.dot(e)-i*i,r=t.radius*t.radius,s=null,o=void 0,l=void 0,u=void 0;return a<=r&&(u=i+(o=Math.sqrt(r-a)),((l=i-o)>=0||u>=0)&&(s=l<0?this.at(u,n):this.at(l,n))),s}},{key:\"intersectsSphere\",value:function(t){return this.distanceToPoint(t.center)<=t.radius}},{key:\"intersectPlane\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.distanceToPlane(t);return null===e?null:this.at(e,n)}},{key:\"intersectsPlane\",value:function(t){var n=t.distanceToPoint(this.origin);return 0===n||t.normal.dot(this.direction)*n<0}},{key:\"intersectBox\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.origin,i=this.direction,a=t.min,r=t.max,s=1/i.x,o=1/i.y,l=1/i.z,u=null,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0;return s>=0?(c=(a.x-e.x)*s,d=(r.x-e.x)*s):(c=(r.x-e.x)*s,d=(a.x-e.x)*s),o>=0?(v=(a.y-e.y)*o,m=(r.y-e.y)*o):(v=(r.y-e.y)*o,m=(a.y-e.y)*o),c<=m&&v<=d&&((v>c||c!=c)&&(c=v),(m<d||d!=d)&&(d=m),l>=0?(y=(a.z-e.z)*l,f=(r.z-e.z)*l):(y=(r.z-e.z)*l,f=(a.z-e.z)*l),c<=f&&y<=d&&((y>c||c!=c)&&(c=y),(f<d||d!=d)&&(d=f),d>=0&&(u=this.at(c>=0?c:d,n)))),u}},{key:\"intersectsBox\",value:function(t){return null!==this.intersectBox(t,$[0])}},{key:\"intersectTriangle\",value:function(t,n,e,i,a){var r=this.direction,s=$[0],o=$[1],l=$[2],u=$[3],h=null,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;return o.subVectors(n,t),l.subVectors(e,t),u.crossVectors(o,l),0===(c=r.dot(u))||i&&c>0||(c>0?d=1:(d=-1,c=-c),s.subVectors(this.origin,t),(v=d*r.dot(l.crossVectors(s,l)))>=0&&(m=d*r.dot(o.cross(s)))>=0&&v+m<=c&&(y=-d*s.dot(u))>=0&&(h=this.at(y/c,a))),h}},{key:\"applyMatrix4\",value:function(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}},{key:\"equals\",value:function(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}]),e}(),j=(function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;t(this,e),this.radius=n,this.phi=i,this.theta=a}n(e,[{key:\"set\",value:function(t,n,e){return this.radius=t,this.phi=n,this.theta=e,this}},{key:\"copy\",value:function(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"setFromVector3\",value:function(t){return this.radius=t.length(),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t.x,t.z),this.phi=Math.acos(Math.min(Math.max(t.y/this.radius,-1),1))),this.makeSafe()}},{key:\"makeSafe\",value:function(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}}])}(),function(){function e(){t(this,e),this.elements=new Float32Array([1,0,0,1,0,1])}return n(e,[{key:\"set\",value:function(t,n,e,i,a,r){var s=this.elements;return s[0]=t,s[1]=n,s[3]=i,s[2]=e,s[4]=a,s[5]=r,this}},{key:\"identity\",value:function(){return this.set(1,0,0,1,0,1),this}},{key:\"copy\",value:function(t){var n=t.elements;return this.set(n[0],n[1],n[2],n[3],n[4],n[5]),this}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"toMatrix3\",value:function(t){var n=t.elements;t.set(n[0],n[1],n[2],n[1],n[3],n[4],n[2],n[4],n[5])}},{key:\"add\",value:function(t){var n=this.elements,e=t.elements;return n[0]+=e[0],n[1]+=e[1],n[3]+=e[3],n[2]+=e[2],n[4]+=e[4],n[5]+=e[5],this}},{key:\"norm\",value:function(){var t=this.elements,n=t[1]*t[1],e=t[2]*t[2],i=t[4]*t[4];return Math.sqrt(t[0]*t[0]+n+e+n+t[3]*t[3]+i+e+i+t[5]*t[5])}},{key:\"off\",value:function(){var t=this.elements;return Math.sqrt(2*(t[1]*t[1]+t[2]*t[2]+t[4]*t[4]))}},{key:\"applyToVector3\",value:function(t){var n=t.x,e=t.y,i=t.z,a=this.elements;return t.x=a[0]*n+a[1]*e+a[2]*i,t.y=a[1]*n+a[3]*e+a[4]*i,t.z=a[2]*n+a[4]*e+a[5]*i,t}},{key:\"equals\",value:function(t){var n=this.elements,e=t.elements,i=!0,a=void 0;for(a=0;i&&a<6;++a)n[a]!==e[a]&&(i=!1);return i}}],[{key:\"calculateIndex\",value:function(t,n){return 3-(3-t)*(2-t)/2+n}}]),e}()),X=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;t(this,e),this.x=n,this.y=i,this.z=a,this.w=r}return n(e,[{key:\"set\",value:function(t,n,e,i){return this.x=t,this.y=n,this.z=e,this.w=i,this}},{key:\"copy\",value:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}},{key:\"clone\",value:function(){return new this.constructor(this.x,this.y,this.z,this.w)}},{key:\"fromArray\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.w=t[n+3],this}},{key:\"toArray\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.w,t}},{key:\"setAxisAngleFromQuaternion\",value:function(t){this.w=2*Math.acos(t.w);var n=Math.sqrt(1-t.w*t.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/n,this.y=t.y/n,this.z=t.z/n),this}},{key:\"setAxisAngleFromRotationMatrix\",value:function(t){var n=t.elements,e=n[0],i=n[4],a=n[8],r=n[1],s=n[5],o=n[9],l=n[2],u=n[6],h=n[10],c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,p=void 0,x=void 0,g=void 0,k=void 0,z=void 0;return Math.abs(i-r)<.01&&Math.abs(a-l)<.01&&Math.abs(o-u)<.01?Math.abs(i+r)<.1&&Math.abs(a+l)<.1&&Math.abs(o+u)<.1&&Math.abs(e+s+h-3)<.1?this.set(1,0,0,0):(c=Math.PI,p=(h+1)/2,x=(i+r)/4,g=(a+l)/4,k=(o+u)/4,(y=(e+1)/2)>(f=(s+1)/2)&&y>p?y<.01?(d=0,v=.707106781,m=.707106781):(v=x/(d=Math.sqrt(y)),m=g/d):f>p?f<.01?(d=.707106781,v=0,m=.707106781):(d=x/(v=Math.sqrt(f)),m=k/v):p<.01?(d=.707106781,v=.707106781,m=0):(d=g/(m=Math.sqrt(p)),v=k/m),this.set(d,v,m,c)):(z=Math.sqrt((u-o)*(u-o)+(a-l)*(a-l)+(r-i)*(r-i)),Math.abs(z)<.001&&(z=1),this.x=(u-o)/z,this.y=(a-l)/z,this.z=(r-i)/z,this.w=Math.acos((e+s+h-1)/2)),this}},{key:\"add\",value:function(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}},{key:\"addScalar\",value:function(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}},{key:\"addVectors\",value:function(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this.w=t.w+n.w,this}},{key:\"addScaledVector\",value:function(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this.w+=t.w*n,this}},{key:\"sub\",value:function(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}},{key:\"subScalar\",value:function(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}},{key:\"subVectors\",value:function(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this.w=t.w-n.w,this}},{key:\"multiply\",value:function(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}},{key:\"multiplyScalar\",value:function(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}},{key:\"multiplyVectors\",value:function(t,n){return this.x=t.x*n.x,this.y=t.y*n.y,this.z=t.z*n.z,this.w=t.w*n.w,this}},{key:\"divide\",value:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}},{key:\"divideScalar\",value:function(t){return this.x/=t,this.y/=t,this.z/=t,this.w/=t,this}},{key:\"applyMatrix4\",value:function(t){var n=this.x,e=this.y,i=this.z,a=this.w,r=t.elements;return this.x=r[0]*n+r[4]*e+r[8]*i+r[12]*a,this.y=r[1]*n+r[5]*e+r[9]*i+r[13]*a,this.z=r[2]*n+r[6]*e+r[10]*i+r[14]*a,this.w=r[3]*n+r[7]*e+r[11]*i+r[15]*a,this}},{key:\"negate\",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}},{key:\"dot\",value:function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}},{key:\"manhattanLength\",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}},{key:\"lengthSquared\",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}},{key:\"length\",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}},{key:\"manhattanDistanceTo\",value:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)+Math.abs(this.w-t.w)}},{key:\"distanceToSquared\",value:function(t){var n=this.x-t.x,e=this.y-t.y,i=this.z-t.z,a=this.w-t.w;return n*n+e*e+i*i+a*a}},{key:\"distanceTo\",value:function(t){return Math.sqrt(this.distanceToSquared(t))}},{key:\"normalize\",value:function(){return this.divideScalar(this.length())}},{key:\"setLength\",value:function(t){return this.normalize().multiplyScalar(t)}},{key:\"min\",value:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}},{key:\"max\",value:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}},{key:\"clamp\",value:function(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this.w=Math.max(t.w,Math.min(n.w,this.w)),this}},{key:\"floor\",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}},{key:\"ceil\",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}},{key:\"round\",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}},{key:\"lerp\",value:function(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this.w+=(t.w-this.w)*n,this}},{key:\"lerpVectors\",value:function(t,n,e){return this.subVectors(n,t).multiplyScalar(e).add(t)}},{key:\"equals\",value:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}}]),e}(),Y={AIR:0,SOLID:1},Z=function(){function e(n){t(this,e),this.type=n;for(var i=arguments.length,a=Array(i>1?i-1:0),r=1;r<i;r++)a[r-1]=arguments[r];this.children=a,this.bbox=null}return n(e,[{key:\"computeBoundingBox\",value:function(){var t=this.children,n=void 0,e=void 0;for(this.bbox=new d,n=0,e=t.length;n<e;++n)this.bbox.union(t[n].boundingBox);return this.bbox}},{key:\"boundingBox\",get:function(){return null!==this.bbox?this.bbox:this.computeBoundingBox()}}]),e}(),H=function(e){i(r,Z);function r(){var n;t(this,r);for(var e=arguments.length,i=Array(e),s=0;s<e;s++)i[s]=arguments[s];return a(this,(n=r.__proto__||Object.getPrototypeOf(r)).call.apply(n,[this,u.UNION].concat(i)))}return n(r,[{key:\"updateMaterialIndex\",value:function(t,n,e){var i=e.materialIndices[t];i!==Y.AIR&&n.setMaterialIndex(t,i)}},{key:\"selectEdge\",value:function(t,n,e){return e?t.t>n.t?t:n:t.t<n.t?t:n}}]),r}(),Q=function(e){i(r,Z);function r(){var n;t(this,r);for(var e=arguments.length,i=Array(e),s=0;s<e;s++)i[s]=arguments[s];return a(this,(n=r.__proto__||Object.getPrototypeOf(r)).call.apply(n,[this,u.DIFFERENCE].concat(i)))}return n(r,[{key:\"updateMaterialIndex\",value:function(t,n,e){e.materialIndices[t]!==Y.AIR&&n.setMaterialIndex(t,Y.AIR)}},{key:\"selectEdge\",value:function(t,n,e){return e?t.t<n.t?t:n:t.t>n.t?t:n}}]),r}(),G=function(e){i(r,Z);function r(){var n;t(this,r);for(var e=arguments.length,i=Array(e),s=0;s<e;s++)i[s]=arguments[s];return a(this,(n=r.__proto__||Object.getPrototypeOf(r)).call.apply(n,[this,u.INTERSECTION].concat(i)))}return n(r,[{key:\"updateMaterialIndex\",value:function(t,n,e){var i=e.materialIndices[t];n.setMaterialIndex(t,n.materialIndices[t]!==Y.AIR&&i!==Y.AIR?i:Y.AIR)}},{key:\"selectEdge\",value:function(t,n,e){return e?t.t<n.t?t:n:t.t>n.t?t:n}}]),r}(),K=function(e){i(r,Z);function r(n){t(this,r);var e=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,u.DENSITY_FUNCTION));return e.sdf=n,e}return n(r,[{key:\"computeBoundingBox\",value:function(){return this.bbox=this.sdf.computeBoundingBox(),this.bbox}},{key:\"generateMaterialIndex\",value:function(t){return this.sdf.sample(t)<=0?this.sdf.material:Y.AIR}},{key:\"generateEdge\",value:function(t){t.approximateZeroCrossing(this.sdf),t.computeSurfaceNormal(this.sdf)}}]),r}(),W=function(){function e(n){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.SOLID;t(this,e),this.type=n,this.operation=null,this.material=Math.min(255,Math.max(Y.SOLID,Math.trunc(i))),this.children=[],this.bbox=null}return n(e,[{key:\"setOperationType\",value:function(t){return this.operation=t,this}},{key:\"union\",value:function(t){return t.operation=u.UNION,this.children.push(t),this}},{key:\"subtract\",value:function(t){return t.operation=u.DIFFERENCE,this.children.push(t),this}},{key:\"intersect\",value:function(t){return t.operation=u.INTERSECTION,this.children.push(t),this}},{key:\"toCSG\",value:function(){var t=this.children,n=new K(this),e=void 0,i=void 0,a=void 0,r=void 0;for(a=0,r=t.length;a<r;++a){if(e!==(i=t[a]).operation)switch(e=i.operation){case u.UNION:n=new H(n);break;case u.DIFFERENCE:n=new Q(n);break;case u.INTERSECTION:n=new G(n)}n.children.push(i.toCSG())}return n}},{key:\"serialize\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n={type:this.type,operation:this.operation,material:this.material,parameters:null,children:[]},e=void 0,i=void 0;for(e=0,i=this.children.length;e<i;++e)n.children.push(this.children[e].serialize(t));return n}},{key:\"createTransferList\",value:function(){return arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]}},{key:\"toJSON\",value:function(){return this.serialize(!0)}},{key:\"computeBoundingBox\",value:function(){throw new Error(\"SignedDistanceFunction#computeBoundingBox method not implemented!\")}},{key:\"sample\",value:function(t){throw new Error(\"SignedDistanceFunction#sample method not implemented!\")}},{key:\"boundingBox\",get:function(){return null!==this.bbox?this.bbox:this.computeBoundingBox()}},{key:\"completeBoundingBox\",get:function(){var t=this.children,n=this.boundingBox.clone(),e=void 0,i=void 0;for(e=0,i=t.length;e<i;++e)n.union(t[e].completeBoundingBox);return n}}]),e}(),J={HEIGHTFIELD:\"sdf.heightfield\",FRACTAL_NOISE:\"sdf.fractalnoise\",SUPER_PRIMITIVE:\"sdf.superprimitive\"},tt=function(s){i(o,W);function o(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1];t(this,o);var i=a(this,(o.__proto__||Object.getPrototypeOf(o)).call(this,J.PERLIN_NOISE,e));return i.min=new(Function.prototype.bind.apply(h,[null].concat(r(n.min)))),i.max=new(Function.prototype.bind.apply(h,[null].concat(r(n.max)))),i}return n(o,[{key:\"computeBoundingBox\",value:function(){return this.bbox=new d(this.min,this.max),this.bbox}},{key:\"sample\",value:function(t){}},{key:\"serialize\",value:function(){var t=e(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),\"serialize\",this).call(this);return t.parameters={min:this.min.toArray(),max:this.max.toArray()},t}}]),o}();var nt=function(r){i(s,W);function s(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1];t(this,s);var i=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,J.HEIGHTFIELD,e));return i.min=new h(0,0,0),void 0!==n.min&&i.min.fromArray(n.min),i.size=new h(1,1,1),void 0!==n.size&&i.size.fromArray(n.size),i.scale=new h(1,1,1),void 0!==n.scale&&i.scale.fromArray(n.scale),i.dimensions=new h,i.dimensions.multiplyVectors(i.size,i.scale),i.data=n.data,i.heightmap=null,void 0!==n.image&&i.fromImage(n.image),i}return n(s,[{key:\"fromImage\",value:function(t){var n=\"undefined\"==typeof document?null:function(t){var n=document.createElementNS(\"http://www.w3.org/1999/xhtml\",\"canvas\").getContext(\"2d\");return n.drawImage(t,0,0),n.getImageData(0,0,t.width,t.height)}(t),e=null,i=void 0,a=void 0,r=void 0,s=void 0;if(null!==n){for(i=n.data,e=new Uint8ClampedArray(i.length/4),a=0,r=0,s=i.length;a<s;++a,r+=4)e[a]=i[r];this.heightmap=t,this.size.set(n.width,1,n.height),this.dimensions.multiplyVectors(this.size,this.scale),this.data=e}return this}},{key:\"computeBoundingBox\",value:function(){return this.bbox=new d,this.bbox.min.copy(this.min),this.bbox.max.addVectors(this.min,this.dimensions),this.bbox}},{key:\"sample\",value:function(t){var n=this.scale,e=t.x/n.x,i=t.z/n.z,a=this.min.y+this.data[i*this.size.x+e]/255*this.dimensions.y;return t.y-a}},{key:\"serialize\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"serialize\",this).call(this);return n.parameters={min:this.min.toArray(),scale:this.scale.toArray(),size:this.size.toArray(),data:t?null:this.data,dataUrl:t&&null!==this.heightmap?this.heightmap.toDataUrl():null,image:null},n}},{key:\"createTransferList\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return t.push(this.data.buffer),t}}]),s}(),et=function(s){i(o,W);function o(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1];t(this,o);var i=a(this,(o.__proto__||Object.getPrototypeOf(o)).call(this,J.SUPER_PRIMITIVE,e));return i.origin=new h,void 0!==n.origin&&i.origin.fromArray(n.origin),i.scale=void 0!==n.scale?n.scale:1,i.s0=new(Function.prototype.bind.apply(X,[null].concat(r(n.s)))),i.r0=new(Function.prototype.bind.apply(h,[null].concat(r(n.r)))),i.s=i.s0.clone().multiplyScalar(i.scale),i.r=i.r0.clone().multiplyScalar(i.scale),i.ba=new y,i.offset=0,i.precompute(),i}return n(o,[{key:\"setScale\",value:function(t){this.scale=t,this.s.copy(this.s0).multiplyScalar(t),this.r.copy(this.r0).multiplyScalar(t),this.computeBoundingBox(),this.precompute()}},{key:\"setGenus\",value:function(t){this.s0.w=t,this.s.copy(this.s0).multiplyScalar(this.scale),this.r.copy(this.r0).multiplyScalar(this.scale),this.precompute()}},{key:\"computeBoundingBox\",value:function(){var t=2*this.scale,n=this.origin;return this.bbox=new d,this.bbox.min.set(n.x-t,n.y-t,n.z-t),this.bbox.max.set(n.x+t,n.y+t,n.z+t),this.bbox}},{key:\"precompute\",value:function(){var t=this.s,n=this.r,e=this.ba,i=void 0;t.x-=n.x,t.y-=n.x,n.x-=t.w,t.w-=n.y,t.z-=n.y,this.offset=-2*t.z,e.set(n.z,this.offset),0===(i=e.dot(e))?e.set(0,-1):e.divideScalar(i)}},{key:\"sample\",value:function(t){var n=this.origin,e=this.s,i=this.r,a=this.ba,r=t.x-n.x,s=t.y-n.y,o=t.z-n.z,l=Math.abs(r)-e.x,u=Math.abs(s)-e.y,h=Math.abs(o)-e.z,c=Math.max(l,0),d=Math.max(u,0),v=Math.sqrt(c*c+d*d),m=o-e.z,y=Math.abs(v+Math.min(0,Math.max(l,u))-i.x)-e.w,f=Math.min(Math.max(y*a.x+m*a.y,0),1),p=y-i.z*f,x=m-this.offset*f,g=Math.max(y-i.z,0),k=o+e.z,z=Math.max(y,0),b=p*p+x*x,w=g*g+k*k,M=z*z+m*m,S=y*-a.y+m*a.x;return Math.sqrt(Math.min(b,Math.min(w,M)))*Math.sign(Math.max(S,h))-i.y}},{key:\"serialize\",value:function(){var t=e(o.prototype.__proto__||Object.getPrototypeOf(o.prototype),\"serialize\",this).call(this);return t.parameters={origin:this.origin.toArray(),scale:this.scale,s:this.s0.toArray(),r:this.r0.toArray()},t}}],[{key:\"create\",value:function(t){var n=it[t];return new o({s:n[0],r:n[1]})}}]),o}(),it=[[new Float32Array([1,1,1,1]),new Float32Array([0,0,0])],[new Float32Array([1,1,1,1]),new Float32Array([1,0,0])],[new Float32Array([0,0,1,1]),new Float32Array([0,0,1])],[new Float32Array([1,1,2,1]),new Float32Array([1,1,0])],[new Float32Array([1,1,1,1]),new Float32Array([1,1,0])],[new Float32Array([1,1,.25,1]),new Float32Array([1,.25,0])],[new Float32Array([1,1,.25,.25]),new Float32Array([1,.25,0])],[new Float32Array([1,1,1,.25]),new Float32Array([1,.1,0])],[new Float32Array([1,1,1,.25]),new Float32Array([.1,.1,0])]],at=5,rt=7,st=function(){function e(){t(this,e)}return n(e,[{key:\"revive\",value:function(t){var n=void 0,e=void 0,i=void 0;switch(t.type){case J.FRACTAL_NOISE:n=new tt(t.parameters,t.material);break;case J.HEIGHTFIELD:n=new nt(t.parameters,t.material);break;case J.SUPER_PRIMITIVE:n=new et(t.parameters,t.material)}for(n.operation=t.operation,e=0,i=t.children.length;e<i;++e)n.children.push(this.revive(t.children[e]));return n}}]),e}(),ot=new(function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.descriptions=null,i}return e}())(\"load\"),lt=function(e){i(r,l);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return n.items=0,n.descriptions=null,n.imageMap=new WeakMap,n}return n(r,[{key:\"clear\",value:function(){this.imageMap=new WeakMap}},{key:\"handleEvent\",value:function(t){switch(t.type){case\"load\":this.progress(t)}}},{key:\"progress\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,n=null!==t?t.target:null,e=this.imageMap;null!==n&&(e.has(n)&&(e.get(n).image=n),--this.items),0===this.items&&(this.clear(),ot.descriptions=this.descriptions,this.dispatchEvent(ot))}},{key:\"loadImage\",value:function(t){var n=new Image;this.imageMap.set(n,t),++this.items,n.addEventListener(\"load\",this),n.src=t.dataUrl}},{key:\"inflate\",value:function(t){var n=void 0;null!==t.dataUrl&&this.loadImage(t);var e=!0,i=!1,a=void 0;try{for(var r,s=t.children[Symbol.iterator]();!(e=(r=s.next()).done);e=!0)n=r.value,this.inflate(n)}catch(t){i=!0,a=t}finally{try{!e&&s.return&&s.return()}finally{if(i)throw a}}this.progress()}},{key:\"load\",value:function(t){var n=void 0;this.items=0,this.descriptions=t;var e=!0,i=!1,a=void 0;try{for(var r,s=t[Symbol.iterator]();!(e=(r=s.next()).done);e=!0)n=r.value,this.inflate(n)}catch(t){i=!0,a=t}finally{try{!e&&s.return&&s.return()}finally{if(i)throw a}}}}]),r}(),ut=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t(this,e),this.runLengths=n,this.data=i}return n(e,null,[{key:\"encode\",value:function(t){var n=[],i=[],a=t[0],r=1,s=void 0,o=void 0;for(s=1,o=t.length;s<o;++s)a!==t[s]?(n.push(r),i.push(a),a=t[s],r=1):++r;return n.push(r),i.push(a),new e(n,i)}},{key:\"decode\",value:function(t,n){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=void 0,a=void 0,r=void 0,s=void 0,o=void 0,l=0;for(a=0,s=n.length;a<s;++a)for(i=n[a],r=0,o=t[a];r<o;++r)e[l++]=i;return e}}]),e}(),ht=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t(this,e),this.value=n,this.done=i}return n(e,[{key:\"reset\",value:function(){this.value=null,this.done=!1}}]),e}(),ct=new h,dt=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.min=n,this.max=i,this.children=null}return n(e,[{key:\"getCenter\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).addVectors(this.min,this.max).multiplyScalar(.5)}},{key:\"getDimensions\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.max,this.min)}},{key:\"split\",value:function(){var t=this.min,n=this.max,e=this.getCenter(ct),i=this.children=[null,null,null,null,null,null,null,null],a=void 0,r=void 0;for(a=0;a<8;++a)r=vt[a],i[a]=new this.constructor(new h(0===r[0]?t.x:e.x,0===r[1]?t.y:e.y,0===r[2]?t.z:e.z),new h(0===r[0]?e.x:n.x,0===r[1]?e.y:n.y,0===r[2]?e.z:n.z))}}]),e}(),vt=[new Uint8Array([0,0,0]),new Uint8Array([0,0,1]),new Uint8Array([0,1,0]),new Uint8Array([0,1,1]),new Uint8Array([1,0,0]),new Uint8Array([1,0,1]),new Uint8Array([1,1,0]),new Uint8Array([1,1,1])],mt=[new Uint8Array([0,4]),new Uint8Array([1,5]),new Uint8Array([2,6]),new Uint8Array([3,7]),new Uint8Array([0,2]),new Uint8Array([1,3]),new Uint8Array([4,6]),new Uint8Array([5,7]),new Uint8Array([0,1]),new Uint8Array([2,3]),new Uint8Array([4,5]),new Uint8Array([6,7])],yt=new h,ft=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.min=n,this.size=i,this.children=null}return n(e,[{key:\"getCenter\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).copy(this.min).addScalar(.5*this.size)}},{key:\"getDimensions\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).set(this.size,this.size,this.size)}},{key:\"split\",value:function(){var t=this.min,n=this.getCenter(yt),e=.5*this.size,i=this.children=[null,null,null,null,null,null,null,null],a=void 0,r=void 0;for(a=0;a<8;++a)r=vt[a],i[a]=new this.constructor(new h(0===r[0]?t.x:n.x,0===r[1]?t.y:n.y,0===r[2]?t.z:n.z),e)}},{key:\"max\",get:function(){return this.min.clone().addScalar(this.size)}}]),e}(),pt=new d,xt=function(){function e(n){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t(this,e),this.octree=n,this.region=i,this.cull=null!==i,this.result=new ht,this.trace=null,this.indices=null,this.reset()}return n(e,[{key:\"reset\",value:function(){var t=this.octree.root;return this.trace=[],this.indices=[],null!==t&&(pt.min=t.min,pt.max=t.max,this.cull&&!this.region.intersectsBox(pt)||(this.trace.push(t),this.indices.push(0))),this.result.reset(),this}},{key:\"next\",value:function(){for(var t=this.cull,n=this.region,e=this.indices,i=this.trace,a=null,r=i.length-1,s=void 0,o=void 0,l=void 0;null===a&&r>=0;)if(s=e[r],o=i[r].children,++e[r],s<8)if(null!==o){if(l=o[s],t&&(pt.min=l.min,pt.max=l.max,!n.intersectsBox(pt)))continue;i.push(l),e.push(0),++r}else a=i.pop(),e.pop();else i.pop(),e.pop(),--r;return this.result.value=a,this.result.done=null===a,this.result}},{key:\"return\",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),gt=[new h,new h,new h],kt=new d,zt=new N,bt=[new Uint8Array([4,2,1]),new Uint8Array([5,3,8]),new Uint8Array([6,8,3]),new Uint8Array([7,8,8]),new Uint8Array([8,6,5]),new Uint8Array([8,7,8]),new Uint8Array([8,8,7]),new Uint8Array([8,8,8])],wt=0;function Mt(t,n,e,i){var a=void 0,r=0;return n<e?(a=n,r=0):(a=e,r=1),i<a&&(r=2),bt[t][r]}var St=function(){function e(){t(this,e)}return n(e,null,[{key:\"intersectOctree\",value:function(t,n,e){var i=kt.min.set(0,0,0),a=kt.max.subVectors(t.max,t.min),r=t.getDimensions(gt[0]),s=gt[1].copy(r).multiplyScalar(.5),o=zt.origin.copy(n.ray.origin),l=zt.direction.copy(n.ray.direction),u=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,p=void 0;o.sub(t.getCenter(gt[2])).add(s),wt=0,l.x<0&&(o.x=r.x-o.x,l.x=-l.x,wt|=4),l.y<0&&(o.y=r.y-o.y,l.y=-l.y,wt|=2),l.z<0&&(o.z=r.z-o.z,l.z=-l.z,wt|=1),u=1/l.x,h=1/l.y,c=1/l.z,d=(i.x-o.x)*u,v=(a.x-o.x)*u,m=(i.y-o.y)*h,y=(a.y-o.y)*h,f=(i.z-o.z)*c,p=(a.z-o.z)*c,Math.max(Math.max(d,m),f)<Math.min(Math.min(v,y),p)&&function t(n,e,i,a,r,s,o,l,u){var h=n.children,c=void 0,d=void 0,v=void 0,m=void 0;if(r>=0&&s>=0&&o>=0)if(null===h)u.push(n);else{c=function(t,n,e,i,a,r){var s=0;return t>n&&t>e?(a<t&&(s|=2),r<t&&(s|=1)):n>e?(i<n&&(s|=4),r<n&&(s|=1)):(i<e&&(s|=4),a<e&&(s|=2)),s}(e,i,a,d=.5*(e+r),v=.5*(i+s),m=.5*(a+o));do{switch(c){case 0:t(h[wt],e,i,a,d,v,m,l,u),c=Mt(c,d,v,m);break;case 1:t(h[1^wt],e,i,m,d,v,o,l,u),c=Mt(c,d,v,o);break;case 2:t(h[2^wt],e,v,a,d,s,m,l,u),c=Mt(c,d,s,m);break;case 3:t(h[3^wt],e,v,m,d,s,o,l,u),c=Mt(c,d,s,o);break;case 4:t(h[4^wt],d,i,a,r,v,m,l,u),c=Mt(c,r,v,m);break;case 5:t(h[5^wt],d,i,m,r,v,o,l,u),c=Mt(c,r,v,o);break;case 6:t(h[6^wt],d,v,a,r,s,m,l,u),c=Mt(c,r,s,m);break;case 7:t(h[7^wt],d,v,m,r,s,o,l,u),c=8}}while(c<8)}}(t.root,d,m,f,v,y,p,n,e)}}]),e}(),Ct=new d;var Ot=function(){function e(n,i){t(this,e),this.root=void 0!==n&&void 0!==i?new dt(n,i):null}return n(e,[{key:\"getCenter\",value:function(t){return this.root.getCenter(t)}},{key:\"getDimensions\",value:function(t){return this.root.getDimensions(t)}},{key:\"getDepth\",value:function(){return function t(n){var e=n.children,i=0,a=void 0,r=void 0,s=void 0;if(null!==e)for(a=0,r=e.length;a<r;++a)(s=1+t(e[a]))>i&&(i=s);return i}(this.root)}},{key:\"cull\",value:function(t){var n=[];return function t(n,e,i){var a=n.children,r=void 0,s=void 0;if(Ct.min=n.min,Ct.max=n.max,e.intersectsBox(Ct))if(null!==a)for(r=0,s=a.length;r<s;++r)t(a[r],e,i);else i.push(n)}(this.root,t,n),n}},{key:\"findOctantsByLevel\",value:function(t){var n=[];return function t(n,e,i,a){var r=n.children,s=void 0,o=void 0;if(i===e)a.push(n);else if(null!==r)for(++i,s=0,o=r.length;s<o;++s)t(r[s],e,i,a)}(this.root,t,0,n),n}},{key:\"raycast\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return St.intersectOctree(this,t,n),n}},{key:\"leaves\",value:function(t){return new xt(this,t)}},{key:Symbol.iterator,value:function(){return new xt(this)}},{key:\"min\",get:function(){return this.root.min}},{key:\"max\",get:function(){return this.root.max}},{key:\"children\",get:function(){return this.root.children}}]),e}(),Dt=new h,Pt=function(e){i(s,dt);function s(n,e){t(this,s);var i=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this,n,e));return i.points=null,i.data=null,i}return n(s,[{key:\"distanceToSquared\",value:function(t){return Dt.copy(t).clamp(this.min,this.max).sub(t).lengthSquared()}},{key:\"distanceToCenterSquared\",value:function(t){var n=this.getCenter(Dt),e=t.x-n.x,i=t.y-n.x,a=t.z-n.z;return e*e+i*i+a*a}},{key:\"contains\",value:function(t,n){var e=this.min,i=this.max;return t.x>=e.x-n&&t.y>=e.y-n&&t.z>=e.z-n&&t.x<=i.x+n&&t.y<=i.y+n&&t.z<=i.z+n}},{key:\"redistribute\",value:function(t){var n=this.children,e=this.points,i=this.data,a=void 0,r=void 0,s=void 0,o=void 0,l=void 0,u=void 0,h=void 0;if(null!==n)for(a=0,s=e.length;a<s;++a)for(u=e[a],h=i[a],r=0,o=n.length;r<o;++r)if((l=n[r]).contains(u,t)){null===l.points&&(l.points=[],l.data=[]),l.points.push(u),l.data.push(h);break}this.points=null,this.data=null}},{key:\"merge\",value:function(){var t=this.children,n=void 0,e=void 0,i=void 0;if(null!==t){for(this.points=[],this.data=[],n=0,e=t.length;n<e;++n)if(null!==(i=t[n]).points){var a,s;(a=this.points).push.apply(a,r(i.points)),(s=this.data).push.apply(s,r(i.data))}this.children=null}}}]),s}(),At=function n(e,i,a){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;t(this,n),this.distance=e,this.distanceToRay=i,this.point=a,this.object=r},_t=1e-6;function qt(t){var n=t.children,e=0,i=void 0,a=void 0;if(null!==n)for(i=0,a=n.length;i<a;++i)e+=qt(n[i]);else null!==t.points&&(e=t.points.length);return e}function It(t,n,e,i,a){var r=i.children,s=!1,o=!1,l=void 0,u=void 0;if(i.contains(t,e.bias)){if(null===r){if(null===i.points)i.points=[],i.data=[];else for(l=0,u=i.points.length;!s&&l<u;++l)s=i.points[l].equals(t);s?(i.data[l-1]=n,o=!0):i.points.length<e.maxPoints||a===e.maxDepth?(i.points.push(t.clone()),i.data.push(n),++e.pointCount,o=!0):(i.split(),i.redistribute(e.bias),r=i.children)}if(null!==r)for(++a,l=0,u=r.length;!o&&l<u;++l)o=It(t,n,e,r[l],a)}return o}function Et(t,n,e,i){var a=e.children,r=null,s=void 0,o=void 0,l=void 0,u=void 0,h=void 0;if(e.contains(t,n.bias))if(null!==a)for(s=0,o=a.length;null===r&&s<o;++s)r=Et(t,n,a[s],e);else if(null!==e.points)for(l=e.points,u=e.data,s=0,o=l.length;s<o;++s)if(l[s].equals(t)){h=o-1,r=u[s],s<h&&(l[s]=l[h],u[s]=u[h]),l.pop(),u.pop(),--n.pointCount,null!==i&&qt(i)<=n.maxPoints&&i.merge();break}return r}!function(r){i(s,Ot);function s(n,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:8;t(this,s);var l=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this));return l.root=new Pt(n,e),l.bias=Math.max(0,i),l.maxPoints=Math.max(1,Math.round(r)),l.maxDepth=Math.max(0,Math.round(o)),l.pointCount=0,l}n(s,[{key:\"countPoints\",value:function(t){return qt(t)}},{key:\"put\",value:function(t,n){return It(t,n,this,this.root,0)}},{key:\"remove\",value:function(t){return Et(t,this,this.root,null)}},{key:\"fetch\",value:function(t){return function t(n,e,i){var a=i.children,r=null,s=void 0,o=void 0,l=void 0;if(i.contains(n,e.bias))if(null!==a)for(s=0,o=a.length;null===r&&s<o;++s)r=t(n,e,a[s]);else for(s=0,o=(l=i.points).length;null===r&&s<o;++s)n.distanceToSquared(l[s])<=_t&&(r=i.data[s]);return r}(t,this,this.root)}},{key:\"move\",value:function(t,n){return function t(n,e,i,a,r,s){var o=a.children,l=null,u=void 0,h=void 0,c=void 0;if(a.contains(n,i.bias))if(a.contains(e,i.bias)){if(null!==o)for(++s,u=0,h=o.length;null===l&&u<h;++u)l=t(n,e,i,o[u],a,s);else for(u=0,h=(c=a.points).length;u<h;++u)if(n.distanceToSquared(c[u])<=_t){c[u].copy(e),l=a.data[u];break}}else It(e,l=Et(n,i,a,r),i,r,s-1);return l}(t,n,this,this.root,null,0)}},{key:\"findNearestPoint\",value:function(t){return function t(n,e,i,a){var r=a.points,s=a.children,o=null,l=e,u=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;if(null!==s)for(u=0,h=(v=s.map(function(t){return{octant:t,distance:t.distanceToCenterSquared(n)}}).sort(function(t,n){return t.distance-n.distance})).length;u<h;++u)(m=v[u].octant).contains(n,l)&&null!==(y=t(n,l,i,m))&&(d=y.point.distanceToSquared(n),(!i||d>0)&&d<l&&(l=d,o=y));else if(null!==r)for(u=0,h=r.length;u<h;++u)c=r[u],d=n.distanceToSquared(c),(!i||d>0)&&d<l&&(l=d,o={point:c.clone(),data:a.data[u]});return o}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1/0,arguments.length>2&&void 0!==arguments[2]&&arguments[2],this.root)}},{key:\"findPoints\",value:function(t,n){var e=[];return function t(n,e,i,a,r){var s=a.points,o=a.children,l=e*e,u=void 0,h=void 0,c=void 0,d=void 0,v=void 0;if(null!==o)for(u=0,h=o.length;u<h;++u)(v=o[u]).contains(n,e)&&t(n,e,i,v,r);else if(null!==s)for(u=0,h=s.length;u<h;++u)c=s[u],d=n.distanceToSquared(c),(!i||d>0)&&d<=l&&r.push({point:c.clone(),data:a.data[u]})}(t,n,arguments.length>2&&void 0!==arguments[2]&&arguments[2],this.root,e),e}},{key:\"raycast\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],i=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"raycast\",this).call(this,t);return i.length>0&&this.testPoints(i,t,n),n}},{key:\"testPoints\",value:function(t,n,e){var i=n.params.Points.threshold,a=i*i,r=void 0,s=void 0,o=void 0,l=void 0,u=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;for(u=0,c=t.length;u<c;++u)if(null!==(m=(v=t[u]).points))for(h=0,d=m.length;h<d;++h)y=m[h],(l=n.ray.distanceSqToPoint(y))<a&&(r=n.ray.closestPointToPoint(y),(s=n.ray.origin.distanceTo(r))>=n.near&&s<=n.far&&(o=Math.sqrt(l),e.push(new At(s,o,r,v.data[h]))))}}])}();var Tt=new d,Vt=new h,Ft=new h,Rt=new h,Ut=(function(){function e(){t(this,e)}n(e,null,[{key:\"recycleOctants\",value:function(t,n){var e=t.min,i=t.getCenter(Ft),a=t.getDimensions(Rt).multiplyScalar(.5),r=t.children,s=n.length,o=void 0,l=void 0,u=void 0,h=void 0;for(o=0;o<8;++o)for(u=vt[o],Tt.min.addVectors(e,Vt.fromArray(u).multiply(a)),Tt.max.addVectors(i,Vt.fromArray(u).multiply(a)),l=0;l<s;++l)if(null!==(h=n[l])&&Tt.min.equals(h.min)&&Tt.max.equals(h.max)){r[o]=h,n[l]=null;break}}}])}(),new h),Lt=new h,Bt=new h,$t=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h;t(this,e),this.a=n,this.b=i,this.index=-1,this.coordinates=new h,this.t=0,this.n=new h}return n(e,[{key:\"approximateZeroCrossing\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8,e=Math.max(1,n-1),i=0,a=1,r=0,s=0,o=void 0,l=void 0;for(Ut.subVectors(this.b,this.a);s<=e&&(r=(i+a)/2,Lt.addVectors(this.a,Bt.copy(Ut).multiplyScalar(r)),l=t.sample(Lt),!(Math.abs(l)<=1e-4||(a-i)/2<=1e-6));)Lt.addVectors(this.a,Bt.copy(Ut).multiplyScalar(i)),o=t.sample(Lt),Math.sign(l)===Math.sign(o)?i=r:a=r,++s;this.t=r}},{key:\"computeZeroCrossingPosition\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.b,this.a).multiplyScalar(this.t).add(this.a)}},{key:\"computeSurfaceNormal\",value:function(t){var n=this.computeZeroCrossingPosition(Ut),e=t.sample(Lt.addVectors(n,Bt.set(.001,0,0)))-t.sample(Lt.subVectors(n,Bt.set(.001,0,0))),i=t.sample(Lt.addVectors(n,Bt.set(0,.001,0)))-t.sample(Lt.subVectors(n,Bt.set(0,.001,0))),a=t.sample(Lt.addVectors(n,Bt.set(0,0,.001)))-t.sample(Lt.subVectors(n,Bt.set(0,0,.001)));this.n.set(e,i,a).normalize()}}]),e}(),Nt=new $t,jt=new h,Xt=new h,Yt=function(){function e(n,i,a){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:3;t(this,e),this.edgeData=n,this.cellPosition=i,this.cellSize=a,this.indices=null,this.zeroCrossings=null,this.normals=null,this.axes=null,this.lengths=null,this.result=new ht,this.initialC=r,this.c=r,this.initialD=s,this.d=s,this.i=0,this.l=0,this.reset()}return n(e,[{key:\"reset\",value:function(){var t=this.edgeData,n=[],e=[],i=[],a=[],r=[],s=void 0,o=void 0,l=void 0,u=void 0;for(this.i=0,this.c=0,this.d=0,s=4>>(o=this.initialC),l=this.initialD;o<l;++o,s>>=1)(u=t.indices[o].length)>0&&(n.push(t.indices[o]),e.push(t.zeroCrossings[o]),i.push(t.normals[o]),a.push(vt[s]),r.push(u),++this.d);return this.l=r.length>0?r[0]:0,this.indices=n,this.zeroCrossings=e,this.normals=i,this.axes=a,this.lengths=r,this.result.reset(),this}},{key:\"next\",value:function(){var t=this.cellSize,n=Gt.resolution,e=n+1,i=e*e,a=this.result,r=this.cellPosition,s=void 0,o=void 0,l=void 0,u=void 0,h=void 0,c=void 0,d=void 0;return this.i===this.l&&(this.l=++this.c<this.d?this.lengths[this.c]:0,this.i=0),this.i<this.l?(c=this.c,d=this.i,s=this.axes[c],o=this.indices[c][d],Nt.index=o,l=o%e,u=Math.trunc(o%i/e),h=Math.trunc(o/i),Nt.coordinates.set(l,u,h),jt.set(l*t/n,u*t/n,h*t/n),Xt.set((l+s[0])*t/n,(u+s[1])*t/n,(h+s[2])*t/n),Nt.a.addVectors(r,jt),Nt.b.addVectors(r,Xt),Nt.t=this.zeroCrossings[c][d],Nt.n.fromArray(this.normals[c],3*d),a.value=Nt,++this.i):(a.value=null,a.done=!0),a}},{key:\"return\",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),Zt=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n;t(this,e),this.indices=n<=0?null:[new Uint32Array(n),new Uint32Array(i),new Uint32Array(a)],this.zeroCrossings=n<=0?null:[new Float32Array(n),new Float32Array(i),new Float32Array(a)],this.normals=n<=0?null:[new Float32Array(3*n),new Float32Array(3*i),new Float32Array(3*a)]}return n(e,[{key:\"serialize\",value:function(){return{edges:this.edges,zeroCrossings:this.zeroCrossings,normals:this.normals}}},{key:\"deserialize\",value:function(t){var n=this;return null!==t?(this.edges=t.edges,this.zeroCrossings=t.zeroCrossings,this.normals=t.normals):n=null,n}},{key:\"createTransferList\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=[this.edges[0],this.edges[1],this.edges[2],this.zeroCrossings[0],this.zeroCrossings[1],this.zeroCrossings[2],this.normals[0],this.normals[1],this.normals[2]],e=void 0,i=void 0,a=void 0;for(i=0,a=n.length;i<a;++i)null!==(e=n[i])&&t.push(e.buffer);return t}},{key:\"edges\",value:function(t,n){return new Yt(this,t,n)}},{key:\"edgesX\",value:function(t,n){return new Yt(this,t,n,0,1)}},{key:\"edgesY\",value:function(t,n){return new Yt(this,t,n,1,2)}},{key:\"edgesZ\",value:function(t,n){return new Yt(this,t,n,2,3)}}],[{key:\"calculate1DEdgeCount\",value:function(t){return Math.pow(t+1,2)*t}}]),e}(),Ht=0,Qt=0;var Gt=function(){function e(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];t(this,e),this.materials=0,this.materialIndices=n?new Uint8Array(Qt):null,this.runLengths=null,this.edgeData=null}return n(e,[{key:\"set\",value:function(t){return this.materials=t.materials,this.materialIndices=t.materialIndices,this.runLengths=t.runLengths,this.edgeData=t.edgeData,this}},{key:\"clear\",value:function(){return this.materials=0,this.materialIndices=null,this.runLengths=null,this.edgeData=null,this}},{key:\"setMaterialIndex\",value:function(t,n){this.materialIndices[t]===Y.AIR?n!==Y.AIR&&++this.materials:n===Y.AIR&&--this.materials,this.materialIndices[t]=n}},{key:\"compress\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this,n=void 0;return this.compressed?(t.materialIndices=this.materialIndices,t.runLengths=this.runLengths):(n=this.full?new ut([this.materialIndices.length],[Y.SOLID]):ut.encode(this.materialIndices),t.materialIndices=new Uint8Array(n.data),t.runLengths=new Uint32Array(n.runLengths)),t.materials=this.materials,t}},{key:\"decompress\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this;return t.materialIndices=this.compressed?ut.decode(this.runLengths,this.materialIndices,new Uint8Array(Qt)):this.materialIndices,t.runLengths=null,t.materials=this.materials,t}},{key:\"serialize\",value:function(){return{materials:this.materials,materialIndices:this.materialIndices,runLengths:this.runLengths,edgeData:null!==this.edgeData?this.edgeData.serialize():null}}},{key:\"deserialize\",value:function(t){var n=this;return null!==t?(this.materials=t.materials,this.materialIndices=t.materialIndices,this.runLengths=t.runLengths,null!==t.edgeData?(null===this.edgeData&&(this.edgeData=new Zt),this.edgeData.deserialize(t.edgeData)):this.edgeData=null):n=null,n}},{key:\"createTransferList\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return null!==this.edgeData&&this.edgeData.createTransferList(t),null!==this.materialIndices&&t.push(this.materialIndices.buffer),null!==this.runLengths&&t.push(this.runLengths.buffer),t}},{key:\"empty\",get:function(){return 0===this.materials}},{key:\"full\",get:function(){return this.materials===Qt}},{key:\"compressed\",get:function(){return null!==this.runLengths}},{key:\"neutered\",get:function(){return!this.empty&&null===this.materialIndices}}],[{key:\"resolution\",get:function(){return Ht},set:function(t){Ht=Math.max(1,Math.min(256,(n=t,Math.pow(2,Math.max(0,Math.ceil(Math.log2(n)))))));var n;Qt=Math.pow(Ht+1,3)}}]),e}(),Kt=function(){function e(){t(this,e)}return n(e,null,[{key:\"parseBin\",value:function(t){return parseInt(t,2)}},{key:\"createBinaryString\",value:function(t){for(var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:64,e=t<0?\"-\":\"\",i=Math.abs(t).toString(2);i.length<n;)i=\"0\"+i;return e+i}}]),e}(),Wt=function(){function e(n,i,a){t(this,e),this.keyDesign=n,this.min=i,this.max=a,this.keyBase=new h,this.key=new h,this.limit=new h,this.result=new ht,this.reset()}return n(e,[{key:\"reset\",value:function(){var t=this.keyDesign,n=this.min,e=this.max;return n.x<=e.x&&n.y<=e.y&&n.z<=e.z?(this.keyBase.set(n.x,n.y*t.rangeX,n.z*t.rangeXY),this.limit.set(e.x,e.y*t.rangeX,e.z*t.rangeXY),this.key.copy(this.keyBase)):(this.keyBase.set(1,1,1),this.limit.set(0,0,0),this.key.copy(this.keyBase),console.error(\"Invalid key range\",n,e)),this.result.reset(),this}},{key:\"next\",value:function(){var t=this.result,n=this.keyDesign,e=this.keyBase,i=this.limit,a=this.key;return a.z<=i.z?(t.value=a.z+a.y+a.x,++a.x,a.x>i.x&&(a.x=e.x,a.y+=n.rangeX,a.y>i.y&&(a.y=e.y,a.z+=n.rangeXY))):(t.value=null,t.done=!0),t}},{key:\"return\",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),Jt=Math.pow(2,32),tn=53,nn=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Math.round(.4*tn),i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Math.round(.2*tn),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n;t(this,e),this.x=0,this.y=0,this.z=0,this.rangeX=0,this.rangeY=0,this.rangeZ=0,this.rangeXY=0,this.halfRange=null,this.maskX=[0,0],this.maskY=[0,0],this.maskZ=[0,0],this.set(n,i,a)}return n(e,[{key:\"set\",value:function(t,n,e){(t+n+e>tn||t>32||n>32||e>32)&&(console.warn(\"Invalid bit allotment\"),t=Math.round(.4*tn),n=Math.round(.2*tn),e=t),this.x=t,this.y=n,this.z=e,this.rangeX=Math.pow(2,t),this.rangeY=Math.pow(2,n),this.rangeZ=Math.pow(2,e),this.rangeXY=Math.pow(2,t+n),this.halfRange=new h(this.rangeX/2,this.rangeY/2,this.rangeZ/2),this.updateBitMasks()}},{key:\"updateBitMasks\",value:function(){var t=this.x,n=this.y,e=this.z,i=this.maskX,a=this.maskY,r=this.maskZ,s=32-Math.max(0,t-32),o=32-Math.max(0,n+t-32),l=32-Math.max(0,e+n+t-32);i[1]=s<32?-1>>>s:0,i[0]=-1>>>Math.max(0,32-t),a[1]=((o<32?-1>>>o:0)&~i[1])>>>0,a[0]=(-1>>>Math.max(0,32-(t+n))&~i[0])>>>0,r[1]=((l<32?-1>>>l:0)&~a[1]&~i[1])>>>0,r[0]=(-1>>>Math.max(0,32-(t+n+e))&~a[0]&~i[0])>>>0}},{key:\"unpackKey\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,e=this.maskX,i=this.maskY,a=this.maskZ,r=Math.trunc(t/Jt),s=t%Jt;return n.set((r&e[1])*Jt+((s&e[0])>>>0),((r&i[1])*Jt+((s&i[0])>>>0))/this.rangeX,((r&a[1])*Jt+((s&a[0])>>>0))/this.rangeXY)}},{key:\"packKey\",value:function(t){return t.z*this.rangeXY+t.y*this.rangeX+t.x}},{key:\"keyRange\",value:function(t,n){return new Wt(this,t,n)}},{key:\"toString\",value:function(){var t=this.maskX,n=this.maskY,e=this.maskZ;return\"Key Design\\n\\nX-Bits: \"+this.x+\"\\nY-Bits: \"+this.y+\"\\nZ-Bits: \"+this.z+\"\\n\\n\"+Kt.createBinaryString(t[1],32)+\" \"+t[1]+\" (HI-Mask X)\\n\"+Kt.createBinaryString(t[0],32)+\" \"+t[0]+\" (LO-Mask X)\\n\\n\"+Kt.createBinaryString(n[1],32)+\" \"+n[1]+\" (HI-Mask Y)\\n\"+Kt.createBinaryString(n[0],32)+\" \"+n[0]+\" (LO-Mask Y)\\n\\n\"+Kt.createBinaryString(e[1],32)+\" \"+e[1]+\" (HI-Mask Z)\\n\"+Kt.createBinaryString(e[0],32)+\" \"+e[0]+\" (LO-Mask Z)\\n\"}}],[{key:\"BITS\",get:function(){return tn}},{key:\"HI_BITS\",get:function(){return 21}},{key:\"LO_BITS\",get:function(){return 32}}]),e}(),en=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,e),this.octant=n,this.min=new h,this.max=new h}return n(e,[{key:\"getCenter\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).addVectors(this.min,this.max).multiplyScalar(.5)}},{key:\"getDimensions\",value:function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:new h).subVectors(this.max,this.min)}},{key:\"containsPoint\",value:function(t){var n=this.min,e=this.max;return t.x>=n.x&&t.y>=n.y&&t.z>=n.z&&t.x<=e.x&&t.y<=e.y&&t.z<=e.z}}]),e}(),an=function(){function e(n){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t(this,e),this.world=n,this.lod=i,this.cellSize=0,this.iterator=null,this.octantWrapper=new en,this.result=new ht,this.reset()}return n(e,[{key:\"reset\",value:function(){var t=this.lod,n=this.world,e=n.getGrid(t);return void 0!==e?(this.cellSize=n.getCellSize(t),this.iterator=e.entries(),this.result.reset()):console.error(\"Invalid LOD\",t),this}},{key:\"next\",value:function(){var t=this.result,n=this.octantWrapper,e=this.iterator.next(),i=e.value;return e.done?(t.value=null,t.done=!0):(this.keyDesign.unpackKey(i[0],n.min),n.min.multiplyScalar(this.cellSize),n.min.add(this.world.min),n.max.copy(n.min).addScalar(this.cellSize),n.octant=i[1],t.value=n),t}},{key:\"return\",value:function(t){return this.result.value=t,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),rn=function n(){t(this,n),this.data=null,this.csg=new s,this.mesh=null},sn=function(n){i(e,rn);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return n.children=0,n}return e}(),on=new h,ln=new h,un=new d,hn=new d,cn=new d,dn=[];function vn(t,n,e,i,a,r,s){var o=void 0,l=void 0,u=void 0,h=void 0,c=void 0,d=void 0;if(e.csg.add(n),s>0)for(--s,o=t.getGrid(s),l=t.getKeyDesign(),u=e.children,h=dn[s],i<<=1,a<<=1,r<<=1,d=0;d<8;++d)0!=(u&1<<d)&&(c=vt[d],on.set(i+c[0],a+c[1],r+c[2]),h.containsPoint(on)&&vn(t,n,o.get(l.packKey(on)),on.x,on.y,on.z,s))}var mn=function(){function e(){t(this,e)}return n(e,null,[{key:\"applyUnion\",value:function(t,n,e){var i=t.getKeyDesign(),a=t.lodZero,r=hn.min,s=hn.max,o=cn.min,l=cn.max,u=cn,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0;for(m=t.getDepth();m>0;--m){d=t.getGrid(m),t.calculateKeyCoordinates(n.min,m,r),t.calculateKeyCoordinates(n.max,m,s),t.calculateKeyCoordinates(n.min,m-1,o),t.calculateKeyCoordinates(n.max,m-1,l);var f=!0,p=!1,x=void 0;try{for(var g,k=i.keyRange(r,s)[Symbol.iterator]();!(f=(g=k.next()).done);f=!0)if(h=g.value,!d.has(h))for((v=new sn).csg.add(e),d.set(h,v),i.unpackKey(h,ln),ln.x<<=1,ln.y<<=1,ln.z<<=1,y=0;y<8;++y)c=vt[y],on.set(ln.x+c[0],ln.y+c[1],ln.z+c[2]),u.containsPoint(on)&&(v.children|=1<<y)}catch(t){p=!0,x=t}finally{try{!f&&k.return&&k.return()}finally{if(p)throw x}}}t.calculateKeyCoordinates(n.min,0,r),t.calculateKeyCoordinates(n.max,0,s);var z=!0,b=!1,w=void 0;try{for(var M,S=i.keyRange(r,s)[Symbol.iterator]();!(z=(M=S.next()).done);z=!0)h=M.value,a.has(h)?v=a.get(h):(v=new rn,a.set(h,v)),v.csg.add(e)}catch(t){b=!0,w=t}finally{try{!z&&S.return&&S.return()}finally{if(b)throw w}}}},{key:\"applyDifference\",value:function(t,n,e){var i=t.getDepth(),a=t.getKeyDesign(),r=t.getGrid(i),s=t.calculateKeyCoordinates(n.min,i,hn.min),o=t.calculateKeyCoordinates(n.max,i,hn.max),l=void 0,u=void 0,h=void 0,c=void 0;for(l=0,u=i-1;l<u;++l)l<dn.length?(h=dn[l],t.calculateKeyCoordinates(n.min,l,h.min),t.calculateKeyCoordinates(n.max,l,h.max)):dn.push(new d(t.calculateKeyCoordinates(n.min,l),t.calculateKeyCoordinates(n.max,l)));var v=!0,m=!1,y=void 0;try{for(var f,p=a.keyRange(s,o)[Symbol.iterator]();!(v=(f=p.next()).done);v=!0)c=f.value,r.has(c)&&(a.unpackKey(c,ln),vn(t,e,r.get(c),ln.x,ln.y,ln.z,i))}catch(t){m=!0,y=t}finally{try{!v&&p.return&&p.return()}finally{if(m)throw y}}}},{key:\"applyIntersection\",value:function(t,n){var e=void 0;for(e=t.getDepth();e>=0;--e){var i=!0,a=!1,r=void 0;try{for(var s,o=t.getGrid(e).values()[Symbol.iterator]();!(i=(s=o.next()).done);i=!0)s.value.csg.add(n)}catch(t){a=!0,r=t}finally{try{!i&&o.return&&o.return()}finally{if(a)throw r}}}}},{key:\"applyCSG\",value:function(t,n){var e=un.copy(n.completeBoundingBox);switch(e.min.max(t.min),e.max.min(t.max),n.operation){case u.UNION:this.applyUnion(t,e,n);break;case u.DIFFERENCE:this.applyDifference(t,e,n);break;case u.INTERSECTION:this.applyIntersection(t,n);break;default:console.error(\"No CSG operation type specified\",n)}}}]),e}(),yn=new h,fn=new F,pn=new d,xn=new d,gn=new N,kn=[new Uint8Array([4,2,1]),new Uint8Array([5,3,8]),new Uint8Array([6,8,3]),new Uint8Array([7,8,8]),new Uint8Array([8,6,5]),new Uint8Array([8,7,8]),new Uint8Array([8,8,7]),new Uint8Array([8,8,8])],zn=0;function bn(t,n,e,i){var a=void 0,r=0;return n<e?(a=n,r=0):(a=e,r=1),i<a&&(r=2),kn[t][r]}function wn(t,n,e,i,a){var r=pn.min.set(0,0,0),s=pn.max.subVectors(n.max,n.min),o=n.getDimensions(xn.min),l=xn.max.copy(o).multiplyScalar(.5),u=gn.origin.copy(i.origin),h=gn.direction.copy(i.direction),c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,p=void 0,x=void 0,g=void 0;u.sub(n.getCenter(yn)).add(l),zn=0,h.x<0&&(u.x=o.x-u.x,h.x=-h.x,zn|=4),h.y<0&&(u.y=o.y-u.y,h.y=-h.y,zn|=2),h.z<0&&(u.z=o.z-u.z,h.z=-h.z,zn|=1),c=1/h.x,d=1/h.y,v=1/h.z,m=(r.x-u.x)*c,y=(s.x-u.x)*c,f=(r.y-u.y)*d,p=(s.y-u.y)*d,x=(r.z-u.z)*v,g=(s.z-u.z)*v,function t(n,e,i,a,r,s,o,l,u,h,c,d,v){var m=void 0,y=void 0,f=void 0,p=void 0,x=void 0,g=void 0,k=void 0,z=void 0,b=void 0;if(h>=0&&c>=0&&d>=0)if(0===s||null!==e.mesh)v.push(e);else if(e.children>0){m=n.getGrid(--s),y=n.getKeyDesign(),f=e.children,i<<=1,a<<=1,r<<=1,x=function(t,n,e,i,a,r){var s=0;return t>n&&t>e?(a<t&&(s|=2),r<t&&(s|=1)):n>e?(i<n&&(s|=4),r<n&&(s|=1)):(i<e&&(s|=4),a<e&&(s|=2)),s}(o,l,u,g=.5*(o+h),k=.5*(l+c),z=.5*(u+d));do{switch(b=zn^x,x){case 0:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,o,l,u,g,k,z,v)),x=bn(x,g,k,z);break;case 1:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,o,l,z,g,k,d,v)),x=bn(x,g,k,d);break;case 2:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,o,k,u,g,c,z,v)),x=bn(x,g,c,z);break;case 3:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,o,k,z,g,c,d,v)),x=bn(x,g,c,d);break;case 4:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,g,l,u,h,k,z,v)),x=bn(x,h,k,z);break;case 5:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,g,l,z,h,k,d,v)),x=bn(x,h,k,d);break;case 6:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,g,k,u,h,c,z,v)),x=bn(x,h,c,z);break;case 7:0!=(f&1<<b)&&(p=vt[b],yn.set(i+p[0],a+p[1],r+p[2]),t(n,m.get(y.packKey(yn)),yn.x,yn.y,yn.z,s,g,k,z,h,c,d,v)),x=8}}while(x<8)}}(t,n.octant,e.x,e.y,e.z,t.getDepth(),m,f,x,y,p,g,a)}var Mn=function(){function e(){t(this,e)}return n(e,null,[{key:\"intersectWorldOctree\",value:function(t,n){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],i=t.getDepth(),a=t.getGrid(i),r=t.getCellSize(i),s=t.getKeyDesign(),o=new en,l=fn.start,u=fn.end,h=t.containsPoint(gn.copy(n).origin)?gn.origin:gn.intersectBox(t,gn.origin),c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,p=void 0,x=void 0,g=void 0,k=void 0,z=void 0,b=void 0,w=void 0,M=void 0,S=void 0,C=void 0,O=void 0,D=void 0,P=void 0,A=void 0;if(null!==h)for(v=r<<1,m=gn.at(v,yn),t.calculateKeyCoordinates(h,i,l),t.calculateKeyCoordinates(m,i,u),f=u.x-l.x,p=u.y-l.y,x=u.z-l.z,S=Math.sign(f),C=Math.sign(p),O=Math.sign(x),b=2*(g=Math.abs(f)),w=2*(k=Math.abs(p)),M=2*(z=Math.abs(x)),D=k-g,P=z-g,A=k-z,y=g+k+z;y>0;--y)c=s.packKey(l),a.has(c)&&(null===(d=a.get(c)).mesh?(o.octant=d,o.min.copy(l),o.min.multiplyScalar(r),o.min.add(t.min),o.max.copy(o.min).addScalar(r),wn(t,o,l,n,e)):e.push(d)),D<0?P<0?(l.x+=S,D+=w,P+=M):(l.z+=O,P-=b,A+=w):A<0?(l.z+=O,P-=b,A+=w):(l.y+=C,D-=b,A-=M);return e}}]),e}(),Sn=new h;var Cn=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:20,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new nn;for(t(this,e),this.cellSize=n,this.keyDesign=a,this.grids=[],i=Math.max(i,1);this.grids.length<i;)this.grids.push(new Map);this.bounds=new en,this.bounds.min.copy(this.keyDesign.halfRange).multiplyScalar(-this.cellSize),this.bounds.max.copy(this.keyDesign.halfRange).multiplyScalar(this.cellSize)}return n(e,[{key:\"getKeyDesign\",value:function(){return this.keyDesign}},{key:\"getCellSize\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return this.cellSize<<t}},{key:\"getCenter\",value:function(t){return this.bounds.getCenter(t)}},{key:\"setCenter\",value:function(t){this.min.copy(this.keyDesign.halfRange).multiplyScalar(-this.cellSize).add(t),this.max.copy(this.keyDesign.halfRange).multiplyScalar(this.cellSize).add(t)}},{key:\"getDimensions\",value:function(t){return this.bounds.getDimensions(t)}},{key:\"getDepth\",value:function(){return this.grids.length-1}},{key:\"getGrid\",value:function(t){return t>=0&&t<this.grids.length?this.grids[t]:void 0}},{key:\"clear\",value:function(){var t=void 0,n=void 0;for(t=0,n=this.grids.length;t<n;++t)this.grids[t].clear()}},{key:\"containsPoint\",value:function(t){return this.bounds.containsPoint(t)}},{key:\"findOctantsByLevel\",value:function(t){return this.octants(t)}},{key:\"calculateKeyCoordinates\",value:function(t,n){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new h,i=this.cellSize<<n;return Sn.subVectors(t,this.min),e.set(Math.trunc(Sn.x/i),Math.trunc(Sn.y/i),Math.trunc(Sn.z/i)),e}},{key:\"getOctantByPoint\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.keyDesign,i=this.getGrid(n),a=void 0;return void 0!==i?this.containsPoint(t)?(this.calculateKeyCoordinates(t,n,Sn),a=i.get(e.packKey(Sn))):console.error(\"Position out of range\",t):console.error(\"Invalid LOD\",n),a}},{key:\"removeOctant\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=this.keyDesign,i=this.getGrid(n),a=void 0,r=void 0,s=void 0;void 0!==i?i.has(t)?(e.unpackKey(t,Sn),a=Sn.x,r=Sn.y,s=Sn.z,function t(n,e,i,a,r,s){var o=void 0,l=void 0,u=void 0,h=void 0,c=void 0,d=void 0,v=void 0;if(s>0){for(--s,o=n.getGrid(s),l=n.getKeyDesign(),u=e.children,i<<=1,a<<=1,r<<=1,v=0;v<8;++v)0!=(u&1<<v)&&(c=vt[v],Sn.set(i+c[0],a+c[1],r+c[2]),d=l.packKey(Sn),h=o.get(d),o.delete(d),t(n,h,Sn.x,Sn.y,Sn.z,s));e.children=0}}(this,i.get(t),a,r,s,n),i.delete(t),function t(n,e,i,a,r){var s=void 0,o=void 0,l=void 0,u=void 0;++r<n.levels&&(s=n.getGrid(r),o=Cn.calculateOffsetIndex(e,i,a),Sn.set(e>>>1,i>>>1,a>>>1),l=n.getKeyDesign().packKey(Sn),(u=s.get(l)).children&=~(1<<o),0===u.children&&(s.delete(l),t(n,Sn.x,Sn.y,Sn.z,r)))}(this,a,r,s,n)):console.error(\"No octant found\",t):console.error(\"Invalid LOD\",n)}},{key:\"applyCSG\",value:function(t){mn.applyCSG(this,t)}},{key:\"raycast\",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Mn.intersectWorldOctree(this,t,n)}},{key:\"octants\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return new an(this,t)}},{key:\"min\",get:function(){return this.bounds.min}},{key:\"max\",get:function(){return this.bounds.max}},{key:\"levels\",get:function(){return this.grids.length}},{key:\"lodZero\",get:function(){return this.grids[0]}}],[{key:\"calculateOffsetIndex\",value:function(t,n,e){return((1&t)<<2)+((1&n)<<1)+(1&e)}}]),e}(),On=function(){function e(n){t(this,e)}return n(e,[{key:\"clone\",value:function(){return new this.constructor(this.levels)}},{key:\"levels\",get:function(){return this.something.length}}]),e}(),Dn=function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.lod=-1,i.left=null,i.entered=null,i.error=null,i}return e}(),Pn=(new Dn(\"update\"),new Dn(\"error\"),new d,new E),An=new B,_n=function(e){i(r,l);function r(n){t(this,r);var e=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return e.world=n,e.position=new h(1/0,1/0,1/0),e.currentScene=new On(e.world.levels),e.previousScene=e.currentScene.clone(),e.nextScene=e.currentScene.clone(),e}return n(r,[{key:\"update\",value:function(t){this.position.copy(t.position),Pn.setFromMatrix(An.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse))}},{key:\"process\",value:function(){}},{key:\"clear\",value:function(){this.previousScene.clear(),this.currentScene.clear(),this.nextScene.clear()}}]),r}(),qn={EXTRACT:\"worker.extract\",MODIFY:\"worker.modify\",CONFIGURE:\"worker.config\",CLOSE:\"worker.close\"},In=function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,n),this.action=e,this.error=null},En=function(n){i(e,In);function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.data=null,i}return e}(),Tn=(function(n){i(e,En);function e(){return t(this,e),a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,qn.EXTRACT))}}(),function(n){i(e,En);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,qn.MODIFY));return n.sdf=null,n.cellSize=0,n.cellPosition=null,n}}(),function(n){i(e,In);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,qn.CONFIGURE));return n.resolution=Gt.resolution,n.errorThreshold=.01,n}return e}()),Vn=function(n){i(e,En);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,qn.EXTRACT));return n.isosurface=null,n}return e}(),Fn=function(n){i(e,En);function e(){t(this,e);var n=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,qn.MODIFY));return n.sdf=null,n}return e}(),Rn=new(function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.worker=null,i.response=null,i}return e}())(\"message\"),Un='(function () {\\n  \\'use strict\\';\\n\\n  var classCallCheck = function (instance, Constructor) {\\n    if (!(instance instanceof Constructor)) {\\n      throw new TypeError(\"Cannot call a class as a function\");\\n    }\\n  };\\n\\n  var createClass = function () {\\n    function defineProperties(target, props) {\\n      for (var i = 0; i < props.length; i++) {\\n        var descriptor = props[i];\\n        descriptor.enumerable = descriptor.enumerable || false;\\n        descriptor.configurable = true;\\n        if (\"value\" in descriptor) descriptor.writable = true;\\n        Object.defineProperty(target, descriptor.key, descriptor);\\n      }\\n    }\\n\\n    return function (Constructor, protoProps, staticProps) {\\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\\n      if (staticProps) defineProperties(Constructor, staticProps);\\n      return Constructor;\\n    };\\n  }();\\n\\n\\n\\n\\n\\n\\n\\n  var get = function get(object, property, receiver) {\\n    if (object === null) object = Function.prototype;\\n    var desc = Object.getOwnPropertyDescriptor(object, property);\\n\\n    if (desc === undefined) {\\n      var parent = Object.getPrototypeOf(object);\\n\\n      if (parent === null) {\\n        return undefined;\\n      } else {\\n        return get(parent, property, receiver);\\n      }\\n    } else if (\"value\" in desc) {\\n      return desc.value;\\n    } else {\\n      var getter = desc.get;\\n\\n      if (getter === undefined) {\\n        return undefined;\\n      }\\n\\n      return getter.call(receiver);\\n    }\\n  };\\n\\n  var inherits = function (subClass, superClass) {\\n    if (typeof superClass !== \"function\" && superClass !== null) {\\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\\n    }\\n\\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\\n      constructor: {\\n        value: subClass,\\n        enumerable: false,\\n        writable: true,\\n        configurable: true\\n      }\\n    });\\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\\n  };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  var possibleConstructorReturn = function (self, call) {\\n    if (!self) {\\n      throw new ReferenceError(\"this hasn\\'t been initialised - super() hasn\\'t been called\");\\n    }\\n\\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\\n  };\\n\\n\\n\\n  var set = function set(object, property, value, receiver) {\\n    var desc = Object.getOwnPropertyDescriptor(object, property);\\n\\n    if (desc === undefined) {\\n      var parent = Object.getPrototypeOf(object);\\n\\n      if (parent !== null) {\\n        set(parent, property, value, receiver);\\n      }\\n    } else if (\"value\" in desc && desc.writable) {\\n      desc.value = value;\\n    } else {\\n      var setter = desc.set;\\n\\n      if (setter !== undefined) {\\n        setter.call(receiver, value);\\n      }\\n    }\\n\\n    return value;\\n  };\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n  var toConsumableArray = function (arr) {\\n    if (Array.isArray(arr)) {\\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\\n\\n      return arr2;\\n    } else {\\n      return Array.from(arr);\\n    }\\n  };\\n\\n  var RunLengthEncoding = function () {\\n  \\t\\tfunction RunLengthEncoding() {\\n  \\t\\t\\t\\tvar runLengths = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\t\\t\\tvar data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n  \\t\\t\\t\\tclassCallCheck(this, RunLengthEncoding);\\n\\n\\n  \\t\\t\\t\\tthis.runLengths = runLengths;\\n\\n  \\t\\t\\t\\tthis.data = data;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(RunLengthEncoding, null, [{\\n  \\t\\t\\t\\tkey: \"encode\",\\n  \\t\\t\\t\\tvalue: function encode(array) {\\n\\n  \\t\\t\\t\\t\\t\\tvar runLengths = [];\\n  \\t\\t\\t\\t\\t\\tvar data = [];\\n\\n  \\t\\t\\t\\t\\t\\tvar previous = array[0];\\n  \\t\\t\\t\\t\\t\\tvar count = 1;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 1, l = array.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (previous !== array[i]) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\trunLengths.push(count);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdata.push(previous);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprevious = array[i];\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount = 1;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++count;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\trunLengths.push(count);\\n  \\t\\t\\t\\t\\t\\tdata.push(previous);\\n\\n  \\t\\t\\t\\t\\t\\treturn new RunLengthEncoding(runLengths, data);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"decode\",\\n  \\t\\t\\t\\tvalue: function decode(runLengths, data) {\\n  \\t\\t\\t\\t\\t\\tvar array = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar element = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    j = void 0,\\n  \\t\\t\\t\\t\\t\\t    il = void 0,\\n  \\t\\t\\t\\t\\t\\t    jl = void 0;\\n  \\t\\t\\t\\t\\t\\tvar k = 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, il = data.length; i < il; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\telement = data[i];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tfor (j = 0, jl = runLengths[i]; j < jl; ++j) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tarray[k++] = element;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn array;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn RunLengthEncoding;\\n  }();\\n\\n  var Vector3 = function () {\\n  \\tfunction Vector3() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Vector3);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n  \\t}\\n\\n  \\tcreateClass(Vector3, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(x, y, z) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(v) {\\n\\n  \\t\\t\\tthis.x = v.x;\\n  \\t\\t\\tthis.y = v.y;\\n  \\t\\t\\tthis.z = v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"fromArray\",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toArray\",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromSpherical\",\\n  \\t\\tvalue: function setFromSpherical(s) {\\n\\n  \\t\\t\\tvar sinPhiRadius = Math.sin(s.phi) * s.radius;\\n\\n  \\t\\t\\tthis.x = sinPhiRadius * Math.sin(s.theta);\\n  \\t\\t\\tthis.y = Math.cos(s.phi) * s.radius;\\n  \\t\\t\\tthis.z = sinPhiRadius * Math.cos(s.theta);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromCylindrical\",\\n  \\t\\tvalue: function setFromCylindrical(c) {\\n\\n  \\t\\t\\tthis.x = c.radius * Math.sin(c.theta);\\n  \\t\\t\\tthis.y = c.y;\\n  \\t\\t\\tthis.z = c.radius * Math.cos(c.theta);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromMatrixColumn\",\\n  \\t\\tvalue: function setFromMatrixColumn(m, index) {\\n\\n  \\t\\t\\treturn this.fromArray(m.elements, index * 4);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromMatrixPosition\",\\n  \\t\\tvalue: function setFromMatrixPosition(m) {\\n\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tthis.x = me[12];\\n  \\t\\t\\tthis.y = me[13];\\n  \\t\\t\\tthis.z = me[14];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromMatrixScale\",\\n  \\t\\tvalue: function setFromMatrixScale(m) {\\n\\n  \\t\\t\\tvar sx = this.setFromMatrixColumn(m, 0).length();\\n  \\t\\t\\tvar sy = this.setFromMatrixColumn(m, 1).length();\\n  \\t\\t\\tvar sz = this.setFromMatrixColumn(m, 2).length();\\n\\n  \\t\\t\\tthis.x = sx;\\n  \\t\\t\\tthis.y = sy;\\n  \\t\\t\\tthis.z = sz;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"add\",\\n  \\t\\tvalue: function add(v) {\\n\\n  \\t\\t\\tthis.x += v.x;\\n  \\t\\t\\tthis.y += v.y;\\n  \\t\\t\\tthis.z += v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addScalar\",\\n  \\t\\tvalue: function addScalar(s) {\\n\\n  \\t\\t\\tthis.x += s;\\n  \\t\\t\\tthis.y += s;\\n  \\t\\t\\tthis.z += s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addVectors\",\\n  \\t\\tvalue: function addVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x + b.x;\\n  \\t\\t\\tthis.y = a.y + b.y;\\n  \\t\\t\\tthis.z = a.z + b.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addScaledVector\",\\n  \\t\\tvalue: function addScaledVector(v, s) {\\n\\n  \\t\\t\\tthis.x += v.x * s;\\n  \\t\\t\\tthis.y += v.y * s;\\n  \\t\\t\\tthis.z += v.z * s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"sub\",\\n  \\t\\tvalue: function sub(v) {\\n\\n  \\t\\t\\tthis.x -= v.x;\\n  \\t\\t\\tthis.y -= v.y;\\n  \\t\\t\\tthis.z -= v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"subScalar\",\\n  \\t\\tvalue: function subScalar(s) {\\n\\n  \\t\\t\\tthis.x -= s;\\n  \\t\\t\\tthis.y -= s;\\n  \\t\\t\\tthis.z -= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"subVectors\",\\n  \\t\\tvalue: function subVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x - b.x;\\n  \\t\\t\\tthis.y = a.y - b.y;\\n  \\t\\t\\tthis.z = a.z - b.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiply\",\\n  \\t\\tvalue: function multiply(v) {\\n\\n  \\t\\t\\tthis.x *= v.x;\\n  \\t\\t\\tthis.y *= v.y;\\n  \\t\\t\\tthis.z *= v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiplyScalar\",\\n  \\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\tthis.x *= s;\\n  \\t\\t\\tthis.y *= s;\\n  \\t\\t\\tthis.z *= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiplyVectors\",\\n  \\t\\tvalue: function multiplyVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x * b.x;\\n  \\t\\t\\tthis.y = a.y * b.y;\\n  \\t\\t\\tthis.z = a.z * b.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"divide\",\\n  \\t\\tvalue: function divide(v) {\\n\\n  \\t\\t\\tthis.x /= v.x;\\n  \\t\\t\\tthis.y /= v.y;\\n  \\t\\t\\tthis.z /= v.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"divideScalar\",\\n  \\t\\tvalue: function divideScalar(s) {\\n\\n  \\t\\t\\tthis.x /= s;\\n  \\t\\t\\tthis.y /= s;\\n  \\t\\t\\tthis.z /= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"crossVectors\",\\n  \\t\\tvalue: function crossVectors(a, b) {\\n\\n  \\t\\t\\tvar ax = a.x,\\n  \\t\\t\\t    ay = a.y,\\n  \\t\\t\\t    az = a.z;\\n  \\t\\t\\tvar bx = b.x,\\n  \\t\\t\\t    by = b.y,\\n  \\t\\t\\t    bz = b.z;\\n\\n  \\t\\t\\tthis.x = ay * bz - az * by;\\n  \\t\\t\\tthis.y = az * bx - ax * bz;\\n  \\t\\t\\tthis.z = ax * by - ay * bx;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"cross\",\\n  \\t\\tvalue: function cross(v) {\\n\\n  \\t\\t\\treturn this.crossVectors(this, v);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"transformDirection\",\\n  \\t\\tvalue: function transformDirection(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[4] * y + e[8] * z;\\n  \\t\\t\\tthis.y = e[1] * x + e[5] * y + e[9] * z;\\n  \\t\\t\\tthis.z = e[2] * x + e[6] * y + e[10] * z;\\n\\n  \\t\\t\\treturn this.normalize();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"applyMatrix3\",\\n  \\t\\tvalue: function applyMatrix3(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[3] * y + e[6] * z;\\n  \\t\\t\\tthis.y = e[1] * x + e[4] * y + e[7] * z;\\n  \\t\\t\\tthis.z = e[2] * x + e[5] * y + e[8] * z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"applyMatrix4\",\\n  \\t\\tvalue: function applyMatrix4(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12];\\n  \\t\\t\\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13];\\n  \\t\\t\\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"applyQuaternion\",\\n  \\t\\tvalue: function applyQuaternion(q) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z;\\n  \\t\\t\\tvar qx = q.x,\\n  \\t\\t\\t    qy = q.y,\\n  \\t\\t\\t    qz = q.z,\\n  \\t\\t\\t    qw = q.w;\\n\\n  \\t\\t\\tvar ix = qw * x + qy * z - qz * y;\\n  \\t\\t\\tvar iy = qw * y + qz * x - qx * z;\\n  \\t\\t\\tvar iz = qw * z + qx * y - qy * x;\\n  \\t\\t\\tvar iw = -qx * x - qy * y - qz * z;\\n\\n  \\t\\t\\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\\n  \\t\\t\\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\\n  \\t\\t\\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"negate\",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.x = -this.x;\\n  \\t\\t\\tthis.y = -this.y;\\n  \\t\\t\\tthis.z = -this.z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"dot\",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"reflect\",\\n  \\t\\tvalue: function reflect(n) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar nx = n.x;\\n  \\t\\t\\tvar ny = n.y;\\n  \\t\\t\\tvar nz = n.z;\\n\\n  \\t\\t\\tthis.sub(n.multiplyScalar(2 * this.dot(n)));\\n\\n  \\t\\t\\tn.set(nx, ny, nz);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"angleTo\",\\n  \\t\\tvalue: function angleTo(v) {\\n\\n  \\t\\t\\tvar theta = this.dot(v) / Math.sqrt(this.lengthSquared() * v.lengthSquared());\\n\\n  \\t\\t\\treturn Math.acos(Math.min(Math.max(theta, -1), 1));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"manhattanLength\",\\n  \\t\\tvalue: function manhattanLength() {\\n\\n  \\t\\t\\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lengthSquared\",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"length\",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"manhattanDistanceTo\",\\n  \\t\\tvalue: function manhattanDistanceTo(v) {\\n\\n  \\t\\t\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToSquared\",\\n  \\t\\tvalue: function distanceToSquared(v) {\\n\\n  \\t\\t\\tvar dx = this.x - v.x;\\n  \\t\\t\\tvar dy = this.y - v.y;\\n  \\t\\t\\tvar dz = this.z - v.z;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceTo\",\\n  \\t\\tvalue: function distanceTo(v) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceToSquared(v));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"normalize\",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\treturn this.divideScalar(this.length());\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setLength\",\\n  \\t\\tvalue: function setLength(length) {\\n\\n  \\t\\t\\treturn this.normalize().multiplyScalar(length);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"min\",\\n  \\t\\tvalue: function min(v) {\\n\\n  \\t\\t\\tthis.x = Math.min(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.min(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.min(this.z, v.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"max\",\\n  \\t\\tvalue: function max(v) {\\n\\n  \\t\\t\\tthis.x = Math.max(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.max(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.max(this.z, v.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clamp\",\\n  \\t\\tvalue: function clamp(min, max) {\\n\\n  \\t\\t\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\n  \\t\\t\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\n  \\t\\t\\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"floor\",\\n  \\t\\tvalue: function floor() {\\n\\n  \\t\\t\\tthis.x = Math.floor(this.x);\\n  \\t\\t\\tthis.y = Math.floor(this.y);\\n  \\t\\t\\tthis.z = Math.floor(this.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"ceil\",\\n  \\t\\tvalue: function ceil() {\\n\\n  \\t\\t\\tthis.x = Math.ceil(this.x);\\n  \\t\\t\\tthis.y = Math.ceil(this.y);\\n  \\t\\t\\tthis.z = Math.ceil(this.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"round\",\\n  \\t\\tvalue: function round() {\\n\\n  \\t\\t\\tthis.x = Math.round(this.x);\\n  \\t\\t\\tthis.y = Math.round(this.y);\\n  \\t\\t\\tthis.z = Math.round(this.z);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lerp\",\\n  \\t\\tvalue: function lerp(v, alpha) {\\n\\n  \\t\\t\\tthis.x += (v.x - this.x) * alpha;\\n  \\t\\t\\tthis.y += (v.y - this.y) * alpha;\\n  \\t\\t\\tthis.z += (v.z - this.z) * alpha;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lerpVectors\",\\n  \\t\\tvalue: function lerpVectors(v1, v2, alpha) {\\n\\n  \\t\\t\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(v) {\\n\\n  \\t\\t\\treturn v.x === this.x && v.y === this.y && v.z === this.z;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Vector3;\\n  }();\\n\\n  var v$1 = new Vector3();\\n\\n  var Box3 = function () {\\n  \\tfunction Box3() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(Infinity, Infinity, Infinity);\\n  \\t\\tvar max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);\\n  \\t\\tclassCallCheck(this, Box3);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.max = max;\\n  \\t}\\n\\n  \\tcreateClass(Box3, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(min, max) {\\n\\n  \\t\\t\\tthis.min.copy(min);\\n  \\t\\t\\tthis.max.copy(max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(b) {\\n\\n  \\t\\t\\tthis.min.copy(b.min);\\n  \\t\\t\\tthis.max.copy(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"makeEmpty\",\\n  \\t\\tvalue: function makeEmpty() {\\n\\n  \\t\\t\\tthis.min.x = this.min.y = this.min.z = Infinity;\\n  \\t\\t\\tthis.max.x = this.max.y = this.max.z = -Infinity;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"isEmpty\",\\n  \\t\\tvalue: function isEmpty() {\\n\\n  \\t\\t\\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getCenter\",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.addVectors(this.min, this.max).multiplyScalar(0.5) : target.set(0, 0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getSize\",\\n  \\t\\tvalue: function getSize() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.subVectors(this.max, this.min) : target.set(0, 0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getBoundingSphere\",\\n  \\t\\tvalue: function getBoundingSphere() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Sphere();\\n\\n\\n  \\t\\t\\tthis.getCenter(target.center);\\n\\n  \\t\\t\\ttarget.radius = this.getSize(v$1).length() * 0.5;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"expandByPoint\",\\n  \\t\\tvalue: function expandByPoint(p) {\\n\\n  \\t\\t\\tthis.min.min(p);\\n  \\t\\t\\tthis.max.max(p);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"expandByVector\",\\n  \\t\\tvalue: function expandByVector(v) {\\n\\n  \\t\\t\\tthis.min.sub(v);\\n  \\t\\t\\tthis.max.add(v);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"expandByScalar\",\\n  \\t\\tvalue: function expandByScalar(s) {\\n\\n  \\t\\t\\tthis.min.addScalar(-s);\\n  \\t\\t\\tthis.max.addScalar(s);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromPoints\",\\n  \\t\\tvalue: function setFromPoints(points) {\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tthis.min.set(0, 0, 0);\\n  \\t\\t\\tthis.max.set(0, 0, 0);\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tthis.expandByPoint(points[i]);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromCenterAndSize\",\\n  \\t\\tvalue: function setFromCenterAndSize(center, size) {\\n\\n  \\t\\t\\tvar halfSize = v$1.copy(size).multiplyScalar(0.5);\\n\\n  \\t\\t\\tthis.min.copy(center).sub(halfSize);\\n  \\t\\t\\tthis.max.copy(center).add(halfSize);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clampPoint\",\\n  \\t\\tvalue: function clampPoint(point) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.copy(point).clamp(this.min, this.max);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToPoint\",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\tvar clampedPoint = v$1.copy(p).clamp(this.min, this.max);\\n\\n  \\t\\t\\treturn clampedPoint.sub(p).length();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"translate\",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.min.add(offset);\\n  \\t\\t\\tthis.max.add(offset);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersect\",\\n  \\t\\tvalue: function intersect(b) {\\n\\n  \\t\\t\\tthis.min.max(b.min);\\n  \\t\\t\\tthis.max.min(b.max);\\n\\n  \\t\\t\\tif (this.isEmpty()) {\\n\\n  \\t\\t\\t\\tthis.makeEmpty();\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"union\",\\n  \\t\\tvalue: function union(b) {\\n\\n  \\t\\t\\tthis.min.min(b.min);\\n  \\t\\t\\tthis.max.max(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"containsPoint\",\\n  \\t\\tvalue: function containsPoint(p) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n\\n  \\t\\t\\treturn p.x >= min.x && p.y >= min.y && p.z >= min.z && p.x <= max.x && p.y <= max.y && p.z <= max.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"containsBox\",\\n  \\t\\tvalue: function containsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn tMin.x <= bMin.x && bMax.x <= tMax.x && tMin.y <= bMin.y && bMax.y <= tMax.y && tMin.z <= bMin.z && bMax.z <= tMax.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsBox\",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn bMax.x >= tMin.x && bMax.y >= tMin.y && bMax.z >= tMin.z && bMin.x <= tMax.x && bMin.y <= tMax.y && bMin.z <= tMax.z;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsSphere\",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n  \\t\\t\\tvar closestPoint = this.clampPoint(s.center, v$1);\\n\\n  \\t\\t\\treturn closestPoint.distanceToSquared(s.center) <= s.radius * s.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsPlane\",\\n  \\t\\tvalue: function intersectsPlane(p) {\\n\\n  \\t\\t\\tvar min = void 0,\\n  \\t\\t\\t    max = void 0;\\n\\n  \\t\\t\\tif (p.normal.x > 0) {\\n\\n  \\t\\t\\t\\tmin = p.normal.x * this.min.x;\\n  \\t\\t\\t\\tmax = p.normal.x * this.max.x;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tmin = p.normal.x * this.max.x;\\n  \\t\\t\\t\\tmax = p.normal.x * this.min.x;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (p.normal.y > 0) {\\n\\n  \\t\\t\\t\\tmin += p.normal.y * this.min.y;\\n  \\t\\t\\t\\tmax += p.normal.y * this.max.y;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tmin += p.normal.y * this.max.y;\\n  \\t\\t\\t\\tmax += p.normal.y * this.min.y;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (p.normal.z > 0) {\\n\\n  \\t\\t\\t\\tmin += p.normal.z * this.min.z;\\n  \\t\\t\\t\\tmax += p.normal.z * this.max.z;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tmin += p.normal.z * this.max.z;\\n  \\t\\t\\t\\tmax += p.normal.z * this.min.z;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn min <= p.constant && max >= p.constant;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(b) {\\n\\n  \\t\\t\\treturn b.min.equals(this.min) && b.max.equals(this.max);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Box3;\\n  }();\\n\\n  var box = new Box3();\\n\\n  var Sphere = function () {\\n  \\tfunction Sphere() {\\n  \\t\\tvar center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, Sphere);\\n\\n\\n  \\t\\tthis.center = center;\\n\\n  \\t\\tthis.radius = radius;\\n  \\t}\\n\\n  \\tcreateClass(Sphere, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(center, radius) {\\n\\n  \\t\\t\\tthis.center.copy(center);\\n  \\t\\t\\tthis.radius = radius;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(s) {\\n\\n  \\t\\t\\tthis.center.copy(s.center);\\n  \\t\\t\\tthis.radius = s.radius;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromPoints\",\\n  \\t\\tvalue: function setFromPoints(points) {\\n  \\t\\t\\tvar center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : box.setFromPoints(points).getCenter(this.center);\\n\\n\\n  \\t\\t\\tvar maxRadiusSq = 0;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.radius = Math.sqrt(maxRadiusSq);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getBoundingBox\",\\n  \\t\\tvalue: function getBoundingBox() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Box3();\\n\\n\\n  \\t\\t\\ttarget.set(this.center, this.center);\\n  \\t\\t\\ttarget.expandByScalar(this.radius);\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"isEmpty\",\\n  \\t\\tvalue: function isEmpty() {\\n\\n  \\t\\t\\treturn this.radius <= 0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"translate\",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.center.add(offset);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clampPoint\",\\n  \\t\\tvalue: function clampPoint(p) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar deltaLengthSq = this.center.distanceToSquared(p);\\n\\n  \\t\\t\\ttarget.copy(p);\\n\\n  \\t\\t\\tif (deltaLengthSq > this.radius * this.radius) {\\n\\n  \\t\\t\\t\\ttarget.sub(this.center).normalize();\\n  \\t\\t\\t\\ttarget.multiplyScalar(this.radius).add(this.center);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToPoint\",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\treturn p.distanceTo(this.center) - this.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"containsPoint\",\\n  \\t\\tvalue: function containsPoint(p) {\\n\\n  \\t\\t\\treturn p.distanceToSquared(this.center) <= this.radius * this.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsSphere\",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n\\n  \\t\\t\\tvar radiusSum = this.radius + s.radius;\\n\\n  \\t\\t\\treturn s.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsBox\",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\treturn b.intersectsSphere(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsPlane\",\\n  \\t\\tvalue: function intersectsPlane(p) {\\n\\n  \\t\\t\\treturn Math.abs(p.distanceToPoint(this.center)) <= this.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(s) {\\n\\n  \\t\\t\\treturn s.center.equals(this.center) && s.radius === this.radius;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Sphere;\\n  }();\\n\\n  var Vector2 = function () {\\n  \\tfunction Vector2() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, Vector2);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n  \\t}\\n\\n  \\tcreateClass(Vector2, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(x, y) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(v) {\\n\\n  \\t\\t\\tthis.x = v.x;\\n  \\t\\t\\tthis.y = v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"fromArray\",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toArray\",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"add\",\\n  \\t\\tvalue: function add(v) {\\n\\n  \\t\\t\\tthis.x += v.x;\\n  \\t\\t\\tthis.y += v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addScalar\",\\n  \\t\\tvalue: function addScalar(s) {\\n\\n  \\t\\t\\tthis.x += s;\\n  \\t\\t\\tthis.y += s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addVectors\",\\n  \\t\\tvalue: function addVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x + b.x;\\n  \\t\\t\\tthis.y = a.y + b.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addScaledVector\",\\n  \\t\\tvalue: function addScaledVector(v, s) {\\n\\n  \\t\\t\\tthis.x += v.x * s;\\n  \\t\\t\\tthis.y += v.y * s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"sub\",\\n  \\t\\tvalue: function sub(v) {\\n\\n  \\t\\t\\tthis.x -= v.x;\\n  \\t\\t\\tthis.y -= v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"subScalar\",\\n  \\t\\tvalue: function subScalar(s) {\\n\\n  \\t\\t\\tthis.x -= s;\\n  \\t\\t\\tthis.y -= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"subVectors\",\\n  \\t\\tvalue: function subVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x - b.x;\\n  \\t\\t\\tthis.y = a.y - b.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiply\",\\n  \\t\\tvalue: function multiply(v) {\\n\\n  \\t\\t\\tthis.x *= v.x;\\n  \\t\\t\\tthis.y *= v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiplyScalar\",\\n  \\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\tthis.x *= s;\\n  \\t\\t\\tthis.y *= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"divide\",\\n  \\t\\tvalue: function divide(v) {\\n\\n  \\t\\t\\tthis.x /= v.x;\\n  \\t\\t\\tthis.y /= v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"divideScalar\",\\n  \\t\\tvalue: function divideScalar(s) {\\n\\n  \\t\\t\\tthis.x /= s;\\n  \\t\\t\\tthis.y /= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"applyMatrix3\",\\n  \\t\\tvalue: function applyMatrix3(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[3] * y + e[6];\\n  \\t\\t\\tthis.y = e[1] * x + e[4] * y + e[7];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"dot\",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"manhattanLength\",\\n  \\t\\tvalue: function manhattanLength() {\\n\\n  \\t\\t\\treturn Math.abs(this.x) + Math.abs(this.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lengthSquared\",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"length\",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"manhattanDistanceTo\",\\n  \\t\\tvalue: function manhattanDistanceTo(v) {\\n\\n  \\t\\t\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToSquared\",\\n  \\t\\tvalue: function distanceToSquared(v) {\\n\\n  \\t\\t\\tvar dx = this.x - v.x;\\n  \\t\\t\\tvar dy = this.y - v.y;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceTo\",\\n  \\t\\tvalue: function distanceTo(v) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceToSquared(v));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"normalize\",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\treturn this.divideScalar(this.length());\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setLength\",\\n  \\t\\tvalue: function setLength(length) {\\n\\n  \\t\\t\\treturn this.normalize().multiplyScalar(length);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"min\",\\n  \\t\\tvalue: function min(v) {\\n\\n  \\t\\t\\tthis.x = Math.min(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.min(this.y, v.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"max\",\\n  \\t\\tvalue: function max(v) {\\n\\n  \\t\\t\\tthis.x = Math.max(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.max(this.y, v.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clamp\",\\n  \\t\\tvalue: function clamp(min, max) {\\n\\n  \\t\\t\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\n  \\t\\t\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"floor\",\\n  \\t\\tvalue: function floor() {\\n\\n  \\t\\t\\tthis.x = Math.floor(this.x);\\n  \\t\\t\\tthis.y = Math.floor(this.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"ceil\",\\n  \\t\\tvalue: function ceil() {\\n\\n  \\t\\t\\tthis.x = Math.ceil(this.x);\\n  \\t\\t\\tthis.y = Math.ceil(this.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"round\",\\n  \\t\\tvalue: function round() {\\n\\n  \\t\\t\\tthis.x = Math.round(this.x);\\n  \\t\\t\\tthis.y = Math.round(this.y);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"negate\",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.x = -this.x;\\n  \\t\\t\\tthis.y = -this.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"angle\",\\n  \\t\\tvalue: function angle() {\\n\\n  \\t\\t\\tvar angle = Math.atan2(this.y, this.x);\\n\\n  \\t\\t\\tif (angle < 0) {\\n\\n  \\t\\t\\t\\tangle += 2 * Math.PI;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn angle;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lerp\",\\n  \\t\\tvalue: function lerp(v, alpha) {\\n\\n  \\t\\t\\tthis.x += (v.x - this.x) * alpha;\\n  \\t\\t\\tthis.y += (v.y - this.y) * alpha;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lerpVectors\",\\n  \\t\\tvalue: function lerpVectors(v1, v2, alpha) {\\n\\n  \\t\\t\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"rotateAround\",\\n  \\t\\tvalue: function rotateAround(center, angle) {\\n\\n  \\t\\t\\tvar c = Math.cos(angle),\\n  \\t\\t\\t    s = Math.sin(angle);\\n\\n  \\t\\t\\tvar x = this.x - center.x;\\n  \\t\\t\\tvar y = this.y - center.y;\\n\\n  \\t\\t\\tthis.x = x * c - y * s + center.x;\\n  \\t\\t\\tthis.y = x * s + y * c + center.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(v) {\\n\\n  \\t\\t\\treturn v.x === this.x && v.y === this.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"width\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.x;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\treturn this.x = value;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"height\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.y;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\treturn this.y = value;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Vector2;\\n  }();\\n\\n  var v = new Vector2();\\n\\n  var Box2 = function () {\\n  \\tfunction Box2() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2(Infinity, Infinity);\\n  \\t\\tvar max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(-Infinity, -Infinity);\\n  \\t\\tclassCallCheck(this, Box2);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.max = max;\\n  \\t}\\n\\n  \\tcreateClass(Box2, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(min, max) {\\n\\n  \\t\\t\\tthis.min.copy(min);\\n  \\t\\t\\tthis.max.copy(max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(b) {\\n\\n  \\t\\t\\tthis.min.copy(b.min);\\n  \\t\\t\\tthis.max.copy(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"makeEmpty\",\\n  \\t\\tvalue: function makeEmpty() {\\n\\n  \\t\\t\\tthis.min.x = this.min.y = Infinity;\\n  \\t\\t\\tthis.max.x = this.max.y = -Infinity;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"isEmpty\",\\n  \\t\\tvalue: function isEmpty() {\\n\\n  \\t\\t\\treturn this.max.x < this.min.x || this.max.y < this.min.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getCenter\",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.addVectors(this.min, this.max).multiplyScalar(0.5) : target.set(0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getSize\",\\n  \\t\\tvalue: function getSize() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\\n\\n\\n  \\t\\t\\treturn !this.isEmpty() ? target.subVectors(this.max, this.min) : target.set(0, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getBoundingSphere\",\\n  \\t\\tvalue: function getBoundingSphere() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Sphere();\\n\\n\\n  \\t\\t\\tthis.getCenter(target.center);\\n\\n  \\t\\t\\ttarget.radius = this.getSize(v).length() * 0.5;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"expandByPoint\",\\n  \\t\\tvalue: function expandByPoint(p) {\\n\\n  \\t\\t\\tthis.min.min(p);\\n  \\t\\t\\tthis.max.max(p);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"expandByVector\",\\n  \\t\\tvalue: function expandByVector(v) {\\n\\n  \\t\\t\\tthis.min.sub(v);\\n  \\t\\t\\tthis.max.add(v);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"expandByScalar\",\\n  \\t\\tvalue: function expandByScalar(s) {\\n\\n  \\t\\t\\tthis.min.addScalar(-s);\\n  \\t\\t\\tthis.max.addScalar(s);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromPoints\",\\n  \\t\\tvalue: function setFromPoints(points) {\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tthis.min.set(0, 0);\\n  \\t\\t\\tthis.max.set(0, 0);\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tthis.expandByPoint(points[i]);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromCenterAndSize\",\\n  \\t\\tvalue: function setFromCenterAndSize(center, size) {\\n\\n  \\t\\t\\tvar halfSize = v.copy(size).multiplyScalar(0.5);\\n\\n  \\t\\t\\tthis.min.copy(center).sub(halfSize);\\n  \\t\\t\\tthis.max.copy(center).add(halfSize);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clampPoint\",\\n  \\t\\tvalue: function clampPoint(point) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\\n\\n\\n  \\t\\t\\treturn target.copy(point).clamp(this.min, this.max);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToPoint\",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\tvar clampedPoint = v.copy(p).clamp(this.min, this.max);\\n\\n  \\t\\t\\treturn clampedPoint.sub(p).length();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"translate\",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.min.add(offset);\\n  \\t\\t\\tthis.max.add(offset);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersect\",\\n  \\t\\tvalue: function intersect(b) {\\n\\n  \\t\\t\\tthis.min.max(b.min);\\n  \\t\\t\\tthis.max.min(b.max);\\n\\n  \\t\\t\\tif (this.isEmpty()) {\\n\\n  \\t\\t\\t\\tthis.makeEmpty();\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"union\",\\n  \\t\\tvalue: function union(b) {\\n\\n  \\t\\t\\tthis.min.min(b.min);\\n  \\t\\t\\tthis.max.max(b.max);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"containsPoint\",\\n  \\t\\tvalue: function containsPoint(p) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n\\n  \\t\\t\\treturn p.x >= min.x && p.y >= min.y && p.x <= max.x && p.y <= max.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"containsBox\",\\n  \\t\\tvalue: function containsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn tMin.x <= bMin.x && bMax.x <= tMax.x && tMin.y <= bMin.y && bMax.y <= tMax.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsBox\",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\tvar tMin = this.min;\\n  \\t\\t\\tvar tMax = this.max;\\n  \\t\\t\\tvar bMin = b.min;\\n  \\t\\t\\tvar bMax = b.max;\\n\\n  \\t\\t\\treturn bMax.x >= tMin.x && bMax.y >= tMin.y && bMin.x <= tMax.x && bMin.y <= tMax.y;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(b) {\\n\\n  \\t\\t\\treturn b.min.equals(this.min) && b.max.equals(this.max);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Box2;\\n  }();\\n\\n  var Cylindrical = function () {\\n  \\tfunction Cylindrical() {\\n  \\t\\tvar radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n  \\t\\tvar theta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Cylindrical);\\n\\n\\n  \\t\\tthis.radius = radius;\\n\\n  \\t\\tthis.theta = theta;\\n\\n  \\t\\tthis.y = y;\\n  \\t}\\n\\n  \\tcreateClass(Cylindrical, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(radius, theta, y) {\\n\\n  \\t\\t\\tthis.radius = radius;\\n  \\t\\t\\tthis.theta = theta;\\n  \\t\\t\\tthis.y = y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(c) {\\n\\n  \\t\\t\\tthis.radius = c.radius;\\n  \\t\\t\\tthis.theta = c.theta;\\n  \\t\\t\\tthis.y = c.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromVector3\",\\n  \\t\\tvalue: function setFromVector3(v) {\\n\\n  \\t\\t\\tthis.radius = Math.sqrt(v.x * v.x + v.z * v.z);\\n  \\t\\t\\tthis.theta = Math.atan2(v.x, v.z);\\n  \\t\\t\\tthis.y = v.y;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Cylindrical;\\n  }();\\n\\n  var Matrix3 = function () {\\n  \\t\\tfunction Matrix3() {\\n  \\t\\t\\t\\tclassCallCheck(this, Matrix3);\\n\\n\\n  \\t\\t\\t\\tthis.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Matrix3, [{\\n  \\t\\t\\t\\tkey: \"set\",\\n  \\t\\t\\t\\tvalue: function set$$1(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = m00;te[3] = m01;te[6] = m02;\\n  \\t\\t\\t\\t\\t\\tte[1] = m10;te[4] = m11;te[7] = m12;\\n  \\t\\t\\t\\t\\t\\tte[2] = m20;te[5] = m21;te[8] = m22;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"identity\",\\n  \\t\\t\\t\\tvalue: function identity() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"copy\",\\n  \\t\\t\\t\\tvalue: function copy(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = me[0];te[1] = me[1];te[2] = me[2];\\n  \\t\\t\\t\\t\\t\\tte[3] = me[3];te[4] = me[4];te[5] = me[5];\\n  \\t\\t\\t\\t\\t\\tte[6] = me[6];te[7] = me[7];te[8] = me[8];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"clone\",\\n  \\t\\t\\t\\tvalue: function clone() {\\n\\n  \\t\\t\\t\\t\\t\\treturn new this.constructor().fromArray(this.elements);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"fromArray\",\\n  \\t\\t\\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 9; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[i] = array[i + offset];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"toArray\",\\n  \\t\\t\\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\t\\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 9; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tarray[i + offset] = te[i];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn array;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"multiplyMatrices\",\\n  \\t\\t\\t\\tvalue: function multiplyMatrices(a, b) {\\n\\n  \\t\\t\\t\\t\\t\\tvar ae = a.elements;\\n  \\t\\t\\t\\t\\t\\tvar be = b.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a11 = ae[0],\\n  \\t\\t\\t\\t\\t\\t    a12 = ae[3],\\n  \\t\\t\\t\\t\\t\\t    a13 = ae[6];\\n  \\t\\t\\t\\t\\t\\tvar a21 = ae[1],\\n  \\t\\t\\t\\t\\t\\t    a22 = ae[4],\\n  \\t\\t\\t\\t\\t\\t    a23 = ae[7];\\n  \\t\\t\\t\\t\\t\\tvar a31 = ae[2],\\n  \\t\\t\\t\\t\\t\\t    a32 = ae[5],\\n  \\t\\t\\t\\t\\t\\t    a33 = ae[8];\\n\\n  \\t\\t\\t\\t\\t\\tvar b11 = be[0],\\n  \\t\\t\\t\\t\\t\\t    b12 = be[3],\\n  \\t\\t\\t\\t\\t\\t    b13 = be[6];\\n  \\t\\t\\t\\t\\t\\tvar b21 = be[1],\\n  \\t\\t\\t\\t\\t\\t    b22 = be[4],\\n  \\t\\t\\t\\t\\t\\t    b23 = be[7];\\n  \\t\\t\\t\\t\\t\\tvar b31 = be[2],\\n  \\t\\t\\t\\t\\t\\t    b32 = be[5],\\n  \\t\\t\\t\\t\\t\\t    b33 = be[8];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\\n  \\t\\t\\t\\t\\t\\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\\n  \\t\\t\\t\\t\\t\\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\\n  \\t\\t\\t\\t\\t\\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\\n  \\t\\t\\t\\t\\t\\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\\n  \\t\\t\\t\\t\\t\\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\\n  \\t\\t\\t\\t\\t\\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"multiply\",\\n  \\t\\t\\t\\tvalue: function multiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(this, m);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"premultiply\",\\n  \\t\\t\\t\\tvalue: function premultiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(m, this);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"multiplyScalar\",\\n  \\t\\t\\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= s;te[3] *= s;te[6] *= s;\\n  \\t\\t\\t\\t\\t\\tte[1] *= s;te[4] *= s;te[7] *= s;\\n  \\t\\t\\t\\t\\t\\tte[2] *= s;te[5] *= s;te[8] *= s;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"determinant\",\\n  \\t\\t\\t\\tvalue: function determinant() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a = te[0],\\n  \\t\\t\\t\\t\\t\\t    b = te[1],\\n  \\t\\t\\t\\t\\t\\t    c = te[2];\\n  \\t\\t\\t\\t\\t\\tvar d = te[3],\\n  \\t\\t\\t\\t\\t\\t    e = te[4],\\n  \\t\\t\\t\\t\\t\\t    f = te[5];\\n  \\t\\t\\t\\t\\t\\tvar g = te[6],\\n  \\t\\t\\t\\t\\t\\t    h = te[7],\\n  \\t\\t\\t\\t\\t\\t    i = te[8];\\n\\n  \\t\\t\\t\\t\\t\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"getInverse\",\\n  \\t\\t\\t\\tvalue: function getInverse(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n11 = me[0],\\n  \\t\\t\\t\\t\\t\\t    n21 = me[1],\\n  \\t\\t\\t\\t\\t\\t    n31 = me[2];\\n  \\t\\t\\t\\t\\t\\tvar n12 = me[3],\\n  \\t\\t\\t\\t\\t\\t    n22 = me[4],\\n  \\t\\t\\t\\t\\t\\t    n32 = me[5];\\n  \\t\\t\\t\\t\\t\\tvar n13 = me[6],\\n  \\t\\t\\t\\t\\t\\t    n23 = me[7],\\n  \\t\\t\\t\\t\\t\\t    n33 = me[8];\\n\\n  \\t\\t\\t\\t\\t\\tvar t11 = n33 * n22 - n32 * n23;\\n  \\t\\t\\t\\t\\t\\tvar t12 = n32 * n13 - n33 * n12;\\n  \\t\\t\\t\\t\\t\\tvar t13 = n23 * n12 - n22 * n13;\\n\\n  \\t\\t\\t\\t\\t\\tvar det = n11 * t11 + n21 * t12 + n31 * t13;\\n\\n  \\t\\t\\t\\t\\t\\tvar invDet = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (det !== 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tinvDet = 1.0 / det;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[0] = t11 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[1] = (n31 * n23 - n33 * n21) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[2] = (n32 * n21 - n31 * n22) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[3] = t12 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[4] = (n33 * n11 - n31 * n13) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[5] = (n31 * n12 - n32 * n11) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[6] = t13 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[7] = (n21 * n13 - n23 * n11) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[8] = (n22 * n11 - n21 * n12) * invDet;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tconsole.error(\"Can\\'t invert matrix, determinant is zero\", matrix);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.identity();\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"transpose\",\\n  \\t\\t\\t\\tvalue: function transpose() {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar t = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tt = me[1];me[1] = me[3];me[3] = t;\\n  \\t\\t\\t\\t\\t\\tt = me[2];me[2] = me[6];me[6] = t;\\n  \\t\\t\\t\\t\\t\\tt = me[5];me[5] = me[7];me[7] = t;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"scale\",\\n  \\t\\t\\t\\tvalue: function scale(sx, sy) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= sx;te[3] *= sx;te[6] *= sx;\\n  \\t\\t\\t\\t\\t\\tte[1] *= sy;te[4] *= sy;te[7] *= sy;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"rotate\",\\n  \\t\\t\\t\\tvalue: function rotate(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta);\\n  \\t\\t\\t\\t\\t\\tvar s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a11 = te[0],\\n  \\t\\t\\t\\t\\t\\t    a12 = te[3],\\n  \\t\\t\\t\\t\\t\\t    a13 = te[6];\\n  \\t\\t\\t\\t\\t\\tvar a21 = te[1],\\n  \\t\\t\\t\\t\\t\\t    a22 = te[4],\\n  \\t\\t\\t\\t\\t\\t    a23 = te[7];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = c * a11 + s * a21;\\n  \\t\\t\\t\\t\\t\\tte[3] = c * a12 + s * a22;\\n  \\t\\t\\t\\t\\t\\tte[6] = c * a13 + s * a23;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = -s * a11 + c * a21;\\n  \\t\\t\\t\\t\\t\\tte[4] = -s * a12 + c * a22;\\n  \\t\\t\\t\\t\\t\\tte[7] = -s * a13 + c * a23;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"translate\",\\n  \\t\\t\\t\\tvalue: function translate(tx, ty) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] += tx * te[2];te[3] += tx * te[5];te[6] += tx * te[8];\\n  \\t\\t\\t\\t\\t\\tte[1] += ty * te[2];te[4] += ty * te[5];te[7] += ty * te[8];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"equals\",\\n  \\t\\t\\t\\tvalue: function equals(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar result = true;\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; result && i < 9; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (te[i] !== me[i]) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Matrix3;\\n  }();\\n\\n  var RotationOrder = {\\n\\n    XYZ: \"XYZ\",\\n    YZX: \"YZX\",\\n    ZXY: \"ZXY\",\\n    XZY: \"XZY\",\\n    YXZ: \"YXZ\",\\n    ZYX: \"ZYX\"\\n\\n  };\\n\\n  var v$2 = new Vector3();\\n\\n  var Quaternion = function () {\\n  \\tfunction Quaternion() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tvar w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\\n  \\t\\tclassCallCheck(this, Quaternion);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n\\n  \\t\\tthis.w = w;\\n  \\t}\\n\\n  \\tcreateClass(Quaternion, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(x, y, z, w) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n  \\t\\t\\tthis.w = w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(q) {\\n\\n  \\t\\t\\tthis.x = q.x;\\n  \\t\\t\\tthis.y = q.y;\\n  \\t\\t\\tthis.z = q.z;\\n  \\t\\t\\tthis.w = q.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z, this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"fromArray\",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n  \\t\\t\\tthis.w = array[offset + 3];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toArray\",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n  \\t\\t\\tarray[offset + 3] = this.w;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromEuler\",\\n  \\t\\tvalue: function setFromEuler(euler) {\\n\\n  \\t\\t\\tvar x = euler.x;\\n  \\t\\t\\tvar y = euler.y;\\n  \\t\\t\\tvar z = euler.z;\\n\\n  \\t\\t\\tvar cos = Math.cos;\\n  \\t\\t\\tvar sin = Math.sin;\\n\\n  \\t\\t\\tvar c1 = cos(x / 2);\\n  \\t\\t\\tvar c2 = cos(y / 2);\\n  \\t\\t\\tvar c3 = cos(z / 2);\\n\\n  \\t\\t\\tvar s1 = sin(x / 2);\\n  \\t\\t\\tvar s2 = sin(y / 2);\\n  \\t\\t\\tvar s3 = sin(z / 2);\\n\\n  \\t\\t\\tswitch (euler.order) {\\n\\n  \\t\\t\\t\\tcase RotationOrder.XYZ:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.YXZ:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZXY:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZYX:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.YZX:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 + c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 + s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 - s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 - s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\tcase RotationOrder.XZY:\\n  \\t\\t\\t\\t\\tthis.x = s1 * c2 * c3 - c1 * s2 * s3;\\n  \\t\\t\\t\\t\\tthis.y = c1 * s2 * c3 - s1 * c2 * s3;\\n  \\t\\t\\t\\t\\tthis.z = c1 * c2 * s3 + s1 * s2 * c3;\\n  \\t\\t\\t\\t\\tthis.w = c1 * c2 * c3 + s1 * s2 * s3;\\n  \\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromAxisAngle\",\\n  \\t\\tvalue: function setFromAxisAngle(axis, angle) {\\n\\n  \\t\\t\\tvar halfAngle = angle / 2.0;\\n  \\t\\t\\tvar s = Math.sin(halfAngle);\\n\\n  \\t\\t\\tthis.x = axis.x * s;\\n  \\t\\t\\tthis.y = axis.y * s;\\n  \\t\\t\\tthis.z = axis.z * s;\\n  \\t\\t\\tthis.w = Math.cos(halfAngle);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromRotationMatrix\",\\n  \\t\\tvalue: function setFromRotationMatrix(m) {\\n\\n  \\t\\t\\tvar te = m.elements;\\n\\n  \\t\\t\\tvar m00 = te[0],\\n  \\t\\t\\t    m01 = te[4],\\n  \\t\\t\\t    m02 = te[8];\\n  \\t\\t\\tvar m10 = te[1],\\n  \\t\\t\\t    m11 = te[5],\\n  \\t\\t\\t    m12 = te[9];\\n  \\t\\t\\tvar m20 = te[2],\\n  \\t\\t\\t    m21 = te[6],\\n  \\t\\t\\t    m22 = te[10];\\n\\n  \\t\\t\\tvar trace = m00 + m11 + m22;\\n\\n  \\t\\t\\tvar s = void 0;\\n\\n  \\t\\t\\tif (trace > 0) {\\n\\n  \\t\\t\\t\\ts = 0.5 / Math.sqrt(trace + 1.0);\\n\\n  \\t\\t\\t\\tthis.w = 0.25 / s;\\n  \\t\\t\\t\\tthis.x = (m21 - m12) * s;\\n  \\t\\t\\t\\tthis.y = (m02 - m20) * s;\\n  \\t\\t\\t\\tthis.z = (m10 - m01) * s;\\n  \\t\\t\\t} else if (m00 > m11 && m00 > m22) {\\n\\n  \\t\\t\\t\\ts = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);\\n\\n  \\t\\t\\t\\tthis.w = (m21 - m12) / s;\\n  \\t\\t\\t\\tthis.x = 0.25 * s;\\n  \\t\\t\\t\\tthis.y = (m01 + m10) / s;\\n  \\t\\t\\t\\tthis.z = (m02 + m20) / s;\\n  \\t\\t\\t} else if (m11 > m22) {\\n\\n  \\t\\t\\t\\ts = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);\\n\\n  \\t\\t\\t\\tthis.w = (m02 - m20) / s;\\n  \\t\\t\\t\\tthis.x = (m01 + m10) / s;\\n  \\t\\t\\t\\tthis.y = 0.25 * s;\\n  \\t\\t\\t\\tthis.z = (m12 + m21) / s;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ts = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);\\n\\n  \\t\\t\\t\\tthis.w = (m10 - m01) / s;\\n  \\t\\t\\t\\tthis.x = (m02 + m20) / s;\\n  \\t\\t\\t\\tthis.y = (m12 + m21) / s;\\n  \\t\\t\\t\\tthis.z = 0.25 * s;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromUnitVectors\",\\n  \\t\\tvalue: function setFromUnitVectors(vFrom, vTo) {\\n\\n  \\t\\t\\tvar r = vFrom.dot(vTo) + 1;\\n\\n  \\t\\t\\tif (r < 1e-6) {\\n\\n  \\t\\t\\t\\tr = 0;\\n\\n  \\t\\t\\t\\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\\n\\n  \\t\\t\\t\\t\\tv$2.set(-vFrom.y, vFrom.x, 0);\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tv$2.set(0, -vFrom.z, vFrom.y);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tv$2.crossVectors(vFrom, vTo);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.x = v$2.x;\\n  \\t\\t\\tthis.y = v$2.y;\\n  \\t\\t\\tthis.z = v$2.z;\\n  \\t\\t\\tthis.w = r;\\n\\n  \\t\\t\\treturn this.normalize();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"invert\",\\n  \\t\\tvalue: function invert() {\\n\\n  \\t\\t\\treturn this.conjugate().normalize();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"conjugate\",\\n  \\t\\tvalue: function conjugate() {\\n\\n  \\t\\t\\tthis.x *= -1;\\n  \\t\\t\\tthis.y *= -1;\\n  \\t\\t\\tthis.z *= -1;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lengthSquared\",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"length\",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"normalize\",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\tvar l = this.length();\\n\\n  \\t\\t\\tvar invLength = void 0;\\n\\n  \\t\\t\\tif (l === 0) {\\n\\n  \\t\\t\\t\\tthis.x = 0;\\n  \\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t\\tthis.w = 1;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tinvLength = 1.0 / l;\\n\\n  \\t\\t\\t\\tthis.x = this.x * invLength;\\n  \\t\\t\\t\\tthis.y = this.y * invLength;\\n  \\t\\t\\t\\tthis.z = this.z * invLength;\\n  \\t\\t\\t\\tthis.w = this.w * invLength;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"dot\",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiplyQuaternions\",\\n  \\t\\tvalue: function multiplyQuaternions(a, b) {\\n\\n  \\t\\t\\tvar qax = a.x,\\n  \\t\\t\\t    qay = a.y,\\n  \\t\\t\\t    qaz = a.z,\\n  \\t\\t\\t    qaw = a.w;\\n  \\t\\t\\tvar qbx = b.x,\\n  \\t\\t\\t    qby = b.y,\\n  \\t\\t\\t    qbz = b.z,\\n  \\t\\t\\t    qbw = b.w;\\n\\n  \\t\\t\\tthis.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\n  \\t\\t\\tthis.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\n  \\t\\t\\tthis.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n  \\t\\t\\tthis.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiply\",\\n  \\t\\tvalue: function multiply(q) {\\n\\n  \\t\\t\\treturn this.multiplyQuaternions(this, q);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"premultiply\",\\n  \\t\\tvalue: function premultiply(q) {\\n\\n  \\t\\t\\treturn this.multiplyQuaternions(q, this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"slerp\",\\n  \\t\\tvalue: function slerp(q, t) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z,\\n  \\t\\t\\t    w = this.w;\\n\\n  \\t\\t\\tvar cosHalfTheta = void 0,\\n  \\t\\t\\t    sinHalfTheta = void 0;\\n  \\t\\t\\tvar halfTheta = void 0,\\n  \\t\\t\\t    ratioA = void 0,\\n  \\t\\t\\t    ratioB = void 0;\\n\\n  \\t\\t\\tif (t === 1) {\\n\\n  \\t\\t\\t\\tthis.copy(q);\\n  \\t\\t\\t} else if (t > 0) {\\n\\n  \\t\\t\\t\\tcosHalfTheta = w * q.w + x * q.x + y * q.y + z * q.z;\\n\\n  \\t\\t\\t\\tif (cosHalfTheta < 0) {\\n\\n  \\t\\t\\t\\t\\tthis.w = -q.w;\\n  \\t\\t\\t\\t\\tthis.x = -q.x;\\n  \\t\\t\\t\\t\\tthis.y = -q.y;\\n  \\t\\t\\t\\t\\tthis.z = -q.z;\\n\\n  \\t\\t\\t\\t\\tcosHalfTheta = -cosHalfTheta;\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tthis.copy(q);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (cosHalfTheta >= 1.0) {\\n\\n  \\t\\t\\t\\t\\tthis.w = w;\\n  \\t\\t\\t\\t\\tthis.x = x;\\n  \\t\\t\\t\\t\\tthis.y = y;\\n  \\t\\t\\t\\t\\tthis.z = z;\\n\\n  \\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tsinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\\n\\n  \\t\\t\\t\\tif (Math.abs(sinHalfTheta) < 1e-3) {\\n\\n  \\t\\t\\t\\t\\tthis.w = 0.5 * (w + this.w);\\n  \\t\\t\\t\\t\\tthis.x = 0.5 * (x + this.x);\\n  \\t\\t\\t\\t\\tthis.y = 0.5 * (y + this.y);\\n  \\t\\t\\t\\t\\tthis.z = 0.5 * (z + this.z);\\n\\n  \\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\thalfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\\n  \\t\\t\\t\\tratioA = Math.sin((1.0 - t) * halfTheta) / sinHalfTheta;\\n  \\t\\t\\t\\tratioB = Math.sin(t * halfTheta) / sinHalfTheta;\\n\\n  \\t\\t\\t\\tthis.w = w * ratioA + this.w * ratioB;\\n  \\t\\t\\t\\tthis.x = x * ratioA + this.x * ratioB;\\n  \\t\\t\\t\\tthis.y = y * ratioA + this.y * ratioB;\\n  \\t\\t\\t\\tthis.z = z * ratioA + this.z * ratioB;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(q) {\\n\\n  \\t\\t\\treturn q.x === this.x && q.y === this.y && q.z === this.z && q.w === this.w;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: \"slerp\",\\n  \\t\\tvalue: function slerp(qa, qb) {\\n  \\t\\t\\tvar qr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Quaternion();\\n  \\t\\t\\tvar t = arguments[3];\\n\\n\\n  \\t\\t\\treturn qr.copy(qa).slerp(qb, t);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"slerpFlat\",\\n  \\t\\tvalue: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\\n\\n  \\t\\t\\tvar x1 = src1[srcOffset1];\\n  \\t\\t\\tvar y1 = src1[srcOffset1 + 1];\\n  \\t\\t\\tvar z1 = src1[srcOffset1 + 2];\\n  \\t\\t\\tvar w1 = src1[srcOffset1 + 3];\\n\\n  \\t\\t\\tvar x0 = src0[srcOffset0];\\n  \\t\\t\\tvar y0 = src0[srcOffset0 + 1];\\n  \\t\\t\\tvar z0 = src0[srcOffset0 + 2];\\n  \\t\\t\\tvar w0 = src0[srcOffset0 + 3];\\n\\n  \\t\\t\\tvar s = void 0,\\n  \\t\\t\\t    f = void 0;\\n  \\t\\t\\tvar sin = void 0,\\n  \\t\\t\\t    cos = void 0,\\n  \\t\\t\\t    sqrSin = void 0;\\n  \\t\\t\\tvar dir = void 0,\\n  \\t\\t\\t    len = void 0,\\n  \\t\\t\\t    tDir = void 0;\\n\\n  \\t\\t\\tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\\n\\n  \\t\\t\\t\\ts = 1.0 - t;\\n  \\t\\t\\t\\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;\\n\\n  \\t\\t\\t\\tdir = cos >= 0 ? 1 : -1;\\n  \\t\\t\\t\\tsqrSin = 1.0 - cos * cos;\\n\\n  \\t\\t\\t\\tif (sqrSin > Number.EPSILON) {\\n\\n  \\t\\t\\t\\t\\tsin = Math.sqrt(sqrSin);\\n  \\t\\t\\t\\t\\tlen = Math.atan2(sin, cos * dir);\\n\\n  \\t\\t\\t\\t\\ts = Math.sin(s * len) / sin;\\n  \\t\\t\\t\\t\\tt = Math.sin(t * len) / sin;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\ttDir = t * dir;\\n\\n  \\t\\t\\t\\tx0 = x0 * s + x1 * tDir;\\n  \\t\\t\\t\\ty0 = y0 * s + y1 * tDir;\\n  \\t\\t\\t\\tz0 = z0 * s + z1 * tDir;\\n  \\t\\t\\t\\tw0 = w0 * s + w1 * tDir;\\n\\n  \\t\\t\\t\\tif (s === 1.0 - t) {\\n\\n  \\t\\t\\t\\t\\tf = 1.0 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\\n\\n  \\t\\t\\t\\t\\tx0 *= f;\\n  \\t\\t\\t\\t\\ty0 *= f;\\n  \\t\\t\\t\\t\\tz0 *= f;\\n  \\t\\t\\t\\t\\tw0 *= f;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tdst[dstOffset] = x0;\\n  \\t\\t\\tdst[dstOffset + 1] = y0;\\n  \\t\\t\\tdst[dstOffset + 2] = z0;\\n  \\t\\t\\tdst[dstOffset + 3] = w0;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Quaternion;\\n  }();\\n\\n  function clamp(value, min, max) {\\n\\n  \\treturn Math.max(Math.min(value, max), min);\\n  }\\n\\n  var m = new Matrix3();\\n\\n  var q = new Quaternion();\\n\\n  var Euler = function () {\\n  \\tfunction Euler() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Euler);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n\\n  \\t\\tthis.order = Euler.defaultOrder;\\n  \\t}\\n\\n  \\tcreateClass(Euler, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(x, y, z, order) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n  \\t\\t\\tthis.order = z;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(e) {\\n\\n  \\t\\t\\tthis.x = e.x;\\n  \\t\\t\\tthis.y = e.y;\\n  \\t\\t\\tthis.z = e.z;\\n  \\t\\t\\tthis.order = e.order;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z, this.order);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"fromArray\",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n  \\t\\t\\tthis.order = array[offset + 3];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toArray\",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n  \\t\\t\\tarray[offset + 3] = this.order;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toVector3\",\\n  \\t\\tvalue: function toVector3() {\\n  \\t\\t\\tvar vector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn vector.set(this.x, this.y, this.z);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromRotationMatrix\",\\n  \\t\\tvalue: function setFromRotationMatrix(m) {\\n  \\t\\t\\tvar order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.order;\\n\\n\\n  \\t\\t\\tvar te = m.elements;\\n  \\t\\t\\tvar m00 = te[0],\\n  \\t\\t\\t    m01 = te[4],\\n  \\t\\t\\t    m02 = te[8];\\n  \\t\\t\\tvar m10 = te[1],\\n  \\t\\t\\t    m11 = te[5],\\n  \\t\\t\\t    m12 = te[9];\\n  \\t\\t\\tvar m20 = te[2],\\n  \\t\\t\\t    m21 = te[6],\\n  \\t\\t\\t    m22 = te[10];\\n\\n  \\t\\t\\tvar THRESHOLD = 1.0 - 1e-5;\\n\\n  \\t\\t\\tswitch (order) {\\n\\n  \\t\\t\\t\\tcase RotationOrder.XYZ:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.y = Math.asin(clamp(m02, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m02) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(-m12, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(-m01, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(m21, m11);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.YXZ:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.x = Math.asin(-clamp(m12, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m12) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(m02, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(m10, m11);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(-m20, m00);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZXY:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.x = Math.asin(clamp(m21, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m21) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(-m20, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(-m01, m11);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(m10, m00);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.ZYX:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.y = Math.asin(-clamp(m20, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m20) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(m21, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(m10, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = 0;\\n  \\t\\t\\t\\t\\t\\t\\tthis.z = Math.atan2(-m01, m11);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.YZX:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.z = Math.asin(clamp(m10, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m10) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(-m12, m11);\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(-m20, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = 0;\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(m02, m22);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcase RotationOrder.XZY:\\n  \\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\tthis.z = Math.asin(-clamp(m01, -1, 1));\\n\\n  \\t\\t\\t\\t\\t\\tif (Math.abs(m01) < THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(m21, m11);\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = Math.atan2(m02, m00);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tthis.x = Math.atan2(-m12, m22);\\n  \\t\\t\\t\\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.order = order;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromQuaternion\",\\n  \\t\\tvalue: function setFromQuaternion(q, order) {\\n\\n  \\t\\t\\tm.makeRotationFromQuaternion(q);\\n\\n  \\t\\t\\treturn this.setFromRotationMatrix(m, order);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromVector3\",\\n  \\t\\tvalue: function setFromVector3(v) {\\n  \\t\\t\\tvar order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.order;\\n\\n\\n  \\t\\t\\treturn this.set(v.x, v.y, v.z, order);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"reorder\",\\n  \\t\\tvalue: function reorder(newOrder) {\\n\\n  \\t\\t\\tq.setFromEuler(this);\\n\\n  \\t\\t\\treturn this.setFromQuaternion(q, newOrder);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(e) {\\n\\n  \\t\\t\\treturn e.x === this.x && e.y === this.y && e.z === this.z && e.order === this.order;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: \"defaultOrder\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn RotationOrder.XYZ;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Euler;\\n  }();\\n\\n  var a = new Vector3();\\n\\n  var b = new Vector3();\\n\\n  var Plane = function () {\\n  \\tfunction Plane() {\\n  \\t\\tvar normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);\\n  \\t\\tvar constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, Plane);\\n\\n\\n  \\t\\tthis.normal = normal;\\n\\n  \\t\\tthis.constant = constant;\\n  \\t}\\n\\n  \\tcreateClass(Plane, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(normal, constant) {\\n\\n  \\t\\t\\tthis.normal.copy(normal);\\n  \\t\\t\\tthis.constant = constant;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setComponents\",\\n  \\t\\tvalue: function setComponents(x, y, z, w) {\\n\\n  \\t\\t\\tthis.normal.set(x, y, z);\\n  \\t\\t\\tthis.constant = w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(p) {\\n\\n  \\t\\t\\tthis.normal.copy(p.normal);\\n  \\t\\t\\tthis.constant = p.constant;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromNormalAndCoplanarPoint\",\\n  \\t\\tvalue: function setFromNormalAndCoplanarPoint(n, p) {\\n\\n  \\t\\t\\tthis.normal.copy(n);\\n  \\t\\t\\tthis.constant = -p.dot(this.normal);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromCoplanarPoints\",\\n  \\t\\tvalue: function setFromCoplanarPoints(p0, p1, p2) {\\n\\n  \\t\\t\\tvar normal = a.subVectors(p2, p1).cross(b.subVectors(p0, p1)).normalize();\\n\\n  \\t\\t\\tthis.setFromNormalAndCoplanarPoint(normal, a);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"normalize\",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\tvar inverseNormalLength = 1.0 / this.normal.length();\\n\\n  \\t\\t\\tthis.normal.multiplyScalar(inverseNormalLength);\\n  \\t\\t\\tthis.constant *= inverseNormalLength;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"negate\",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.normal.negate();\\n  \\t\\t\\tthis.constant = -this.constant;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToPoint\",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\treturn this.normal.dot(p) + this.constant;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToSphere\",\\n  \\t\\tvalue: function distanceToSphere(s) {\\n\\n  \\t\\t\\treturn this.distanceToPoint(s.center) - s.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"projectPoint\",\\n  \\t\\tvalue: function projectPoint(p, target) {\\n\\n  \\t\\t\\treturn target.copy(this.normal).multiplyScalar(-this.distanceToPoint(p)).add(p);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"coplanarPoint\",\\n  \\t\\tvalue: function coplanarPoint(target) {\\n\\n  \\t\\t\\treturn target.copy(this.normal).multiplyScalar(-this.constant);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"translate\",\\n  \\t\\tvalue: function translate(offset) {\\n\\n  \\t\\t\\tthis.constant -= offset.dot(this.normal);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectLine\",\\n  \\t\\tvalue: function intersectLine(l, target) {\\n\\n  \\t\\t\\tvar direction = l.delta(a);\\n  \\t\\t\\tvar denominator = this.normal.dot(direction);\\n\\n  \\t\\t\\tif (denominator === 0) {\\n  \\t\\t\\t\\tif (this.distanceToPoint(l.start) === 0) {\\n\\n  \\t\\t\\t\\t\\ttarget.copy(l.start);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tvar t = -(l.start.dot(this.normal) + this.constant) / denominator;\\n\\n  \\t\\t\\t\\tif (t >= 0 && t <= 1) {\\n\\n  \\t\\t\\t\\t\\ttarget.copy(direction).multiplyScalar(t).add(l.start);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsLine\",\\n  \\t\\tvalue: function intersectsLine(l) {\\n\\n  \\t\\t\\tvar startSign = this.distanceToPoint(l.start);\\n  \\t\\t\\tvar endSign = this.distanceToPoint(l.end);\\n\\n  \\t\\t\\treturn startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsBox\",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\treturn b.intersectsPlane(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsSphere\",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n\\n  \\t\\t\\treturn s.intersectsPlane(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(p) {\\n\\n  \\t\\t\\treturn p.normal.equals(this.normal) && p.constant === this.constant;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Plane;\\n  }();\\n\\n  var v0 = new Vector3();\\n\\n  var v1 = new Vector3();\\n\\n  var Frustum = function () {\\n  \\tfunction Frustum() {\\n  \\t\\tvar p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();\\n  \\t\\tvar p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();\\n  \\t\\tvar p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();\\n  \\t\\tvar p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();\\n  \\t\\tvar p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();\\n  \\t\\tvar p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();\\n  \\t\\tclassCallCheck(this, Frustum);\\n\\n\\n  \\t\\tthis.planes = [p0, p1, p2, p3, p4, p5];\\n  \\t}\\n\\n  \\tcreateClass(Frustum, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(p0, p1, p2, p3, p4, p5) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tplanes[0].copy(p0);\\n  \\t\\t\\tplanes[1].copy(p1);\\n  \\t\\t\\tplanes[2].copy(p2);\\n  \\t\\t\\tplanes[3].copy(p3);\\n  \\t\\t\\tplanes[4].copy(p4);\\n  \\t\\t\\tplanes[5].copy(p5);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(frustum) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\tplanes[i].copy(frustum.planes[i]);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromMatrix\",\\n  \\t\\tvalue: function setFromMatrix(m) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tvar me = m.elements;\\n  \\t\\t\\tvar me0 = me[0],\\n  \\t\\t\\t    me1 = me[1],\\n  \\t\\t\\t    me2 = me[2],\\n  \\t\\t\\t    me3 = me[3];\\n  \\t\\t\\tvar me4 = me[4],\\n  \\t\\t\\t    me5 = me[5],\\n  \\t\\t\\t    me6 = me[6],\\n  \\t\\t\\t    me7 = me[7];\\n  \\t\\t\\tvar me8 = me[8],\\n  \\t\\t\\t    me9 = me[9],\\n  \\t\\t\\t    me10 = me[10],\\n  \\t\\t\\t    me11 = me[11];\\n  \\t\\t\\tvar me12 = me[12],\\n  \\t\\t\\t    me13 = me[13],\\n  \\t\\t\\t    me14 = me[14],\\n  \\t\\t\\t    me15 = me[15];\\n\\n  \\t\\t\\tplanes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\\n  \\t\\t\\tplanes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\\n  \\t\\t\\tplanes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\\n  \\t\\t\\tplanes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\\n  \\t\\t\\tplanes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\\n  \\t\\t\\tplanes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsSphere\",\\n  \\t\\tvalue: function intersectsSphere(sphere) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n  \\t\\t\\tvar center = sphere.center;\\n  \\t\\t\\tvar negativeRadius = -sphere.radius;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    d = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\td = planes[i].distanceToPoint(center);\\n\\n  \\t\\t\\t\\tif (d < negativeRadius) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsBox\",\\n  \\t\\tvalue: function intersectsBox(box) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n  \\t\\t\\tvar min = box.min;\\n  \\t\\t\\tvar max = box.max;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    d0 = void 0,\\n  \\t\\t\\t    d1 = void 0;\\n  \\t\\t\\tvar plane = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\tplane = planes[i];\\n\\n  \\t\\t\\t\\tv0.x = plane.normal.x > 0 ? min.x : max.x;\\n  \\t\\t\\t\\tv1.x = plane.normal.x > 0 ? max.x : min.x;\\n  \\t\\t\\t\\tv0.y = plane.normal.y > 0 ? min.y : max.y;\\n  \\t\\t\\t\\tv1.y = plane.normal.y > 0 ? max.y : min.y;\\n  \\t\\t\\t\\tv0.z = plane.normal.z > 0 ? min.z : max.z;\\n  \\t\\t\\t\\tv1.z = plane.normal.z > 0 ? max.z : min.z;\\n\\n  \\t\\t\\t\\td0 = plane.distanceToPoint(v0);\\n  \\t\\t\\t\\td1 = plane.distanceToPoint(v1);\\n\\n  \\t\\t\\t\\tif (d0 < 0 && d1 < 0) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"containsPoint\",\\n  \\t\\tvalue: function containsPoint(point) {\\n\\n  \\t\\t\\tvar planes = this.planes;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\t\\tif (planes[i].distanceToPoint(point) < 0) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Frustum;\\n  }();\\n\\n  var a$1 = new Vector3();\\n\\n  var b$1 = new Vector3();\\n\\n  var Line3 = function () {\\n  \\tfunction Line3() {\\n  \\t\\tvar start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\tclassCallCheck(this, Line3);\\n\\n\\n  \\t\\tthis.start = start;\\n\\n  \\t\\tthis.end = end;\\n  \\t}\\n\\n  \\tcreateClass(Line3, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(start, end) {\\n\\n  \\t\\t\\tthis.start.copy(start);\\n  \\t\\t\\tthis.end.copy(end);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(l) {\\n\\n  \\t\\t\\tthis.start.copy(l.start);\\n  \\t\\t\\tthis.end.copy(l.end);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getCenter\",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.addVectors(this.start, this.end).multiplyScalar(0.5);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"delta\",\\n  \\t\\tvalue: function delta() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.subVectors(this.end, this.start);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lengthSquared\",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.start.distanceToSquared(this.end);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"length\",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn this.start.distanceTo(this.end);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"at\",\\n  \\t\\tvalue: function at(d, target) {\\n\\n  \\t\\t\\treturn this.delta(target).multiplyScalar(d).add(this.start);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"closestPointToPointParameter\",\\n  \\t\\tvalue: function closestPointToPointParameter(p, clampToLine) {\\n\\n  \\t\\t\\ta$1.subVectors(p, this.start);\\n  \\t\\t\\tb$1.subVectors(this.end, this.start);\\n\\n  \\t\\t\\tvar bb = b$1.dot(b$1);\\n  \\t\\t\\tvar ba = b$1.dot(a$1);\\n\\n  \\t\\t\\tvar t = clampToLine ? Math.min(Math.max(ba / bb, 0), 1) : ba / bb;\\n\\n  \\t\\t\\treturn t;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"closestPointToPoint\",\\n  \\t\\tvalue: function closestPointToPoint(p) {\\n  \\t\\t\\tvar clampToLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n  \\t\\t\\tvar target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\\n\\n\\n  \\t\\t\\tvar t = this.closestPointToPointParameter(p, clampToLine);\\n\\n  \\t\\t\\treturn this.delta(target).multiplyScalar(t).add(this.start);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(l) {\\n\\n  \\t\\t\\treturn l.start.equals(this.start) && l.end.equals(this.end);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Line3;\\n  }();\\n\\n  var a$2 = new Vector3();\\n\\n  var b$2 = new Vector3();\\n\\n  var c = new Vector3();\\n\\n  var Matrix4 = function () {\\n  \\t\\tfunction Matrix4() {\\n  \\t\\t\\t\\tclassCallCheck(this, Matrix4);\\n\\n\\n  \\t\\t\\t\\tthis.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Matrix4, [{\\n  \\t\\t\\t\\tkey: \"set\",\\n  \\t\\t\\t\\tvalue: function set$$1(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = n00;te[4] = n01;te[8] = n02;te[12] = n03;\\n  \\t\\t\\t\\t\\t\\tte[1] = n10;te[5] = n11;te[9] = n12;te[13] = n13;\\n  \\t\\t\\t\\t\\t\\tte[2] = n20;te[6] = n21;te[10] = n22;te[14] = n23;\\n  \\t\\t\\t\\t\\t\\tte[3] = n30;te[7] = n31;te[11] = n32;te[15] = n33;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"identity\",\\n  \\t\\t\\t\\tvalue: function identity() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"copy\",\\n  \\t\\t\\t\\tvalue: function copy(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = me[0];te[1] = me[1];te[2] = me[2];te[3] = me[3];\\n  \\t\\t\\t\\t\\t\\tte[4] = me[4];te[5] = me[5];te[6] = me[6];te[7] = me[7];\\n  \\t\\t\\t\\t\\t\\tte[8] = me[8];te[9] = me[9];te[10] = me[10];te[11] = me[11];\\n  \\t\\t\\t\\t\\t\\tte[12] = me[12];te[13] = me[13];te[14] = me[14];te[15] = me[15];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"clone\",\\n  \\t\\t\\t\\tvalue: function clone() {\\n\\n  \\t\\t\\t\\t\\t\\treturn new this.constructor().fromArray(this.elements);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"fromArray\",\\n  \\t\\t\\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 16; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[i] = array[i + offset];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"toArray\",\\n  \\t\\t\\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\t\\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\t\\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 16; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tarray[i + offset] = te[i];\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn array;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"getMaxScaleOnAxis\",\\n  \\t\\t\\t\\tvalue: function getMaxScaleOnAxis() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\\n  \\t\\t\\t\\t\\t\\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\\n  \\t\\t\\t\\t\\t\\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\\n\\n  \\t\\t\\t\\t\\t\\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"copyPosition\",\\n  \\t\\t\\t\\tvalue: function copyPosition(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = me[12];\\n  \\t\\t\\t\\t\\t\\tte[13] = me[13];\\n  \\t\\t\\t\\t\\t\\tte[14] = me[14];\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"setPosition\",\\n  \\t\\t\\t\\tvalue: function setPosition(p) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = p.x;\\n  \\t\\t\\t\\t\\t\\tte[13] = p.y;\\n  \\t\\t\\t\\t\\t\\tte[14] = p.z;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"extractBasis\",\\n  \\t\\t\\t\\tvalue: function extractBasis(xAxis, yAxis, zAxis) {\\n\\n  \\t\\t\\t\\t\\t\\txAxis.setFromMatrixColumn(this, 0);\\n  \\t\\t\\t\\t\\t\\tyAxis.setFromMatrixColumn(this, 1);\\n  \\t\\t\\t\\t\\t\\tzAxis.setFromMatrixColumn(this, 2);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeBasis\",\\n  \\t\\t\\t\\tvalue: function makeBasis(xAxis, yAxis, zAxis) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"extractRotation\",\\n  \\t\\t\\t\\tvalue: function extractRotation(m) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar scaleX = 1.0 / a$2.setFromMatrixColumn(m, 0).length();\\n  \\t\\t\\t\\t\\t\\tvar scaleY = 1.0 / a$2.setFromMatrixColumn(m, 1).length();\\n  \\t\\t\\t\\t\\t\\tvar scaleZ = 1.0 / a$2.setFromMatrixColumn(m, 2).length();\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = me[0] * scaleX;\\n  \\t\\t\\t\\t\\t\\tte[1] = me[1] * scaleX;\\n  \\t\\t\\t\\t\\t\\tte[2] = me[2] * scaleX;\\n\\n  \\t\\t\\t\\t\\t\\tte[4] = me[4] * scaleY;\\n  \\t\\t\\t\\t\\t\\tte[5] = me[5] * scaleY;\\n  \\t\\t\\t\\t\\t\\tte[6] = me[6] * scaleY;\\n\\n  \\t\\t\\t\\t\\t\\tte[8] = me[8] * scaleZ;\\n  \\t\\t\\t\\t\\t\\tte[9] = me[9] * scaleZ;\\n  \\t\\t\\t\\t\\t\\tte[10] = me[10] * scaleZ;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeRotationFromEuler\",\\n  \\t\\t\\t\\tvalue: function makeRotationFromEuler(euler) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = euler.x;\\n  \\t\\t\\t\\t\\t\\tvar y = euler.y;\\n  \\t\\t\\t\\t\\t\\tvar z = euler.z;\\n\\n  \\t\\t\\t\\t\\t\\tvar a = Math.cos(x),\\n  \\t\\t\\t\\t\\t\\t    b = Math.sin(x);\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(y),\\n  \\t\\t\\t\\t\\t\\t    d = Math.sin(y);\\n  \\t\\t\\t\\t\\t\\tvar e = Math.cos(z),\\n  \\t\\t\\t\\t\\t\\t    f = Math.sin(z);\\n\\n  \\t\\t\\t\\t\\t\\tvar ae = void 0,\\n  \\t\\t\\t\\t\\t\\t    af = void 0,\\n  \\t\\t\\t\\t\\t\\t    be = void 0,\\n  \\t\\t\\t\\t\\t\\t    bf = void 0;\\n  \\t\\t\\t\\t\\t\\tvar ce = void 0,\\n  \\t\\t\\t\\t\\t\\t    cf = void 0,\\n  \\t\\t\\t\\t\\t\\t    de = void 0,\\n  \\t\\t\\t\\t\\t\\t    df = void 0;\\n  \\t\\t\\t\\t\\t\\tvar ac = void 0,\\n  \\t\\t\\t\\t\\t\\t    ad = void 0,\\n  \\t\\t\\t\\t\\t\\t    bc = void 0,\\n  \\t\\t\\t\\t\\t\\t    bd = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tswitch (euler.order) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.XYZ:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = -c * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = af + be * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = ae - bf * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = -b * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = bf - ae * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = be + af * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.YXZ:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = ce + df * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = de * b - cf;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = a * d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = a * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = -b;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = cf * b - de;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = df + ce * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.ZXY:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = ce - df * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = -a * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = de + cf * b;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = cf + de * b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = df - ce * b;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = -a * d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = b;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.ZYX:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = be * d - af;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = ae * d + bf;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = c * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = bf * d + ae;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = af * d - be;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = -d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = b * c;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = a * c;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.YZX:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = bd - ac * f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = bc * f + ad;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = -b * e;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = -d * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = ad * f + bc;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = ac - bd * f;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase RotationOrder.XZY:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[0] = c * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[4] = -f;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[8] = d * e;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[1] = ac * f + bd;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[5] = a * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[9] = ad * f - bc;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[2] = bc * f - ad;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[6] = b * e;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tte[10] = bd * f + ac;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;\\n  \\t\\t\\t\\t\\t\\tte[7] = 0;\\n  \\t\\t\\t\\t\\t\\tte[11] = 0;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = 0;\\n  \\t\\t\\t\\t\\t\\tte[13] = 0;\\n  \\t\\t\\t\\t\\t\\tte[14] = 0;\\n  \\t\\t\\t\\t\\t\\tte[15] = 1;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeRotationFromQuaternion\",\\n  \\t\\t\\t\\tvalue: function makeRotationFromQuaternion(q) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = q.x,\\n  \\t\\t\\t\\t\\t\\t    y = q.y,\\n  \\t\\t\\t\\t\\t\\t    z = q.z,\\n  \\t\\t\\t\\t\\t\\t    w = q.w;\\n  \\t\\t\\t\\t\\t\\tvar x2 = x + x,\\n  \\t\\t\\t\\t\\t\\t    y2 = y + y,\\n  \\t\\t\\t\\t\\t\\t    z2 = z + z;\\n  \\t\\t\\t\\t\\t\\tvar xx = x * x2,\\n  \\t\\t\\t\\t\\t\\t    xy = x * y2,\\n  \\t\\t\\t\\t\\t\\t    xz = x * z2;\\n  \\t\\t\\t\\t\\t\\tvar yy = y * y2,\\n  \\t\\t\\t\\t\\t\\t    yz = y * z2,\\n  \\t\\t\\t\\t\\t\\t    zz = z * z2;\\n  \\t\\t\\t\\t\\t\\tvar wx = w * x2,\\n  \\t\\t\\t\\t\\t\\t    wy = w * y2,\\n  \\t\\t\\t\\t\\t\\t    wz = w * z2;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = 1 - (yy + zz);\\n  \\t\\t\\t\\t\\t\\tte[4] = xy - wz;\\n  \\t\\t\\t\\t\\t\\tte[8] = xz + wy;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = xy + wz;\\n  \\t\\t\\t\\t\\t\\tte[5] = 1 - (xx + zz);\\n  \\t\\t\\t\\t\\t\\tte[9] = yz - wx;\\n\\n  \\t\\t\\t\\t\\t\\tte[2] = xz - wy;\\n  \\t\\t\\t\\t\\t\\tte[6] = yz + wx;\\n  \\t\\t\\t\\t\\t\\tte[10] = 1 - (xx + yy);\\n\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;\\n  \\t\\t\\t\\t\\t\\tte[7] = 0;\\n  \\t\\t\\t\\t\\t\\tte[11] = 0;\\n\\n  \\t\\t\\t\\t\\t\\tte[12] = 0;\\n  \\t\\t\\t\\t\\t\\tte[13] = 0;\\n  \\t\\t\\t\\t\\t\\tte[14] = 0;\\n  \\t\\t\\t\\t\\t\\tte[15] = 1;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"lookAt\",\\n  \\t\\t\\t\\tvalue: function lookAt(eye, target, up) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar x = a$2,\\n  \\t\\t\\t\\t\\t\\t    y = b$2,\\n  \\t\\t\\t\\t\\t\\t    z = c;\\n\\n  \\t\\t\\t\\t\\t\\tz.subVectors(eye, target);\\n\\n  \\t\\t\\t\\t\\t\\tif (z.lengthSquared() === 0) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tz.z = 1;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tz.normalize();\\n  \\t\\t\\t\\t\\t\\tx.crossVectors(up, z);\\n\\n  \\t\\t\\t\\t\\t\\tif (x.lengthSquared() === 0) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (Math.abs(up.z) === 1) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tz.x += 1e-4;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tz.z += 1e-4;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tz.normalize();\\n  \\t\\t\\t\\t\\t\\t\\t\\tx.crossVectors(up, z);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tx.normalize();\\n  \\t\\t\\t\\t\\t\\ty.crossVectors(z, x);\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = x.x;te[4] = y.x;te[8] = z.x;\\n  \\t\\t\\t\\t\\t\\tte[1] = x.y;te[5] = y.y;te[9] = z.y;\\n  \\t\\t\\t\\t\\t\\tte[2] = x.z;te[6] = y.z;te[10] = z.z;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"multiplyMatrices\",\\n  \\t\\t\\t\\tvalue: function multiplyMatrices(a, b) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar ae = a.elements;\\n  \\t\\t\\t\\t\\t\\tvar be = b.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar a00 = ae[0],\\n  \\t\\t\\t\\t\\t\\t    a01 = ae[4],\\n  \\t\\t\\t\\t\\t\\t    a02 = ae[8],\\n  \\t\\t\\t\\t\\t\\t    a03 = ae[12];\\n  \\t\\t\\t\\t\\t\\tvar a10 = ae[1],\\n  \\t\\t\\t\\t\\t\\t    a11 = ae[5],\\n  \\t\\t\\t\\t\\t\\t    a12 = ae[9],\\n  \\t\\t\\t\\t\\t\\t    a13 = ae[13];\\n  \\t\\t\\t\\t\\t\\tvar a20 = ae[2],\\n  \\t\\t\\t\\t\\t\\t    a21 = ae[6],\\n  \\t\\t\\t\\t\\t\\t    a22 = ae[10],\\n  \\t\\t\\t\\t\\t\\t    a23 = ae[14];\\n  \\t\\t\\t\\t\\t\\tvar a30 = ae[3],\\n  \\t\\t\\t\\t\\t\\t    a31 = ae[7],\\n  \\t\\t\\t\\t\\t\\t    a32 = ae[11],\\n  \\t\\t\\t\\t\\t\\t    a33 = ae[15];\\n\\n  \\t\\t\\t\\t\\t\\tvar b00 = be[0],\\n  \\t\\t\\t\\t\\t\\t    b01 = be[4],\\n  \\t\\t\\t\\t\\t\\t    b02 = be[8],\\n  \\t\\t\\t\\t\\t\\t    b03 = be[12];\\n  \\t\\t\\t\\t\\t\\tvar b10 = be[1],\\n  \\t\\t\\t\\t\\t\\t    b11 = be[5],\\n  \\t\\t\\t\\t\\t\\t    b12 = be[9],\\n  \\t\\t\\t\\t\\t\\t    b13 = be[13];\\n  \\t\\t\\t\\t\\t\\tvar b20 = be[2],\\n  \\t\\t\\t\\t\\t\\t    b21 = be[6],\\n  \\t\\t\\t\\t\\t\\t    b22 = be[10],\\n  \\t\\t\\t\\t\\t\\t    b23 = be[14];\\n  \\t\\t\\t\\t\\t\\tvar b30 = be[3],\\n  \\t\\t\\t\\t\\t\\t    b31 = be[7],\\n  \\t\\t\\t\\t\\t\\t    b32 = be[11],\\n  \\t\\t\\t\\t\\t\\t    b33 = be[15];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\\n  \\t\\t\\t\\t\\t\\tte[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\\n  \\t\\t\\t\\t\\t\\tte[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\\n  \\t\\t\\t\\t\\t\\tte[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\\n  \\t\\t\\t\\t\\t\\tte[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\\n  \\t\\t\\t\\t\\t\\tte[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\\n  \\t\\t\\t\\t\\t\\tte[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\\n  \\t\\t\\t\\t\\t\\tte[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\\n  \\t\\t\\t\\t\\t\\tte[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\\n  \\t\\t\\t\\t\\t\\tte[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\\n\\n  \\t\\t\\t\\t\\t\\tte[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\\n  \\t\\t\\t\\t\\t\\tte[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\\n  \\t\\t\\t\\t\\t\\tte[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\\n  \\t\\t\\t\\t\\t\\tte[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"multiply\",\\n  \\t\\t\\t\\tvalue: function multiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(this, m);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"premultiply\",\\n  \\t\\t\\t\\tvalue: function premultiply(m) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.multiplyMatrices(m, this);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"multiplyScalar\",\\n  \\t\\t\\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;\\n  \\t\\t\\t\\t\\t\\tte[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;\\n  \\t\\t\\t\\t\\t\\tte[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;\\n  \\t\\t\\t\\t\\t\\tte[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"determinant\",\\n  \\t\\t\\t\\tvalue: function determinant() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n00 = te[0],\\n  \\t\\t\\t\\t\\t\\t    n01 = te[4],\\n  \\t\\t\\t\\t\\t\\t    n02 = te[8],\\n  \\t\\t\\t\\t\\t\\t    n03 = te[12];\\n  \\t\\t\\t\\t\\t\\tvar n10 = te[1],\\n  \\t\\t\\t\\t\\t\\t    n11 = te[5],\\n  \\t\\t\\t\\t\\t\\t    n12 = te[9],\\n  \\t\\t\\t\\t\\t\\t    n13 = te[13];\\n  \\t\\t\\t\\t\\t\\tvar n20 = te[2],\\n  \\t\\t\\t\\t\\t\\t    n21 = te[6],\\n  \\t\\t\\t\\t\\t\\t    n22 = te[10],\\n  \\t\\t\\t\\t\\t\\t    n23 = te[14];\\n  \\t\\t\\t\\t\\t\\tvar n30 = te[3],\\n  \\t\\t\\t\\t\\t\\t    n31 = te[7],\\n  \\t\\t\\t\\t\\t\\t    n32 = te[11],\\n  \\t\\t\\t\\t\\t\\t    n33 = te[15];\\n\\n  \\t\\t\\t\\t\\t\\tvar n00n11 = n00 * n11,\\n  \\t\\t\\t\\t\\t\\t    n00n12 = n00 * n12,\\n  \\t\\t\\t\\t\\t\\t    n00n13 = n00 * n13;\\n  \\t\\t\\t\\t\\t\\tvar n01n10 = n01 * n10,\\n  \\t\\t\\t\\t\\t\\t    n01n12 = n01 * n12,\\n  \\t\\t\\t\\t\\t\\t    n01n13 = n01 * n13;\\n  \\t\\t\\t\\t\\t\\tvar n02n10 = n02 * n10,\\n  \\t\\t\\t\\t\\t\\t    n02n11 = n02 * n11,\\n  \\t\\t\\t\\t\\t\\t    n02n13 = n02 * n13;\\n  \\t\\t\\t\\t\\t\\tvar n03n10 = n03 * n10,\\n  \\t\\t\\t\\t\\t\\t    n03n11 = n03 * n11,\\n  \\t\\t\\t\\t\\t\\t    n03n12 = n03 * n12;\\n\\n  \\t\\t\\t\\t\\t\\treturn n30 * (n03n12 * n21 - n02n13 * n21 - n03n11 * n22 + n01n13 * n22 + n02n11 * n23 - n01n12 * n23) + n31 * (n00n12 * n23 - n00n13 * n22 + n03n10 * n22 - n02n10 * n23 + n02n13 * n20 - n03n12 * n20) + n32 * (n00n13 * n21 - n00n11 * n23 - n03n10 * n21 + n01n10 * n23 + n03n11 * n20 - n01n13 * n20) + n33 * (-n02n11 * n20 - n00n12 * n21 + n00n11 * n22 + n02n10 * n21 - n01n10 * n22 + n01n12 * n20);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"getInverse\",\\n  \\t\\t\\t\\tvalue: function getInverse(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n00 = me[0],\\n  \\t\\t\\t\\t\\t\\t    n10 = me[1],\\n  \\t\\t\\t\\t\\t\\t    n20 = me[2],\\n  \\t\\t\\t\\t\\t\\t    n30 = me[3];\\n  \\t\\t\\t\\t\\t\\tvar n01 = me[4],\\n  \\t\\t\\t\\t\\t\\t    n11 = me[5],\\n  \\t\\t\\t\\t\\t\\t    n21 = me[6],\\n  \\t\\t\\t\\t\\t\\t    n31 = me[7];\\n  \\t\\t\\t\\t\\t\\tvar n02 = me[8],\\n  \\t\\t\\t\\t\\t\\t    n12 = me[9],\\n  \\t\\t\\t\\t\\t\\t    n22 = me[10],\\n  \\t\\t\\t\\t\\t\\t    n32 = me[11];\\n  \\t\\t\\t\\t\\t\\tvar n03 = me[12],\\n  \\t\\t\\t\\t\\t\\t    n13 = me[13],\\n  \\t\\t\\t\\t\\t\\t    n23 = me[14],\\n  \\t\\t\\t\\t\\t\\t    n33 = me[15];\\n\\n  \\t\\t\\t\\t\\t\\tvar t00 = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\\n  \\t\\t\\t\\t\\t\\tvar t01 = n03 * n22 * n31 - n02 * n23 * n31 - n03 * n21 * n32 + n01 * n23 * n32 + n02 * n21 * n33 - n01 * n22 * n33;\\n  \\t\\t\\t\\t\\t\\tvar t02 = n02 * n13 * n31 - n03 * n12 * n31 + n03 * n11 * n32 - n01 * n13 * n32 - n02 * n11 * n33 + n01 * n12 * n33;\\n  \\t\\t\\t\\t\\t\\tvar t03 = n03 * n12 * n21 - n02 * n13 * n21 - n03 * n11 * n22 + n01 * n13 * n22 + n02 * n11 * n23 - n01 * n12 * n23;\\n\\n  \\t\\t\\t\\t\\t\\tvar det = n00 * t00 + n10 * t01 + n20 * t02 + n30 * t03;\\n\\n  \\t\\t\\t\\t\\t\\tvar invDet = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (det !== 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tinvDet = 1.0 / det;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[0] = t00 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[1] = (n13 * n22 * n30 - n12 * n23 * n30 - n13 * n20 * n32 + n10 * n23 * n32 + n12 * n20 * n33 - n10 * n22 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[2] = (n11 * n23 * n30 - n13 * n21 * n30 + n13 * n20 * n31 - n10 * n23 * n31 - n11 * n20 * n33 + n10 * n21 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[3] = (n12 * n21 * n30 - n11 * n22 * n30 - n12 * n20 * n31 + n10 * n22 * n31 + n11 * n20 * n32 - n10 * n21 * n32) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[4] = t01 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[5] = (n02 * n23 * n30 - n03 * n22 * n30 + n03 * n20 * n32 - n00 * n23 * n32 - n02 * n20 * n33 + n00 * n22 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[6] = (n03 * n21 * n30 - n01 * n23 * n30 - n03 * n20 * n31 + n00 * n23 * n31 + n01 * n20 * n33 - n00 * n21 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[7] = (n01 * n22 * n30 - n02 * n21 * n30 + n02 * n20 * n31 - n00 * n22 * n31 - n01 * n20 * n32 + n00 * n21 * n32) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[8] = t02 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[9] = (n03 * n12 * n30 - n02 * n13 * n30 - n03 * n10 * n32 + n00 * n13 * n32 + n02 * n10 * n33 - n00 * n12 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[10] = (n01 * n13 * n30 - n03 * n11 * n30 + n03 * n10 * n31 - n00 * n13 * n31 - n01 * n10 * n33 + n00 * n11 * n33) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[11] = (n02 * n11 * n30 - n01 * n12 * n30 - n02 * n10 * n31 + n00 * n12 * n31 + n01 * n10 * n32 - n00 * n11 * n32) * invDet;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[12] = t03 * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[13] = (n02 * n13 * n20 - n03 * n12 * n20 + n03 * n10 * n22 - n00 * n13 * n22 - n02 * n10 * n23 + n00 * n12 * n23) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[14] = (n03 * n11 * n20 - n01 * n13 * n20 - n03 * n10 * n21 + n00 * n13 * n21 + n01 * n10 * n23 - n00 * n11 * n23) * invDet;\\n  \\t\\t\\t\\t\\t\\t\\t\\tte[15] = (n01 * n12 * n20 - n02 * n11 * n20 + n02 * n10 * n21 - n00 * n12 * n21 - n01 * n10 * n22 + n00 * n11 * n22) * invDet;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tconsole.error(\"Can\\'t invert matrix, determinant is zero\", matrix);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.identity();\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"transpose\",\\n  \\t\\t\\t\\tvalue: function transpose() {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar t = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tt = te[1];te[1] = te[4];te[4] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[2];te[2] = te[8];te[8] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[6];te[6] = te[9];te[9] = t;\\n\\n  \\t\\t\\t\\t\\t\\tt = te[3];te[3] = te[12];te[12] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[7];te[7] = te[13];te[13] = t;\\n  \\t\\t\\t\\t\\t\\tt = te[11];te[11] = te[14];te[14] = t;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"scale\",\\n  \\t\\t\\t\\tvalue: function scale(sx, sy, sz) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= sx;te[4] *= sy;te[8] *= sz;\\n  \\t\\t\\t\\t\\t\\tte[1] *= sx;te[5] *= sy;te[9] *= sz;\\n  \\t\\t\\t\\t\\t\\tte[2] *= sx;te[6] *= sy;te[10] *= sz;\\n  \\t\\t\\t\\t\\t\\tte[3] *= sx;te[7] *= sy;te[11] *= sz;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeScale\",\\n  \\t\\t\\t\\tvalue: function makeScale(x, y, z) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeTranslation\",\\n  \\t\\t\\t\\tvalue: function makeTranslation(x, y, z) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeRotationX\",\\n  \\t\\t\\t\\tvalue: function makeRotationX(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta),\\n  \\t\\t\\t\\t\\t\\t    s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeRotationY\",\\n  \\t\\t\\t\\tvalue: function makeRotationY(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta),\\n  \\t\\t\\t\\t\\t\\t    s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeRotationZ\",\\n  \\t\\t\\t\\tvalue: function makeRotationZ(theta) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(theta),\\n  \\t\\t\\t\\t\\t\\t    s = Math.sin(theta);\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeRotationAxis\",\\n  \\t\\t\\t\\tvalue: function makeRotationAxis(axis, angle) {\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.cos(angle);\\n  \\t\\t\\t\\t\\t\\tvar s = Math.sin(angle);\\n\\n  \\t\\t\\t\\t\\t\\tvar t = 1.0 - c;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = axis.x,\\n  \\t\\t\\t\\t\\t\\t    y = axis.y,\\n  \\t\\t\\t\\t\\t\\t    z = axis.z;\\n  \\t\\t\\t\\t\\t\\tvar tx = t * x,\\n  \\t\\t\\t\\t\\t\\t    ty = t * y;\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeShear\",\\n  \\t\\t\\t\\tvalue: function makeShear(x, y, z) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"compose\",\\n  \\t\\t\\t\\tvalue: function compose(position, quaternion, scale) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.makeRotationFromQuaternion(quaternion);\\n  \\t\\t\\t\\t\\t\\tthis.scale(scale.x, scale.y, scale.z);\\n  \\t\\t\\t\\t\\t\\tthis.setPosition(position);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"decompose\",\\n  \\t\\t\\t\\tvalue: function decompose(position, quaternion, scale) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar n00 = te[0],\\n  \\t\\t\\t\\t\\t\\t    n10 = te[1],\\n  \\t\\t\\t\\t\\t\\t    n20 = te[2];\\n  \\t\\t\\t\\t\\t\\tvar n01 = te[4],\\n  \\t\\t\\t\\t\\t\\t    n11 = te[5],\\n  \\t\\t\\t\\t\\t\\t    n21 = te[6];\\n  \\t\\t\\t\\t\\t\\tvar n02 = te[8],\\n  \\t\\t\\t\\t\\t\\t    n12 = te[9],\\n  \\t\\t\\t\\t\\t\\t    n22 = te[10];\\n\\n  \\t\\t\\t\\t\\t\\tvar det = this.determinant();\\n\\n  \\t\\t\\t\\t\\t\\tvar sx = a$2.set(n00, n10, n20).length() * (det < 0 ? -1 : 1);\\n  \\t\\t\\t\\t\\t\\tvar sy = a$2.set(n01, n11, n21).length();\\n  \\t\\t\\t\\t\\t\\tvar sz = a$2.set(n02, n12, n22).length();\\n\\n  \\t\\t\\t\\t\\t\\tvar invSX = 1.0 / sx;\\n  \\t\\t\\t\\t\\t\\tvar invSY = 1.0 / sy;\\n  \\t\\t\\t\\t\\t\\tvar invSZ = 1.0 / sz;\\n\\n  \\t\\t\\t\\t\\t\\tposition.x = te[12];\\n  \\t\\t\\t\\t\\t\\tposition.y = te[13];\\n  \\t\\t\\t\\t\\t\\tposition.z = te[14];\\n\\n  \\t\\t\\t\\t\\t\\tte[0] *= invSX;te[1] *= invSX;te[2] *= invSX;\\n  \\t\\t\\t\\t\\t\\tte[4] *= invSY;te[5] *= invSY;te[6] *= invSY;\\n  \\t\\t\\t\\t\\t\\tte[8] *= invSZ;te[9] *= invSZ;te[10] *= invSZ;\\n\\n  \\t\\t\\t\\t\\t\\tquaternion.setFromRotationMatrix(this);\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = n00;te[1] = n10;te[2] = n20;\\n  \\t\\t\\t\\t\\t\\tte[4] = n01;te[5] = n11;te[6] = n21;\\n  \\t\\t\\t\\t\\t\\tte[8] = n02;te[9] = n12;te[10] = n22;\\n\\n  \\t\\t\\t\\t\\t\\tscale.x = sx;\\n  \\t\\t\\t\\t\\t\\tscale.y = sy;\\n  \\t\\t\\t\\t\\t\\tscale.z = sz;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makePerspective\",\\n  \\t\\t\\t\\tvalue: function makePerspective(left, right, top, bottom, near, far) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar x = 2 * near / (right - left);\\n  \\t\\t\\t\\t\\t\\tvar y = 2 * near / (top - bottom);\\n\\n  \\t\\t\\t\\t\\t\\tvar a = (right + left) / (right - left);\\n  \\t\\t\\t\\t\\t\\tvar b = (top + bottom) / (top - bottom);\\n  \\t\\t\\t\\t\\t\\tvar c = -(far + near) / (far - near);\\n  \\t\\t\\t\\t\\t\\tvar d = -2 * far * near / (far - near);\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = x;te[4] = 0;te[8] = a;te[12] = 0;\\n  \\t\\t\\t\\t\\t\\tte[1] = 0;te[5] = y;te[9] = b;te[13] = 0;\\n  \\t\\t\\t\\t\\t\\tte[2] = 0;te[6] = 0;te[10] = c;te[14] = d;\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"makeOrthographic\",\\n  \\t\\t\\t\\tvalue: function makeOrthographic(left, right, top, bottom, near, far) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar w = 1.0 / (right - left);\\n  \\t\\t\\t\\t\\t\\tvar h = 1.0 / (top - bottom);\\n  \\t\\t\\t\\t\\t\\tvar p = 1.0 / (far - near);\\n\\n  \\t\\t\\t\\t\\t\\tvar x = (right + left) * w;\\n  \\t\\t\\t\\t\\t\\tvar y = (top + bottom) * h;\\n  \\t\\t\\t\\t\\t\\tvar z = (far + near) * p;\\n\\n  \\t\\t\\t\\t\\t\\tte[0] = 2 * w;te[4] = 0;te[8] = 0;te[12] = -x;\\n  \\t\\t\\t\\t\\t\\tte[1] = 0;te[5] = 2 * h;te[9] = 0;te[13] = -y;\\n  \\t\\t\\t\\t\\t\\tte[2] = 0;te[6] = 0;te[10] = -2 * p;te[14] = -z;\\n  \\t\\t\\t\\t\\t\\tte[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"equals\",\\n  \\t\\t\\t\\tvalue: function equals(matrix) {\\n\\n  \\t\\t\\t\\t\\t\\tvar te = this.elements;\\n  \\t\\t\\t\\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\t\\t\\t\\tvar result = true;\\n  \\t\\t\\t\\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; result && i < 16; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (te[i] !== me[i]) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Matrix4;\\n  }();\\n\\n  var v$3 = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];\\n\\n  var Ray = function () {\\n  \\tfunction Ray() {\\n  \\t\\tvar origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\tclassCallCheck(this, Ray);\\n\\n\\n  \\t\\tthis.origin = origin;\\n\\n  \\t\\tthis.direction = direction;\\n  \\t}\\n\\n  \\tcreateClass(Ray, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(origin, direction) {\\n\\n  \\t\\t\\tthis.origin.copy(origin);\\n  \\t\\t\\tthis.direction.copy(direction);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(r) {\\n\\n  \\t\\t\\tthis.origin.copy(r.origin);\\n  \\t\\t\\tthis.direction.copy(r.direction);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"at\",\\n  \\t\\tvalue: function at(t) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lookAt\",\\n  \\t\\tvalue: function lookAt(target) {\\n\\n  \\t\\t\\tthis.direction.copy(target).sub(this.origin).normalize();\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"recast\",\\n  \\t\\tvalue: function recast(t) {\\n\\n  \\t\\t\\tthis.origin.copy(this.at(t, v$3[0]));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"closestPointToPoint\",\\n  \\t\\tvalue: function closestPointToPoint(p) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar directionDistance = target.subVectors(p, this.origin).dot(this.direction);\\n\\n  \\t\\t\\treturn directionDistance >= 0.0 ? target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin) : target.copy(this.origin);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceSquaredToPoint\",\\n  \\t\\tvalue: function distanceSquaredToPoint(p) {\\n\\n  \\t\\t\\tvar directionDistance = v$3[0].subVectors(p, this.origin).dot(this.direction);\\n\\n  \\t\\t\\treturn directionDistance < 0.0 ? this.origin.distanceToSquared(p) : v$3[0].copy(this.direction).multiplyScalar(directionDistance).add(this.origin).distanceToSquared(p);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToPoint\",\\n  \\t\\tvalue: function distanceToPoint(p) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceSquaredToPoint(p));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToPlane\",\\n  \\t\\tvalue: function distanceToPlane(p) {\\n\\n  \\t\\t\\tvar denominator = p.normal.dot(this.direction);\\n\\n  \\t\\t\\tvar t = denominator !== 0.0 ? -(this.origin.dot(p.normal) + p.constant) / denominator : p.distanceToPoint(this.origin) === 0.0 ? 0.0 : -1.0;\\n\\n  \\t\\t\\treturn t >= 0.0 ? t : null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceSquaredToSegment\",\\n  \\t\\tvalue: function distanceSquaredToSegment(v0, v1, pointOnRay, pointOnSegment) {\\n\\n  \\t\\t\\tvar segCenter = v$3[0].copy(v0).add(v1).multiplyScalar(0.5);\\n  \\t\\t\\tvar segDir = v$3[1].copy(v1).sub(v0).normalize();\\n  \\t\\t\\tvar diff = v$3[2].copy(this.origin).sub(segCenter);\\n\\n  \\t\\t\\tvar segExtent = v0.distanceTo(v1) * 0.5;\\n  \\t\\t\\tvar a01 = -this.direction.dot(segDir);\\n  \\t\\t\\tvar b0 = diff.dot(this.direction);\\n  \\t\\t\\tvar b1 = -diff.dot(segDir);\\n  \\t\\t\\tvar c = diff.lengthSq();\\n  \\t\\t\\tvar det = Math.abs(1.0 - a01 * a01);\\n\\n  \\t\\t\\tvar s0 = void 0,\\n  \\t\\t\\t    s1 = void 0,\\n  \\t\\t\\t    extDet = void 0,\\n  \\t\\t\\t    invDet = void 0,\\n  \\t\\t\\t    sqrDist = void 0;\\n\\n  \\t\\t\\tif (det > 0.0) {\\n  \\t\\t\\t\\ts0 = a01 * b1 - b0;\\n  \\t\\t\\t\\ts1 = a01 * b0 - b1;\\n  \\t\\t\\t\\textDet = segExtent * det;\\n\\n  \\t\\t\\t\\tif (s0 >= 0.0) {\\n\\n  \\t\\t\\t\\t\\tif (s1 >= -extDet) {\\n\\n  \\t\\t\\t\\t\\t\\tif (s1 <= extDet) {\\n  \\t\\t\\t\\t\\t\\t\\tinvDet = 1.0 / det;\\n  \\t\\t\\t\\t\\t\\t\\ts0 *= invDet;\\n  \\t\\t\\t\\t\\t\\t\\ts1 *= invDet;\\n  \\t\\t\\t\\t\\t\\t\\tsqrDist = s0 * (s0 + a01 * s1 + 2.0 * b0) + s1 * (a01 * s0 + s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\t\\ts1 = segExtent;\\n  \\t\\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * s1 + b0));\\n  \\t\\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\ts1 = -segExtent;\\n  \\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * s1 + b0));\\n  \\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tif (s1 <= -extDet) {\\n  \\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(-a01 * segExtent + b0));\\n  \\t\\t\\t\\t\\t\\ts1 = s0 > 0.0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\\n  \\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t} else if (s1 <= extDet) {\\n  \\t\\t\\t\\t\\t\\ts0 = 0.0;\\n  \\t\\t\\t\\t\\t\\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\\n  \\t\\t\\t\\t\\t\\tsqrDist = s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * segExtent + b0));\\n  \\t\\t\\t\\t\\t\\ts1 = s0 > 0.0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\\n  \\t\\t\\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\ts1 = a01 > 0.0 ? -segExtent : segExtent;\\n  \\t\\t\\t\\ts0 = Math.max(0.0, -(a01 * s1 + b0));\\n  \\t\\t\\t\\tsqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (pointOnRay !== undefined) {\\n\\n  \\t\\t\\t\\tpointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (pointOnSegment !== undefined) {\\n\\n  \\t\\t\\t\\tpointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn sqrDist;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectSphere\",\\n  \\t\\tvalue: function intersectSphere(s) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar ab = v$3[0].subVectors(s.center, this.origin);\\n  \\t\\t\\tvar tca = ab.dot(this.direction);\\n  \\t\\t\\tvar d2 = ab.dot(ab) - tca * tca;\\n  \\t\\t\\tvar radius2 = s.radius * s.radius;\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar thc = void 0,\\n  \\t\\t\\t    t0 = void 0,\\n  \\t\\t\\t    t1 = void 0;\\n\\n  \\t\\t\\tif (d2 <= radius2) {\\n\\n  \\t\\t\\t\\tthc = Math.sqrt(radius2 - d2);\\n\\n  \\t\\t\\t\\tt0 = tca - thc;\\n\\n  \\t\\t\\t\\tt1 = tca + thc;\\n\\n  \\t\\t\\t\\tif (t0 >= 0.0 || t1 >= 0.0) {\\n  \\t\\t\\t\\t\\tresult = t0 < 0.0 ? this.at(t1, target) : this.at(t0, target);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsSphere\",\\n  \\t\\tvalue: function intersectsSphere(s) {\\n\\n  \\t\\t\\treturn this.distanceToPoint(s.center) <= s.radius;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectPlane\",\\n  \\t\\tvalue: function intersectPlane(p) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar t = this.distanceToPlane(p);\\n\\n  \\t\\t\\treturn t === null ? null : this.at(t, target);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsPlane\",\\n  \\t\\tvalue: function intersectsPlane(p) {\\n\\n  \\t\\t\\tvar distanceToPoint = p.distanceToPoint(this.origin);\\n\\n  \\t\\t\\treturn distanceToPoint === 0.0 || p.normal.dot(this.direction) * distanceToPoint < 0.0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectBox\",\\n  \\t\\tvalue: function intersectBox(b) {\\n  \\t\\t\\tvar target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n\\n\\n  \\t\\t\\tvar origin = this.origin;\\n  \\t\\t\\tvar direction = this.direction;\\n  \\t\\t\\tvar min = b.min;\\n  \\t\\t\\tvar max = b.max;\\n\\n  \\t\\t\\tvar invDirX = 1.0 / direction.x;\\n  \\t\\t\\tvar invDirY = 1.0 / direction.y;\\n  \\t\\t\\tvar invDirZ = 1.0 / direction.z;\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar tmin = void 0,\\n  \\t\\t\\t    tmax = void 0,\\n  \\t\\t\\t    tymin = void 0,\\n  \\t\\t\\t    tymax = void 0,\\n  \\t\\t\\t    tzmin = void 0,\\n  \\t\\t\\t    tzmax = void 0;\\n\\n  \\t\\t\\tif (invDirX >= 0.0) {\\n\\n  \\t\\t\\t\\ttmin = (min.x - origin.x) * invDirX;\\n  \\t\\t\\t\\ttmax = (max.x - origin.x) * invDirX;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttmin = (max.x - origin.x) * invDirX;\\n  \\t\\t\\t\\ttmax = (min.x - origin.x) * invDirX;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (invDirY >= 0.0) {\\n\\n  \\t\\t\\t\\ttymin = (min.y - origin.y) * invDirY;\\n  \\t\\t\\t\\ttymax = (max.y - origin.y) * invDirY;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttymin = (max.y - origin.y) * invDirY;\\n  \\t\\t\\t\\ttymax = (min.y - origin.y) * invDirY;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (tmin <= tymax && tymin <= tmax) {\\n  \\t\\t\\t\\tif (tymin > tmin || tmin !== tmin) {\\n\\n  \\t\\t\\t\\t\\ttmin = tymin;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (tymax < tmax || tmax !== tmax) {\\n\\n  \\t\\t\\t\\t\\ttmax = tymax;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (invDirZ >= 0.0) {\\n\\n  \\t\\t\\t\\t\\ttzmin = (min.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t\\ttzmax = (max.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\ttzmin = (max.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t\\ttzmax = (min.z - origin.z) * invDirZ;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (tmin <= tzmax && tzmin <= tmax) {\\n\\n  \\t\\t\\t\\t\\tif (tzmin > tmin || tmin !== tmin) {\\n\\n  \\t\\t\\t\\t\\t\\ttmin = tzmin;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tif (tzmax < tmax || tmax !== tmax) {\\n\\n  \\t\\t\\t\\t\\t\\ttmax = tzmax;\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tif (tmax >= 0.0) {\\n\\n  \\t\\t\\t\\t\\t\\tresult = this.at(tmin >= 0.0 ? tmin : tmax, target);\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectsBox\",\\n  \\t\\tvalue: function intersectsBox(b) {\\n\\n  \\t\\t\\treturn this.intersectBox(b, v$3[0]) !== null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersectTriangle\",\\n  \\t\\tvalue: function intersectTriangle(a, b, c, backfaceCulling, target) {\\n\\n  \\t\\t\\tvar direction = this.direction;\\n\\n  \\t\\t\\tvar diff = v$3[0];\\n  \\t\\t\\tvar edge1 = v$3[1];\\n  \\t\\t\\tvar edge2 = v$3[2];\\n  \\t\\t\\tvar normal = v$3[3];\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar DdN = void 0,\\n  \\t\\t\\t    sign = void 0,\\n  \\t\\t\\t    DdQxE2 = void 0,\\n  \\t\\t\\t    DdE1xQ = void 0,\\n  \\t\\t\\t    QdN = void 0;\\n\\n  \\t\\t\\tedge1.subVectors(b, a);\\n  \\t\\t\\tedge2.subVectors(c, a);\\n  \\t\\t\\tnormal.crossVectors(edge1, edge2);\\n\\n  \\t\\t\\tDdN = direction.dot(normal);\\n\\n  \\t\\t\\tif (DdN !== 0.0 && !(backfaceCulling && DdN > 0.0)) {\\n\\n  \\t\\t\\t\\tif (DdN > 0.0) {\\n\\n  \\t\\t\\t\\t\\tsign = 1.0;\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tsign = -1.0;\\n  \\t\\t\\t\\t\\tDdN = -DdN;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tdiff.subVectors(this.origin, a);\\n  \\t\\t\\t\\tDdQxE2 = sign * direction.dot(edge2.crossVectors(diff, edge2));\\n\\n  \\t\\t\\t\\tif (DdQxE2 >= 0.0) {\\n\\n  \\t\\t\\t\\t\\tDdE1xQ = sign * direction.dot(edge1.cross(diff));\\n\\n  \\t\\t\\t\\t\\tif (DdE1xQ >= 0.0 && DdQxE2 + DdE1xQ <= DdN) {\\n  \\t\\t\\t\\t\\t\\tQdN = -sign * diff.dot(normal);\\n\\n  \\t\\t\\t\\t\\t\\tif (QdN >= 0.0) {\\n  \\t\\t\\t\\t\\t\\t\\tresult = this.at(QdN / DdN, target);\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"applyMatrix4\",\\n  \\t\\tvalue: function applyMatrix4(m) {\\n\\n  \\t\\t\\tthis.origin.applyMatrix4(m);\\n  \\t\\t\\tthis.direction.transformDirection(m);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(r) {\\n\\n  \\t\\t\\treturn r.origin.equals(this.origin) && r.direction.equals(this.direction);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Ray;\\n  }();\\n\\n  var Spherical = function () {\\n  \\tfunction Spherical() {\\n  \\t\\tvar radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n  \\t\\tvar phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar theta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tclassCallCheck(this, Spherical);\\n\\n\\n  \\t\\tthis.radius = radius;\\n\\n  \\t\\tthis.phi = phi;\\n\\n  \\t\\tthis.theta = theta;\\n  \\t}\\n\\n  \\tcreateClass(Spherical, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(radius, phi, theta) {\\n\\n  \\t\\t\\tthis.radius = radius;\\n  \\t\\t\\tthis.phi = phi;\\n  \\t\\t\\tthis.theta = theta;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(s) {\\n\\n  \\t\\t\\tthis.radius = s.radius;\\n  \\t\\t\\tthis.phi = s.phi;\\n  \\t\\t\\tthis.theta = s.theta;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setFromVector3\",\\n  \\t\\tvalue: function setFromVector3(v) {\\n\\n  \\t\\t\\tthis.radius = v.length();\\n\\n  \\t\\t\\tif (this.radius === 0) {\\n\\n  \\t\\t\\t\\tthis.theta = 0;\\n  \\t\\t\\t\\tthis.phi = 0;\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\tthis.theta = Math.atan2(v.x, v.z);\\n\\n  \\t\\t\\t\\tthis.phi = Math.acos(Math.min(Math.max(v.y / this.radius, -1), 1));\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this.makeSafe();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"makeSafe\",\\n  \\t\\tvalue: function makeSafe() {\\n\\n  \\t\\t\\tthis.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Spherical;\\n  }();\\n\\n  var SymmetricMatrix3 = function () {\\n  \\tfunction SymmetricMatrix3() {\\n  \\t\\tclassCallCheck(this, SymmetricMatrix3);\\n\\n\\n  \\t\\tthis.elements = new Float32Array([1, 0, 0, 1, 0, 1]);\\n  \\t}\\n\\n  \\tcreateClass(SymmetricMatrix3, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(m00, m01, m02, m11, m12, m22) {\\n\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\te[0] = m00;\\n  \\t\\t\\te[1] = m01;e[3] = m11;\\n  \\t\\t\\te[2] = m02;e[4] = m12;e[5] = m22;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"identity\",\\n  \\t\\tvalue: function identity() {\\n\\n  \\t\\t\\tthis.set(1, 0, 0, 1, 0, 1);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(m) {\\n\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tthis.set(me[0], me[1], me[2], me[3], me[4], me[5]);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toMatrix3\",\\n  \\t\\tvalue: function toMatrix3(m) {\\n\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tm.set(me[0], me[1], me[2], me[1], me[3], me[4], me[2], me[4], me[5]);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"add\",\\n  \\t\\tvalue: function add(m) {\\n\\n  \\t\\t\\tvar te = this.elements;\\n  \\t\\t\\tvar me = m.elements;\\n\\n  \\t\\t\\tte[0] += me[0];\\n  \\t\\t\\tte[1] += me[1];te[3] += me[3];\\n  \\t\\t\\tte[2] += me[2];te[4] += me[4];te[5] += me[5];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"norm\",\\n  \\t\\tvalue: function norm() {\\n\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\tvar m01m01 = e[1] * e[1];\\n  \\t\\t\\tvar m02m02 = e[2] * e[2];\\n  \\t\\t\\tvar m12m12 = e[4] * e[4];\\n\\n  \\t\\t\\treturn Math.sqrt(e[0] * e[0] + m01m01 + m02m02 + m01m01 + e[3] * e[3] + m12m12 + m02m02 + m12m12 + e[5] * e[5]);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"off\",\\n  \\t\\tvalue: function off() {\\n\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\treturn Math.sqrt(2 * (e[1] * e[1] + e[2] * e[2] + e[4] * e[4]));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"applyToVector3\",\\n  \\t\\tvalue: function applyToVector3(v) {\\n\\n  \\t\\t\\tvar x = v.x,\\n  \\t\\t\\t    y = v.y,\\n  \\t\\t\\t    z = v.z;\\n  \\t\\t\\tvar e = this.elements;\\n\\n  \\t\\t\\tv.x = e[0] * x + e[1] * y + e[2] * z;\\n  \\t\\t\\tv.y = e[1] * x + e[3] * y + e[4] * z;\\n  \\t\\t\\tv.z = e[2] * x + e[4] * y + e[5] * z;\\n\\n  \\t\\t\\treturn v;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(matrix) {\\n\\n  \\t\\t\\tvar te = this.elements;\\n  \\t\\t\\tvar me = matrix.elements;\\n\\n  \\t\\t\\tvar result = true;\\n  \\t\\t\\tvar i = void 0;\\n\\n  \\t\\t\\tfor (i = 0; result && i < 6; ++i) {\\n\\n  \\t\\t\\t\\tif (te[i] !== me[i]) {\\n\\n  \\t\\t\\t\\t\\tresult = false;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: \"calculateIndex\",\\n  \\t\\tvalue: function calculateIndex(i, j) {\\n\\n  \\t\\t\\treturn 3 - (3 - i) * (2 - i) / 2 + j;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn SymmetricMatrix3;\\n  }();\\n\\n  var Vector4 = function () {\\n  \\tfunction Vector4() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  \\t\\tvar w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\\n  \\t\\tclassCallCheck(this, Vector4);\\n\\n\\n  \\t\\tthis.x = x;\\n\\n  \\t\\tthis.y = y;\\n\\n  \\t\\tthis.z = z;\\n\\n  \\t\\tthis.w = w;\\n  \\t}\\n\\n  \\tcreateClass(Vector4, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(x, y, z, w) {\\n\\n  \\t\\t\\tthis.x = x;\\n  \\t\\t\\tthis.y = y;\\n  \\t\\t\\tthis.z = z;\\n  \\t\\t\\tthis.w = w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"copy\",\\n  \\t\\tvalue: function copy(v) {\\n\\n  \\t\\t\\tthis.x = v.x;\\n  \\t\\t\\tthis.y = v.y;\\n  \\t\\t\\tthis.z = v.z;\\n  \\t\\t\\tthis.w = v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clone\",\\n  \\t\\tvalue: function clone() {\\n\\n  \\t\\t\\treturn new this.constructor(this.x, this.y, this.z, this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"fromArray\",\\n  \\t\\tvalue: function fromArray(array) {\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tthis.x = array[offset];\\n  \\t\\t\\tthis.y = array[offset + 1];\\n  \\t\\t\\tthis.z = array[offset + 2];\\n  \\t\\t\\tthis.w = array[offset + 3];\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toArray\",\\n  \\t\\tvalue: function toArray$$1() {\\n  \\t\\t\\tvar array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n  \\t\\t\\tvar offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n\\n  \\t\\t\\tarray[offset] = this.x;\\n  \\t\\t\\tarray[offset + 1] = this.y;\\n  \\t\\t\\tarray[offset + 2] = this.z;\\n  \\t\\t\\tarray[offset + 3] = this.w;\\n\\n  \\t\\t\\treturn array;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setAxisAngleFromQuaternion\",\\n  \\t\\tvalue: function setAxisAngleFromQuaternion(q) {\\n\\n  \\t\\t\\tthis.w = 2 * Math.acos(q.w);\\n\\n  \\t\\t\\tvar s = Math.sqrt(1 - q.w * q.w);\\n\\n  \\t\\t\\tif (s < 1e-4) {\\n\\n  \\t\\t\\t\\tthis.x = 1;\\n  \\t\\t\\t\\tthis.y = 0;\\n  \\t\\t\\t\\tthis.z = 0;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tthis.x = q.x / s;\\n  \\t\\t\\t\\tthis.y = q.y / s;\\n  \\t\\t\\t\\tthis.z = q.z / s;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setAxisAngleFromRotationMatrix\",\\n  \\t\\tvalue: function setAxisAngleFromRotationMatrix(m) {\\n  \\t\\t\\tvar E = 0.01;\\n\\n  \\t\\t\\tvar H = 0.1;\\n\\n  \\t\\t\\tvar me = m.elements;\\n  \\t\\t\\tvar m00 = me[0],\\n  \\t\\t\\t    m01 = me[4],\\n  \\t\\t\\t    m02 = me[8];\\n  \\t\\t\\tvar m10 = me[1],\\n  \\t\\t\\t    m11 = me[5],\\n  \\t\\t\\t    m12 = me[9];\\n  \\t\\t\\tvar m20 = me[2],\\n  \\t\\t\\t    m21 = me[6],\\n  \\t\\t\\t    m22 = me[10];\\n\\n  \\t\\t\\tvar angle = void 0;\\n  \\t\\t\\tvar x = void 0,\\n  \\t\\t\\t    y = void 0,\\n  \\t\\t\\t    z = void 0;\\n  \\t\\t\\tvar xx = void 0,\\n  \\t\\t\\t    yy = void 0,\\n  \\t\\t\\t    zz = void 0;\\n  \\t\\t\\tvar xy = void 0,\\n  \\t\\t\\t    xz = void 0,\\n  \\t\\t\\t    yz = void 0;\\n  \\t\\t\\tvar s = void 0;\\n\\n  \\t\\t\\tif (Math.abs(m01 - m10) < E && Math.abs(m02 - m20) < E && Math.abs(m12 - m21) < E) {\\n  \\t\\t\\t\\tif (Math.abs(m01 + m10) < H && Math.abs(m02 + m20) < H && Math.abs(m12 + m21) < H && Math.abs(m00 + m11 + m22 - 3) < H) {\\n  \\t\\t\\t\\t\\tthis.set(1, 0, 0, 0);\\n  \\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\tangle = Math.PI;\\n\\n  \\t\\t\\t\\t\\txx = (m00 + 1) / 2;\\n  \\t\\t\\t\\t\\tyy = (m11 + 1) / 2;\\n  \\t\\t\\t\\t\\tzz = (m22 + 1) / 2;\\n  \\t\\t\\t\\t\\txy = (m01 + m10) / 4;\\n  \\t\\t\\t\\t\\txz = (m02 + m20) / 4;\\n  \\t\\t\\t\\t\\tyz = (m12 + m21) / 4;\\n\\n  \\t\\t\\t\\t\\tif (xx > yy && xx > zz) {\\n  \\t\\t\\t\\t\\t\\tif (xx < E) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = 0;\\n  \\t\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = Math.sqrt(xx);\\n  \\t\\t\\t\\t\\t\\t\\ty = xy / x;\\n  \\t\\t\\t\\t\\t\\t\\tz = xz / x;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else if (yy > zz) {\\n  \\t\\t\\t\\t\\t\\tif (yy < E) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\ty = 0;\\n  \\t\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\ty = Math.sqrt(yy);\\n  \\t\\t\\t\\t\\t\\t\\tx = xy / y;\\n  \\t\\t\\t\\t\\t\\t\\tz = yz / y;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\tif (zz < E) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n  \\t\\t\\t\\t\\t\\t\\tz = 0;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\tz = Math.sqrt(zz);\\n  \\t\\t\\t\\t\\t\\t\\tx = xz / z;\\n  \\t\\t\\t\\t\\t\\t\\ty = yz / z;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tthis.set(x, y, z, angle);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\ts = Math.sqrt((m21 - m12) * (m21 - m12) + (m02 - m20) * (m02 - m20) + (m10 - m01) * (m10 - m01));\\n\\n  \\t\\t\\t\\tif (Math.abs(s) < 0.001) {\\n\\n  \\t\\t\\t\\t\\ts = 1;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tthis.x = (m21 - m12) / s;\\n  \\t\\t\\t\\tthis.y = (m02 - m20) / s;\\n  \\t\\t\\t\\tthis.z = (m10 - m01) / s;\\n  \\t\\t\\t\\tthis.w = Math.acos((m00 + m11 + m22 - 1) / 2);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"add\",\\n  \\t\\tvalue: function add(v) {\\n\\n  \\t\\t\\tthis.x += v.x;\\n  \\t\\t\\tthis.y += v.y;\\n  \\t\\t\\tthis.z += v.z;\\n  \\t\\t\\tthis.w += v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addScalar\",\\n  \\t\\tvalue: function addScalar(s) {\\n\\n  \\t\\t\\tthis.x += s;\\n  \\t\\t\\tthis.y += s;\\n  \\t\\t\\tthis.z += s;\\n  \\t\\t\\tthis.w += s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addVectors\",\\n  \\t\\tvalue: function addVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x + b.x;\\n  \\t\\t\\tthis.y = a.y + b.y;\\n  \\t\\t\\tthis.z = a.z + b.z;\\n  \\t\\t\\tthis.w = a.w + b.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"addScaledVector\",\\n  \\t\\tvalue: function addScaledVector(v, s) {\\n\\n  \\t\\t\\tthis.x += v.x * s;\\n  \\t\\t\\tthis.y += v.y * s;\\n  \\t\\t\\tthis.z += v.z * s;\\n  \\t\\t\\tthis.w += v.w * s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"sub\",\\n  \\t\\tvalue: function sub(v) {\\n\\n  \\t\\t\\tthis.x -= v.x;\\n  \\t\\t\\tthis.y -= v.y;\\n  \\t\\t\\tthis.z -= v.z;\\n  \\t\\t\\tthis.w -= v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"subScalar\",\\n  \\t\\tvalue: function subScalar(s) {\\n\\n  \\t\\t\\tthis.x -= s;\\n  \\t\\t\\tthis.y -= s;\\n  \\t\\t\\tthis.z -= s;\\n  \\t\\t\\tthis.w -= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"subVectors\",\\n  \\t\\tvalue: function subVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x - b.x;\\n  \\t\\t\\tthis.y = a.y - b.y;\\n  \\t\\t\\tthis.z = a.z - b.z;\\n  \\t\\t\\tthis.w = a.w - b.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiply\",\\n  \\t\\tvalue: function multiply(v) {\\n\\n  \\t\\t\\tthis.x *= v.x;\\n  \\t\\t\\tthis.y *= v.y;\\n  \\t\\t\\tthis.z *= v.z;\\n  \\t\\t\\tthis.w *= v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiplyScalar\",\\n  \\t\\tvalue: function multiplyScalar(s) {\\n\\n  \\t\\t\\tthis.x *= s;\\n  \\t\\t\\tthis.y *= s;\\n  \\t\\t\\tthis.z *= s;\\n  \\t\\t\\tthis.w *= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"multiplyVectors\",\\n  \\t\\tvalue: function multiplyVectors(a, b) {\\n\\n  \\t\\t\\tthis.x = a.x * b.x;\\n  \\t\\t\\tthis.y = a.y * b.y;\\n  \\t\\t\\tthis.z = a.z * b.z;\\n  \\t\\t\\tthis.w = a.w * b.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"divide\",\\n  \\t\\tvalue: function divide(v) {\\n\\n  \\t\\t\\tthis.x /= v.x;\\n  \\t\\t\\tthis.y /= v.y;\\n  \\t\\t\\tthis.z /= v.z;\\n  \\t\\t\\tthis.w /= v.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"divideScalar\",\\n  \\t\\tvalue: function divideScalar(s) {\\n\\n  \\t\\t\\tthis.x /= s;\\n  \\t\\t\\tthis.y /= s;\\n  \\t\\t\\tthis.z /= s;\\n  \\t\\t\\tthis.w /= s;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"applyMatrix4\",\\n  \\t\\tvalue: function applyMatrix4(m) {\\n\\n  \\t\\t\\tvar x = this.x,\\n  \\t\\t\\t    y = this.y,\\n  \\t\\t\\t    z = this.z,\\n  \\t\\t\\t    w = this.w;\\n  \\t\\t\\tvar e = m.elements;\\n\\n  \\t\\t\\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\\n  \\t\\t\\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\\n  \\t\\t\\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\\n  \\t\\t\\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"negate\",\\n  \\t\\tvalue: function negate() {\\n\\n  \\t\\t\\tthis.x = -this.x;\\n  \\t\\t\\tthis.y = -this.y;\\n  \\t\\t\\tthis.z = -this.z;\\n  \\t\\t\\tthis.w = -this.w;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"dot\",\\n  \\t\\tvalue: function dot(v) {\\n\\n  \\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"manhattanLength\",\\n  \\t\\tvalue: function manhattanLength() {\\n\\n  \\t\\t\\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lengthSquared\",\\n  \\t\\tvalue: function lengthSquared() {\\n\\n  \\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"length\",\\n  \\t\\tvalue: function length() {\\n\\n  \\t\\t\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"manhattanDistanceTo\",\\n  \\t\\tvalue: function manhattanDistanceTo(v) {\\n\\n  \\t\\t\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z) + Math.abs(this.w - v.w);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToSquared\",\\n  \\t\\tvalue: function distanceToSquared(v) {\\n\\n  \\t\\t\\tvar dx = this.x - v.x;\\n  \\t\\t\\tvar dy = this.y - v.y;\\n  \\t\\t\\tvar dz = this.z - v.z;\\n  \\t\\t\\tvar dw = this.w - v.w;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy + dz * dz + dw * dw;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceTo\",\\n  \\t\\tvalue: function distanceTo(v) {\\n\\n  \\t\\t\\treturn Math.sqrt(this.distanceToSquared(v));\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"normalize\",\\n  \\t\\tvalue: function normalize() {\\n\\n  \\t\\t\\treturn this.divideScalar(this.length());\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setLength\",\\n  \\t\\tvalue: function setLength(length) {\\n\\n  \\t\\t\\treturn this.normalize().multiplyScalar(length);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"min\",\\n  \\t\\tvalue: function min(v) {\\n\\n  \\t\\t\\tthis.x = Math.min(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.min(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.min(this.z, v.z);\\n  \\t\\t\\tthis.w = Math.min(this.w, v.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"max\",\\n  \\t\\tvalue: function max(v) {\\n\\n  \\t\\t\\tthis.x = Math.max(this.x, v.x);\\n  \\t\\t\\tthis.y = Math.max(this.y, v.y);\\n  \\t\\t\\tthis.z = Math.max(this.z, v.z);\\n  \\t\\t\\tthis.w = Math.max(this.w, v.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clamp\",\\n  \\t\\tvalue: function clamp(min, max) {\\n\\n  \\t\\t\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\n  \\t\\t\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\n  \\t\\t\\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\\n  \\t\\t\\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"floor\",\\n  \\t\\tvalue: function floor() {\\n\\n  \\t\\t\\tthis.x = Math.floor(this.x);\\n  \\t\\t\\tthis.y = Math.floor(this.y);\\n  \\t\\t\\tthis.z = Math.floor(this.z);\\n  \\t\\t\\tthis.w = Math.floor(this.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"ceil\",\\n  \\t\\tvalue: function ceil() {\\n\\n  \\t\\t\\tthis.x = Math.ceil(this.x);\\n  \\t\\t\\tthis.y = Math.ceil(this.y);\\n  \\t\\t\\tthis.z = Math.ceil(this.z);\\n  \\t\\t\\tthis.w = Math.ceil(this.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"round\",\\n  \\t\\tvalue: function round() {\\n\\n  \\t\\t\\tthis.x = Math.round(this.x);\\n  \\t\\t\\tthis.y = Math.round(this.y);\\n  \\t\\t\\tthis.z = Math.round(this.z);\\n  \\t\\t\\tthis.w = Math.round(this.w);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lerp\",\\n  \\t\\tvalue: function lerp(v, alpha) {\\n\\n  \\t\\t\\tthis.x += (v.x - this.x) * alpha;\\n  \\t\\t\\tthis.y += (v.y - this.y) * alpha;\\n  \\t\\t\\tthis.z += (v.z - this.z) * alpha;\\n  \\t\\t\\tthis.w += (v.w - this.w) * alpha;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"lerpVectors\",\\n  \\t\\tvalue: function lerpVectors(v1, v2, alpha) {\\n\\n  \\t\\t\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"equals\",\\n  \\t\\tvalue: function equals(v) {\\n\\n  \\t\\t\\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Vector4;\\n  }();\\n\\n  var IteratorResult = function () {\\n  \\tfunction IteratorResult() {\\n  \\t\\tvar value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\tvar done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n  \\t\\tclassCallCheck(this, IteratorResult);\\n\\n\\n  \\t\\tthis.value = value;\\n\\n  \\t\\tthis.done = done;\\n  \\t}\\n\\n  \\tcreateClass(IteratorResult, [{\\n  \\t\\tkey: \"reset\",\\n  \\t\\tvalue: function reset() {\\n\\n  \\t\\t\\tthis.value = null;\\n  \\t\\t\\tthis.done = false;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn IteratorResult;\\n  }();\\n\\n  var c$2 = new Vector3();\\n\\n  var Octant = function () {\\n  \\tfunction Octant() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\tclassCallCheck(this, Octant);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.max = max;\\n\\n  \\t\\tthis.children = null;\\n  \\t}\\n\\n  \\tcreateClass(Octant, [{\\n  \\t\\tkey: \"getCenter\",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.addVectors(this.min, this.max).multiplyScalar(0.5);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getDimensions\",\\n  \\t\\tvalue: function getDimensions() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.subVectors(this.max, this.min);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"split\",\\n  \\t\\tvalue: function split() {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n  \\t\\t\\tvar mid = this.getCenter(c$2);\\n\\n  \\t\\t\\tvar children = this.children = [null, null, null, null, null, null, null, null];\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    combination = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\tcombination = pattern[i];\\n\\n  \\t\\t\\t\\tchildren[i] = new this.constructor(new Vector3(combination[0] === 0 ? min.x : mid.x, combination[1] === 0 ? min.y : mid.y, combination[2] === 0 ? min.z : mid.z), new Vector3(combination[0] === 0 ? mid.x : max.x, combination[1] === 0 ? mid.y : max.y, combination[2] === 0 ? mid.z : max.z));\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Octant;\\n  }();\\n\\n  var pattern = [new Uint8Array([0, 0, 0]), new Uint8Array([0, 0, 1]), new Uint8Array([0, 1, 0]), new Uint8Array([0, 1, 1]), new Uint8Array([1, 0, 0]), new Uint8Array([1, 0, 1]), new Uint8Array([1, 1, 0]), new Uint8Array([1, 1, 1])];\\n\\n  var edges = [new Uint8Array([0, 4]), new Uint8Array([1, 5]), new Uint8Array([2, 6]), new Uint8Array([3, 7]), new Uint8Array([0, 2]), new Uint8Array([1, 3]), new Uint8Array([4, 6]), new Uint8Array([5, 7]), new Uint8Array([0, 1]), new Uint8Array([2, 3]), new Uint8Array([4, 5]), new Uint8Array([6, 7])];\\n\\n  var c$1 = new Vector3();\\n\\n  var CubicOctant = function () {\\n  \\tfunction CubicOctant() {\\n  \\t\\tvar min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\tvar size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  \\t\\tclassCallCheck(this, CubicOctant);\\n\\n\\n  \\t\\tthis.min = min;\\n\\n  \\t\\tthis.size = size;\\n\\n  \\t\\tthis.children = null;\\n  \\t}\\n\\n  \\tcreateClass(CubicOctant, [{\\n  \\t\\tkey: \"getCenter\",\\n  \\t\\tvalue: function getCenter() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.copy(this.min).addScalar(this.size * 0.5);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getDimensions\",\\n  \\t\\tvalue: function getDimensions() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\treturn target.set(this.size, this.size, this.size);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"split\",\\n  \\t\\tvalue: function split() {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar mid = this.getCenter(c$1);\\n  \\t\\t\\tvar halfSize = this.size * 0.5;\\n\\n  \\t\\t\\tvar children = this.children = [null, null, null, null, null, null, null, null];\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    combination = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\tcombination = pattern[i];\\n\\n  \\t\\t\\t\\tchildren[i] = new this.constructor(new Vector3(combination[0] === 0 ? min.x : mid.x, combination[1] === 0 ? min.y : mid.y, combination[2] === 0 ? min.z : mid.z), halfSize);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"max\",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.min.clone().addScalar(this.size);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn CubicOctant;\\n  }();\\n\\n  var b$4 = new Box3();\\n\\n  var OctantIterator = function () {\\n  \\t\\tfunction OctantIterator(octree) {\\n  \\t\\t\\t\\tvar region = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n  \\t\\t\\t\\tclassCallCheck(this, OctantIterator);\\n\\n\\n  \\t\\t\\t\\tthis.octree = octree;\\n\\n  \\t\\t\\t\\tthis.region = region;\\n\\n  \\t\\t\\t\\tthis.cull = region !== null;\\n\\n  \\t\\t\\t\\tthis.result = new IteratorResult();\\n\\n  \\t\\t\\t\\tthis.trace = null;\\n\\n  \\t\\t\\t\\tthis.indices = null;\\n\\n  \\t\\t\\t\\tthis.reset();\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(OctantIterator, [{\\n  \\t\\t\\t\\tkey: \"reset\",\\n  \\t\\t\\t\\tvalue: function reset() {\\n\\n  \\t\\t\\t\\t\\t\\tvar root = this.octree.root;\\n\\n  \\t\\t\\t\\t\\t\\tthis.trace = [];\\n  \\t\\t\\t\\t\\t\\tthis.indices = [];\\n\\n  \\t\\t\\t\\t\\t\\tif (root !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tb$4.min = root.min;\\n  \\t\\t\\t\\t\\t\\t\\t\\tb$4.max = root.max;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (!this.cull || this.region.intersectsBox(b$4)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.trace.push(root);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis.indices.push(0);\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.reset();\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"next\",\\n  \\t\\t\\t\\tvalue: function next() {\\n\\n  \\t\\t\\t\\t\\t\\tvar cull = this.cull;\\n  \\t\\t\\t\\t\\t\\tvar region = this.region;\\n  \\t\\t\\t\\t\\t\\tvar indices = this.indices;\\n  \\t\\t\\t\\t\\t\\tvar trace = this.trace;\\n\\n  \\t\\t\\t\\t\\t\\tvar octant = null;\\n  \\t\\t\\t\\t\\t\\tvar depth = trace.length - 1;\\n\\n  \\t\\t\\t\\t\\t\\tvar index = void 0,\\n  \\t\\t\\t\\t\\t\\t    children = void 0,\\n  \\t\\t\\t\\t\\t\\t    child = void 0;\\n\\n  \\t\\t\\t\\t\\t\\twhile (octant === null && depth >= 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tindex = indices[depth];\\n  \\t\\t\\t\\t\\t\\t\\t\\tchildren = trace[depth].children;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t++indices[depth];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (index < 8) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tchild = children[index];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (cull) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb$4.min = child.min;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb$4.max = child.max;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (!region.intersectsBox(b$4)) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcontinue;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttrace.push(child);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.push(0);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++depth;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toctant = trace.pop();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.pop();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttrace.pop();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.pop();\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t--depth;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.value = octant;\\n  \\t\\t\\t\\t\\t\\tthis.result.done = octant === null;\\n\\n  \\t\\t\\t\\t\\t\\treturn this.result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"return\",\\n  \\t\\t\\t\\tvalue: function _return(value) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.value = value;\\n  \\t\\t\\t\\t\\t\\tthis.result.done = true;\\n\\n  \\t\\t\\t\\t\\t\\treturn this.result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: Symbol.iterator,\\n  \\t\\t\\t\\tvalue: function value() {\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn OctantIterator;\\n  }();\\n\\n  var v$4 = [new Vector3(), new Vector3(), new Vector3()];\\n\\n  var b$5 = new Box3();\\n\\n  var r = new Ray();\\n\\n  var octantTable = [new Uint8Array([4, 2, 1]), new Uint8Array([5, 3, 8]), new Uint8Array([6, 8, 3]), new Uint8Array([7, 8, 8]), new Uint8Array([8, 6, 5]), new Uint8Array([8, 7, 8]), new Uint8Array([8, 8, 7]), new Uint8Array([8, 8, 8])];\\n\\n  var flags = 0;\\n\\n  function findEntryOctant(tx0, ty0, tz0, txm, tym, tzm) {\\n\\n  \\tvar entry = 0;\\n\\n  \\tif (tx0 > ty0 && tx0 > tz0) {\\n  \\t\\tif (tym < tx0) {\\n  \\t\\t\\tentry |= 2;\\n  \\t\\t}\\n  \\t\\tif (tzm < tx0) {\\n  \\t\\t\\tentry |= 1;\\n  \\t\\t}\\n  \\t} else if (ty0 > tz0) {\\n  \\t\\tif (txm < ty0) {\\n  \\t\\t\\tentry |= 4;\\n  \\t\\t}\\n  \\t\\tif (tzm < ty0) {\\n  \\t\\t\\tentry |= 1;\\n  \\t\\t}\\n  \\t} else {\\n  \\t\\tif (txm < tz0) {\\n  \\t\\t\\tentry |= 4;\\n  \\t\\t}\\n  \\t\\tif (tym < tz0) {\\n  \\t\\t\\tentry |= 2;\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn entry;\\n  }\\n\\n  function findNextOctant(currentOctant, tx1, ty1, tz1) {\\n\\n  \\tvar min = void 0;\\n  \\tvar exit = 0;\\n\\n  \\tif (tx1 < ty1) {\\n\\n  \\t\\tmin = tx1;\\n  \\t\\texit = 0;\\n  \\t} else {\\n\\n  \\t\\tmin = ty1;\\n  \\t\\texit = 1;\\n  \\t}\\n\\n  \\tif (tz1 < min) {\\n\\n  \\t\\texit = 2;\\n  \\t}\\n\\n  \\treturn octantTable[currentOctant][exit];\\n  }\\n\\n  function raycastOctant(octant, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar currentOctant = void 0;\\n  \\tvar txm = void 0,\\n  \\t    tym = void 0,\\n  \\t    tzm = void 0;\\n\\n  \\tif (tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {\\n\\n  \\t\\tif (children === null) {\\n  \\t\\t\\tintersects.push(octant);\\n  \\t\\t} else {\\n  \\t\\t\\ttxm = 0.5 * (tx0 + tx1);\\n  \\t\\t\\ttym = 0.5 * (ty0 + ty1);\\n  \\t\\t\\ttzm = 0.5 * (tz0 + tz1);\\n\\n  \\t\\t\\tcurrentOctant = findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);\\n\\n  \\t\\t\\tdo {\\n\\n  \\t\\t\\t\\tswitch (currentOctant) {\\n\\n  \\t\\t\\t\\t\\tcase 0:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags], tx0, ty0, tz0, txm, tym, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 1:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, tym, tz1);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 2:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 3:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, txm, ty1, tz1);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 4:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 5:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, tx1, tym, tz1);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 6:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, raycaster, intersects);\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = findNextOctant(currentOctant, tx1, ty1, tzm);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase 7:\\n  \\t\\t\\t\\t\\t\\traycastOctant(children[flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, raycaster, intersects);\\n\\n  \\t\\t\\t\\t\\t\\tcurrentOctant = 8;\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} while (currentOctant < 8);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  var OctreeRaycaster = function () {\\n  \\tfunction OctreeRaycaster() {\\n  \\t\\tclassCallCheck(this, OctreeRaycaster);\\n  \\t}\\n\\n  \\tcreateClass(OctreeRaycaster, null, [{\\n  \\t\\tkey: \"intersectOctree\",\\n  \\t\\tvalue: function intersectOctree(octree, raycaster, intersects) {\\n  \\t\\t\\tvar min = b$5.min.set(0, 0, 0);\\n  \\t\\t\\tvar max = b$5.max.subVectors(octree.max, octree.min);\\n\\n  \\t\\t\\tvar dimensions = octree.getDimensions(v$4[0]);\\n  \\t\\t\\tvar halfDimensions = v$4[1].copy(dimensions).multiplyScalar(0.5);\\n\\n  \\t\\t\\tvar origin = r.origin.copy(raycaster.ray.origin);\\n  \\t\\t\\tvar direction = r.direction.copy(raycaster.ray.direction);\\n\\n  \\t\\t\\tvar invDirX = void 0,\\n  \\t\\t\\t    invDirY = void 0,\\n  \\t\\t\\t    invDirZ = void 0;\\n  \\t\\t\\tvar tx0 = void 0,\\n  \\t\\t\\t    tx1 = void 0,\\n  \\t\\t\\t    ty0 = void 0,\\n  \\t\\t\\t    ty1 = void 0,\\n  \\t\\t\\t    tz0 = void 0,\\n  \\t\\t\\t    tz1 = void 0;\\n\\n  \\t\\t\\torigin.sub(octree.getCenter(v$4[2])).add(halfDimensions);\\n\\n  \\t\\t\\tflags = 0;\\n\\n  \\t\\t\\tif (direction.x < 0.0) {\\n\\n  \\t\\t\\t\\torigin.x = dimensions.x - origin.x;\\n  \\t\\t\\t\\tdirection.x = -direction.x;\\n  \\t\\t\\t\\tflags |= 4;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (direction.y < 0.0) {\\n\\n  \\t\\t\\t\\torigin.y = dimensions.y - origin.y;\\n  \\t\\t\\t\\tdirection.y = -direction.y;\\n  \\t\\t\\t\\tflags |= 2;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (direction.z < 0.0) {\\n\\n  \\t\\t\\t\\torigin.z = dimensions.z - origin.z;\\n  \\t\\t\\t\\tdirection.z = -direction.z;\\n  \\t\\t\\t\\tflags |= 1;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tinvDirX = 1.0 / direction.x;\\n  \\t\\t\\tinvDirY = 1.0 / direction.y;\\n  \\t\\t\\tinvDirZ = 1.0 / direction.z;\\n\\n  \\t\\t\\ttx0 = (min.x - origin.x) * invDirX;\\n  \\t\\t\\ttx1 = (max.x - origin.x) * invDirX;\\n  \\t\\t\\tty0 = (min.y - origin.y) * invDirY;\\n  \\t\\t\\tty1 = (max.y - origin.y) * invDirY;\\n  \\t\\t\\ttz0 = (min.z - origin.z) * invDirZ;\\n  \\t\\t\\ttz1 = (max.z - origin.z) * invDirZ;\\n\\n  \\t\\t\\tif (Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {\\n  \\t\\t\\t\\traycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, raycaster, intersects);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn OctreeRaycaster;\\n  }();\\n\\n  var b$3 = new Box3();\\n\\n  function _getDepth(octant) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = 0;\\n  \\tvar i = void 0,\\n  \\t    l = void 0,\\n  \\t    d = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\td = 1 + _getDepth(children[i]);\\n\\n  \\t\\t\\tif (d > result) {\\n\\n  \\t\\t\\t\\tresult = d;\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _cull(octant, region, result) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tb$3.min = octant.min;\\n  \\tb$3.max = octant.max;\\n\\n  \\tif (region.intersectsBox(b$3)) {\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t_cull(children[i], region, result);\\n  \\t\\t\\t}\\n  \\t\\t} else {\\n\\n  \\t\\t\\tresult.push(octant);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function _findOctantsByLevel(octant, level, depth, result) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (depth === level) {\\n\\n  \\t\\tresult.push(octant);\\n  \\t} else if (children !== null) {\\n\\n  \\t\\t++depth;\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t_findOctantsByLevel(children[i], level, depth, result);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  var Octree = function () {\\n  \\tfunction Octree(min, max) {\\n  \\t\\tclassCallCheck(this, Octree);\\n\\n\\n  \\t\\tthis.root = min !== undefined && max !== undefined ? new Octant(min, max) : null;\\n  \\t}\\n\\n  \\tcreateClass(Octree, [{\\n  \\t\\tkey: \"getCenter\",\\n  \\t\\tvalue: function getCenter(target) {\\n  \\t\\t\\treturn this.root.getCenter(target);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getDimensions\",\\n  \\t\\tvalue: function getDimensions(target) {\\n  \\t\\t\\treturn this.root.getDimensions(target);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"getDepth\",\\n  \\t\\tvalue: function getDepth() {\\n  \\t\\t\\treturn _getDepth(this.root);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"cull\",\\n  \\t\\tvalue: function cull(region) {\\n\\n  \\t\\t\\tvar result = [];\\n\\n  \\t\\t\\t_cull(this.root, region, result);\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"findOctantsByLevel\",\\n  \\t\\tvalue: function findOctantsByLevel(level) {\\n\\n  \\t\\t\\tvar result = [];\\n\\n  \\t\\t\\t_findOctantsByLevel(this.root, level, 0, result);\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"raycast\",\\n  \\t\\tvalue: function raycast(raycaster) {\\n  \\t\\t\\tvar intersects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n\\n\\n  \\t\\t\\tOctreeRaycaster.intersectOctree(this, raycaster, intersects);\\n\\n  \\t\\t\\treturn intersects;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"leaves\",\\n  \\t\\tvalue: function leaves(region) {\\n\\n  \\t\\t\\treturn new OctantIterator(this, region);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: Symbol.iterator,\\n  \\t\\tvalue: function value() {\\n\\n  \\t\\t\\treturn new OctantIterator(this);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"min\",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.root.min;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"max\",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.root.max;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"children\",\\n  \\t\\tget: function get$$1() {\\n  \\t\\t\\treturn this.root.children;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Octree;\\n  }();\\n\\n  var p = new Vector3();\\n\\n  var PointOctant = function (_Octant) {\\n  \\tinherits(PointOctant, _Octant);\\n\\n  \\tfunction PointOctant(min, max) {\\n  \\t\\tclassCallCheck(this, PointOctant);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (PointOctant.__proto__ || Object.getPrototypeOf(PointOctant)).call(this, min, max));\\n\\n  \\t\\t_this.points = null;\\n\\n  \\t\\t_this.data = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(PointOctant, [{\\n  \\t\\tkey: \"distanceToSquared\",\\n  \\t\\tvalue: function distanceToSquared(point) {\\n\\n  \\t\\t\\tvar clampedPoint = p.copy(point).clamp(this.min, this.max);\\n\\n  \\t\\t\\treturn clampedPoint.sub(point).lengthSquared();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"distanceToCenterSquared\",\\n  \\t\\tvalue: function distanceToCenterSquared(point) {\\n\\n  \\t\\t\\tvar center = this.getCenter(p);\\n\\n  \\t\\t\\tvar dx = point.x - center.x;\\n  \\t\\t\\tvar dy = point.y - center.x;\\n  \\t\\t\\tvar dz = point.z - center.z;\\n\\n  \\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"contains\",\\n  \\t\\tvalue: function contains(point, bias) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar max = this.max;\\n\\n  \\t\\t\\treturn point.x >= min.x - bias && point.y >= min.y - bias && point.z >= min.z - bias && point.x <= max.x + bias && point.y <= max.y + bias && point.z <= max.z + bias;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"redistribute\",\\n  \\t\\tvalue: function redistribute(bias) {\\n\\n  \\t\\t\\tvar children = this.children;\\n  \\t\\t\\tvar points = this.points;\\n  \\t\\t\\tvar data = this.data;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    j = void 0,\\n  \\t\\t\\t    il = void 0,\\n  \\t\\t\\t    jl = void 0;\\n  \\t\\t\\tvar child = void 0,\\n  \\t\\t\\t    point = void 0,\\n  \\t\\t\\t    entry = void 0;\\n\\n  \\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\tfor (i = 0, il = points.length; i < il; ++i) {\\n\\n  \\t\\t\\t\\t\\tpoint = points[i];\\n  \\t\\t\\t\\t\\tentry = data[i];\\n\\n  \\t\\t\\t\\t\\tfor (j = 0, jl = children.length; j < jl; ++j) {\\n\\n  \\t\\t\\t\\t\\t\\tchild = children[j];\\n\\n  \\t\\t\\t\\t\\t\\tif (child.contains(point, bias)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tif (child.points === null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tchild.points = [];\\n  \\t\\t\\t\\t\\t\\t\\t\\tchild.data = [];\\n  \\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\tchild.points.push(point);\\n  \\t\\t\\t\\t\\t\\t\\tchild.data.push(entry);\\n\\n  \\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.points = null;\\n  \\t\\t\\tthis.data = null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"merge\",\\n  \\t\\tvalue: function merge() {\\n\\n  \\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n  \\t\\t\\tvar child = void 0;\\n\\n  \\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\tthis.points = [];\\n  \\t\\t\\t\\tthis.data = [];\\n\\n  \\t\\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\t\\t\\tif (child.points !== null) {\\n  \\t\\t\\t\\t\\t\\tvar _points, _data;\\n\\n  \\t\\t\\t\\t\\t\\t(_points = this.points).push.apply(_points, toConsumableArray(child.points));\\n  \\t\\t\\t\\t\\t\\t(_data = this.data).push.apply(_data, toConsumableArray(child.data));\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tthis.children = null;\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn PointOctant;\\n  }(Octant);\\n\\n  var RayPointIntersection = function RayPointIntersection(distance, distanceToRay, point) {\\n  \\t\\tvar object = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\\n  \\t\\tclassCallCheck(this, RayPointIntersection);\\n\\n\\n  \\t\\tthis.distance = distance;\\n\\n  \\t\\tthis.distanceToRay = distanceToRay;\\n\\n  \\t\\tthis.point = point;\\n\\n  \\t\\tthis.object = object;\\n  };\\n\\n  var THRESHOLD = 1e-6;\\n\\n  function _countPoints(octant) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = 0;\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\tresult += _countPoints(children[i]);\\n  \\t\\t}\\n  \\t} else if (octant.points !== null) {\\n\\n  \\t\\tresult = octant.points.length;\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _put(point, data, octree, octant, depth) {\\n\\n  \\tvar children = octant.children;\\n  \\tvar exists = false;\\n  \\tvar done = false;\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (children === null) {\\n\\n  \\t\\t\\tif (octant.points === null) {\\n\\n  \\t\\t\\t\\toctant.points = [];\\n  \\t\\t\\t\\toctant.data = [];\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tfor (i = 0, l = octant.points.length; !exists && i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\texists = octant.points[i].equals(point);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (exists) {\\n\\n  \\t\\t\\t\\toctant.data[i - 1] = data;\\n  \\t\\t\\t\\tdone = true;\\n  \\t\\t\\t} else if (octant.points.length < octree.maxPoints || depth === octree.maxDepth) {\\n\\n  \\t\\t\\t\\toctant.points.push(point.clone());\\n  \\t\\t\\t\\toctant.data.push(data);\\n  \\t\\t\\t\\t++octree.pointCount;\\n  \\t\\t\\t\\tdone = true;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\toctant.split();\\n  \\t\\t\\t\\toctant.redistribute(octree.bias);\\n  \\t\\t\\t\\tchildren = octant.children;\\n  \\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\t++depth;\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; !done && i < l; ++i) {\\n\\n  \\t\\t\\t\\tdone = _put(point, data, octree, children[i], depth);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn done;\\n  }\\n\\n  function _remove(point, octree, octant, parent) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar points = void 0,\\n  \\t    data = void 0,\\n  \\t    last = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\tresult = _remove(point, octree, children[i], octant);\\n  \\t\\t\\t}\\n  \\t\\t} else if (octant.points !== null) {\\n\\n  \\t\\t\\tpoints = octant.points;\\n  \\t\\t\\tdata = octant.data;\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tif (points[i].equals(point)) {\\n\\n  \\t\\t\\t\\t\\tlast = l - 1;\\n  \\t\\t\\t\\t\\tresult = data[i];\\n\\n  \\t\\t\\t\\t\\tif (i < last) {\\n  \\t\\t\\t\\t\\t\\tpoints[i] = points[last];\\n  \\t\\t\\t\\t\\t\\tdata[i] = data[last];\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tpoints.pop();\\n  \\t\\t\\t\\t\\tdata.pop();\\n\\n  \\t\\t\\t\\t\\t--octree.pointCount;\\n\\n  \\t\\t\\t\\t\\tif (parent !== null && _countPoints(parent) <= octree.maxPoints) {\\n\\n  \\t\\t\\t\\t\\t\\tparent.merge();\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _fetch(point, octree, octant) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar points = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (children !== null) {\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\tresult = _fetch(point, octree, children[i]);\\n  \\t\\t\\t}\\n  \\t\\t} else {\\n\\n  \\t\\t\\tpoints = octant.points;\\n\\n  \\t\\t\\tfor (i = 0, l = points.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\tif (point.distanceToSquared(points[i]) <= THRESHOLD) {\\n\\n  \\t\\t\\t\\t\\tresult = octant.data[i];\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _move(point, position, octree, octant, parent, depth) {\\n\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar points = void 0;\\n\\n  \\tif (octant.contains(point, octree.bias)) {\\n\\n  \\t\\tif (octant.contains(position, octree.bias)) {\\n  \\t\\t\\tif (children !== null) {\\n\\n  \\t\\t\\t\\t++depth;\\n\\n  \\t\\t\\t\\tfor (i = 0, l = children.length; result === null && i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\tresult = _move(point, position, octree, children[i], octant, depth);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\tpoints = octant.points;\\n\\n  \\t\\t\\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\tif (point.distanceToSquared(points[i]) <= THRESHOLD) {\\n  \\t\\t\\t\\t\\t\\tpoints[i].copy(position);\\n  \\t\\t\\t\\t\\t\\tresult = octant.data[i];\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t} else {\\n  \\t\\t\\tresult = _remove(point, octree, octant, parent);\\n\\n  \\t\\t\\t_put(position, result, octree, parent, depth - 1);\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _findNearestPoint(point, maxDistance, skipSelf, octant) {\\n\\n  \\tvar points = octant.points;\\n  \\tvar children = octant.children;\\n\\n  \\tvar result = null;\\n  \\tvar bestDist = maxDistance;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n  \\tvar p = void 0,\\n  \\t    distSq = void 0;\\n\\n  \\tvar sortedChildren = void 0;\\n  \\tvar child = void 0,\\n  \\t    childResult = void 0;\\n\\n  \\tif (children !== null) {\\n  \\t\\tsortedChildren = children.map(function (child) {\\n  \\t\\t\\treturn {\\n  \\t\\t\\t\\toctant: child,\\n  \\t\\t\\t\\tdistance: child.distanceToCenterSquared(point)\\n  \\t\\t\\t};\\n  \\t\\t}).sort(function (a, b) {\\n  \\t\\t\\treturn a.distance - b.distance;\\n  \\t\\t});\\n\\n  \\t\\tfor (i = 0, l = sortedChildren.length; i < l; ++i) {\\n  \\t\\t\\tchild = sortedChildren[i].octant;\\n\\n  \\t\\t\\tif (child.contains(point, bestDist)) {\\n\\n  \\t\\t\\t\\tchildResult = _findNearestPoint(point, bestDist, skipSelf, child);\\n\\n  \\t\\t\\t\\tif (childResult !== null) {\\n\\n  \\t\\t\\t\\t\\tdistSq = childResult.point.distanceToSquared(point);\\n\\n  \\t\\t\\t\\t\\tif ((!skipSelf || distSq > 0.0) && distSq < bestDist) {\\n\\n  \\t\\t\\t\\t\\t\\tbestDist = distSq;\\n  \\t\\t\\t\\t\\t\\tresult = childResult;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t} else if (points !== null) {\\n\\n  \\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\tp = points[i];\\n  \\t\\t\\tdistSq = point.distanceToSquared(p);\\n\\n  \\t\\t\\tif ((!skipSelf || distSq > 0.0) && distSq < bestDist) {\\n\\n  \\t\\t\\t\\tbestDist = distSq;\\n\\n  \\t\\t\\t\\tresult = {\\n  \\t\\t\\t\\t\\tpoint: p.clone(),\\n  \\t\\t\\t\\t\\tdata: octant.data[i]\\n  \\t\\t\\t\\t};\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result;\\n  }\\n\\n  function _findPoints(point, radius, skipSelf, octant, result) {\\n\\n  \\tvar points = octant.points;\\n  \\tvar children = octant.children;\\n  \\tvar rSq = radius * radius;\\n\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tvar p = void 0,\\n  \\t    distSq = void 0;\\n  \\tvar child = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\tif (child.contains(point, radius)) {\\n\\n  \\t\\t\\t\\t_findPoints(point, radius, skipSelf, child, result);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t} else if (points !== null) {\\n\\n  \\t\\tfor (i = 0, l = points.length; i < l; ++i) {\\n\\n  \\t\\t\\tp = points[i];\\n  \\t\\t\\tdistSq = point.distanceToSquared(p);\\n\\n  \\t\\t\\tif ((!skipSelf || distSq > 0.0) && distSq <= rSq) {\\n\\n  \\t\\t\\t\\tresult.push({\\n  \\t\\t\\t\\t\\tpoint: p.clone(),\\n  \\t\\t\\t\\t\\tdata: octant.data[i]\\n  \\t\\t\\t\\t});\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  var PointOctree = function (_Octree) {\\n  \\tinherits(PointOctree, _Octree);\\n\\n  \\tfunction PointOctree(min, max) {\\n  \\t\\tvar bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;\\n  \\t\\tvar maxPoints = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\\n  \\t\\tvar maxDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 8;\\n  \\t\\tclassCallCheck(this, PointOctree);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (PointOctree.__proto__ || Object.getPrototypeOf(PointOctree)).call(this));\\n\\n  \\t\\t_this.root = new PointOctant(min, max);\\n\\n  \\t\\t_this.bias = Math.max(0.0, bias);\\n\\n  \\t\\t_this.maxPoints = Math.max(1, Math.round(maxPoints));\\n\\n  \\t\\t_this.maxDepth = Math.max(0, Math.round(maxDepth));\\n\\n  \\t\\t_this.pointCount = 0;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(PointOctree, [{\\n  \\t\\tkey: \"countPoints\",\\n  \\t\\tvalue: function countPoints(octant) {\\n\\n  \\t\\t\\treturn _countPoints(octant);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"put\",\\n  \\t\\tvalue: function put(point, data) {\\n\\n  \\t\\t\\treturn _put(point, data, this, this.root, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"remove\",\\n  \\t\\tvalue: function remove(point) {\\n\\n  \\t\\t\\treturn _remove(point, this, this.root, null);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"fetch\",\\n  \\t\\tvalue: function fetch(point) {\\n\\n  \\t\\t\\treturn _fetch(point, this, this.root);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"move\",\\n  \\t\\tvalue: function move(point, position) {\\n\\n  \\t\\t\\treturn _move(point, position, this, this.root, null, 0);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"findNearestPoint\",\\n  \\t\\tvalue: function findNearestPoint(point) {\\n  \\t\\t\\tvar maxDistance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\\n  \\t\\t\\tvar skipSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n\\n  \\t\\t\\treturn _findNearestPoint(point, maxDistance, skipSelf, this.root);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"findPoints\",\\n  \\t\\tvalue: function findPoints(point, radius) {\\n  \\t\\t\\tvar skipSelf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n\\n  \\t\\t\\tvar result = [];\\n\\n  \\t\\t\\t_findPoints(point, radius, skipSelf, this.root, result);\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"raycast\",\\n  \\t\\tvalue: function raycast(raycaster) {\\n  \\t\\t\\tvar intersects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n\\n\\n  \\t\\t\\tvar octants = get(PointOctree.prototype.__proto__ || Object.getPrototypeOf(PointOctree.prototype), \"raycast\", this).call(this, raycaster);\\n\\n  \\t\\t\\tif (octants.length > 0) {\\n  \\t\\t\\t\\tthis.testPoints(octants, raycaster, intersects);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn intersects;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"testPoints\",\\n  \\t\\tvalue: function testPoints(octants, raycaster, intersects) {\\n\\n  \\t\\t\\tvar threshold = raycaster.params.Points.threshold;\\n  \\t\\t\\tvar thresholdSq = threshold * threshold;\\n\\n  \\t\\t\\tvar intersectPoint = void 0;\\n  \\t\\t\\tvar distance = void 0,\\n  \\t\\t\\t    distanceToRay = void 0;\\n  \\t\\t\\tvar rayPointDistanceSq = void 0;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    j = void 0,\\n  \\t\\t\\t    il = void 0,\\n  \\t\\t\\t    jl = void 0;\\n  \\t\\t\\tvar octant = void 0,\\n  \\t\\t\\t    points = void 0,\\n  \\t\\t\\t    point = void 0;\\n\\n  \\t\\t\\tfor (i = 0, il = octants.length; i < il; ++i) {\\n\\n  \\t\\t\\t\\toctant = octants[i];\\n  \\t\\t\\t\\tpoints = octant.points;\\n\\n  \\t\\t\\t\\tif (points !== null) {\\n\\n  \\t\\t\\t\\t\\tfor (j = 0, jl = points.length; j < jl; ++j) {\\n\\n  \\t\\t\\t\\t\\t\\tpoint = points[j];\\n  \\t\\t\\t\\t\\t\\trayPointDistanceSq = raycaster.ray.distanceSqToPoint(point);\\n\\n  \\t\\t\\t\\t\\t\\tif (rayPointDistanceSq < thresholdSq) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tintersectPoint = raycaster.ray.closestPointToPoint(point);\\n  \\t\\t\\t\\t\\t\\t\\tdistance = raycaster.ray.origin.distanceTo(intersectPoint);\\n\\n  \\t\\t\\t\\t\\t\\t\\tif (distance >= raycaster.near && distance <= raycaster.far) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tdistanceToRay = Math.sqrt(rayPointDistanceSq);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tintersects.push(new RayPointIntersection(distance, distanceToRay, intersectPoint, octant.data[j]));\\n  \\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn PointOctree;\\n  }(Octree);\\n\\n  var b$6 = new Box3();\\n\\n  var c$3 = new Vector3();\\n\\n  var u = new Vector3();\\n\\n  var v$5 = new Vector3();\\n\\n  var OctreeUtils = function () {\\n  \\tfunction OctreeUtils() {\\n  \\t\\tclassCallCheck(this, OctreeUtils);\\n  \\t}\\n\\n  \\tcreateClass(OctreeUtils, null, [{\\n  \\t\\tkey: \"recycleOctants\",\\n  \\t\\tvalue: function recycleOctants(octant, octants) {\\n\\n  \\t\\t\\tvar min = octant.min;\\n  \\t\\t\\tvar mid = octant.getCenter(u);\\n  \\t\\t\\tvar halfDimensions = octant.getDimensions(v$5).multiplyScalar(0.5);\\n\\n  \\t\\t\\tvar children = octant.children;\\n  \\t\\t\\tvar l = octants.length;\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    j = void 0;\\n  \\t\\t\\tvar combination = void 0,\\n  \\t\\t\\t    candidate = void 0;\\n\\n  \\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\tcombination = pattern[i];\\n\\n  \\t\\t\\t\\tb$6.min.addVectors(min, c$3.fromArray(combination).multiply(halfDimensions));\\n  \\t\\t\\t\\tb$6.max.addVectors(mid, c$3.fromArray(combination).multiply(halfDimensions));\\n\\n  \\t\\t\\t\\tfor (j = 0; j < l; ++j) {\\n\\n  \\t\\t\\t\\t\\tcandidate = octants[j];\\n\\n  \\t\\t\\t\\t\\tif (candidate !== null && b$6.min.equals(candidate.min) && b$6.max.equals(candidate.max)) {\\n\\n  \\t\\t\\t\\t\\t\\tchildren[i] = candidate;\\n  \\t\\t\\t\\t\\t\\toctants[j] = null;\\n\\n  \\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn OctreeUtils;\\n  }();\\n\\n  var ISOVALUE_BIAS = 1e-4;\\n\\n  var INTERVAL_THRESHOLD = 1e-6;\\n\\n  var ab = new Vector3();\\n\\n  var p$1 = new Vector3();\\n\\n  var v$6 = new Vector3();\\n\\n  var Edge = function () {\\n  \\t\\tfunction Edge() {\\n  \\t\\t\\t\\tvar a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n  \\t\\t\\t\\tvar b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\t\\t\\tclassCallCheck(this, Edge);\\n\\n\\n  \\t\\t\\t\\tthis.a = a;\\n\\n  \\t\\t\\t\\tthis.b = b;\\n\\n  \\t\\t\\t\\tthis.index = -1;\\n\\n  \\t\\t\\t\\tthis.coordinates = new Vector3();\\n\\n  \\t\\t\\t\\tthis.t = 0.0;\\n\\n  \\t\\t\\t\\tthis.n = new Vector3();\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Edge, [{\\n  \\t\\t\\t\\tkey: \"approximateZeroCrossing\",\\n  \\t\\t\\t\\tvalue: function approximateZeroCrossing(sdf) {\\n  \\t\\t\\t\\t\\t\\tvar steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar s = Math.max(1, steps - 1);\\n\\n  \\t\\t\\t\\t\\t\\tvar a = 0.0;\\n  \\t\\t\\t\\t\\t\\tvar b = 1.0;\\n  \\t\\t\\t\\t\\t\\tvar c = 0.0;\\n  \\t\\t\\t\\t\\t\\tvar i = 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar densityA = void 0,\\n  \\t\\t\\t\\t\\t\\t    densityC = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tab.subVectors(this.b, this.a);\\n\\n  \\t\\t\\t\\t\\t\\twhile (i <= s) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tc = (a + b) / 2;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tp$1.addVectors(this.a, v$6.copy(ab).multiplyScalar(c));\\n  \\t\\t\\t\\t\\t\\t\\t\\tdensityC = sdf.sample(p$1);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (Math.abs(densityC) <= ISOVALUE_BIAS || (b - a) / 2 <= INTERVAL_THRESHOLD) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tp$1.addVectors(this.a, v$6.copy(ab).multiplyScalar(a));\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdensityA = sdf.sample(p$1);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (Math.sign(densityC) === Math.sign(densityA)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ta = c;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tb = c;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t++i;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.t = c;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"computeZeroCrossingPosition\",\\n  \\t\\t\\t\\tvalue: function computeZeroCrossingPosition() {\\n  \\t\\t\\t\\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\\n\\n\\n  \\t\\t\\t\\t\\t\\treturn target.subVectors(this.b, this.a).multiplyScalar(this.t).add(this.a);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"computeSurfaceNormal\",\\n  \\t\\t\\t\\tvalue: function computeSurfaceNormal(sdf) {\\n\\n  \\t\\t\\t\\t\\t\\tvar position = this.computeZeroCrossingPosition(ab);\\n  \\t\\t\\t\\t\\t\\tvar E = 1e-3;\\n\\n  \\t\\t\\t\\t\\t\\tvar dx = sdf.sample(p$1.addVectors(position, v$6.set(E, 0, 0))) - sdf.sample(p$1.subVectors(position, v$6.set(E, 0, 0)));\\n  \\t\\t\\t\\t\\t\\tvar dy = sdf.sample(p$1.addVectors(position, v$6.set(0, E, 0))) - sdf.sample(p$1.subVectors(position, v$6.set(0, E, 0)));\\n  \\t\\t\\t\\t\\t\\tvar dz = sdf.sample(p$1.addVectors(position, v$6.set(0, 0, E))) - sdf.sample(p$1.subVectors(position, v$6.set(0, 0, E)));\\n\\n  \\t\\t\\t\\t\\t\\tthis.n.set(dx, dy, dz).normalize();\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Edge;\\n  }();\\n\\n  var edge = new Edge();\\n\\n  var offsetA = new Vector3();\\n\\n  var offsetB = new Vector3();\\n\\n  var EdgeIterator = function () {\\n  \\t\\tfunction EdgeIterator(edgeData, cellPosition, cellSize) {\\n  \\t\\t\\t\\tvar c = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\\n  \\t\\t\\t\\tvar d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 3;\\n  \\t\\t\\t\\tclassCallCheck(this, EdgeIterator);\\n\\n\\n  \\t\\t\\t\\tthis.edgeData = edgeData;\\n\\n  \\t\\t\\t\\tthis.cellPosition = cellPosition;\\n\\n  \\t\\t\\t\\tthis.cellSize = cellSize;\\n\\n  \\t\\t\\t\\tthis.indices = null;\\n\\n  \\t\\t\\t\\tthis.zeroCrossings = null;\\n\\n  \\t\\t\\t\\tthis.normals = null;\\n\\n  \\t\\t\\t\\tthis.axes = null;\\n\\n  \\t\\t\\t\\tthis.lengths = null;\\n\\n  \\t\\t\\t\\tthis.result = new IteratorResult();\\n\\n  \\t\\t\\t\\tthis.initialC = c;\\n\\n  \\t\\t\\t\\tthis.c = c;\\n\\n  \\t\\t\\t\\tthis.initialD = d;\\n\\n  \\t\\t\\t\\tthis.d = d;\\n\\n  \\t\\t\\t\\tthis.i = 0;\\n\\n  \\t\\t\\t\\tthis.l = 0;\\n\\n  \\t\\t\\t\\tthis.reset();\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(EdgeIterator, [{\\n  \\t\\t\\t\\tkey: \"reset\",\\n  \\t\\t\\t\\tvalue: function reset() {\\n\\n  \\t\\t\\t\\t\\t\\tvar edgeData = this.edgeData;\\n  \\t\\t\\t\\t\\t\\tvar indices = [];\\n  \\t\\t\\t\\t\\t\\tvar zeroCrossings = [];\\n  \\t\\t\\t\\t\\t\\tvar normals = [];\\n  \\t\\t\\t\\t\\t\\tvar axes = [];\\n  \\t\\t\\t\\t\\t\\tvar lengths = [];\\n\\n  \\t\\t\\t\\t\\t\\tvar a = void 0,\\n  \\t\\t\\t\\t\\t\\t    c = void 0,\\n  \\t\\t\\t\\t\\t\\t    d = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tthis.i = 0;\\n  \\t\\t\\t\\t\\t\\tthis.c = 0;\\n  \\t\\t\\t\\t\\t\\tthis.d = 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (c = this.initialC, a = 4 >> c, d = this.initialD; c < d; ++c, a >>= 1) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tl = edgeData.indices[c].length;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tif (l > 0) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tindices.push(edgeData.indices[c]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tzeroCrossings.push(edgeData.zeroCrossings[c]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals.push(edgeData.normals[c]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\taxes.push(pattern[a]);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlengths.push(l);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++this.d;\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.l = lengths.length > 0 ? lengths[0] : 0;\\n\\n  \\t\\t\\t\\t\\t\\tthis.indices = indices;\\n  \\t\\t\\t\\t\\t\\tthis.zeroCrossings = zeroCrossings;\\n  \\t\\t\\t\\t\\t\\tthis.normals = normals;\\n  \\t\\t\\t\\t\\t\\tthis.axes = axes;\\n  \\t\\t\\t\\t\\t\\tthis.lengths = lengths;\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.reset();\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"next\",\\n  \\t\\t\\t\\tvalue: function next() {\\n\\n  \\t\\t\\t\\t\\t\\tvar s = this.cellSize;\\n  \\t\\t\\t\\t\\t\\tvar n = HermiteData.resolution;\\n  \\t\\t\\t\\t\\t\\tvar m = n + 1;\\n  \\t\\t\\t\\t\\t\\tvar mm = m * m;\\n\\n  \\t\\t\\t\\t\\t\\tvar result = this.result;\\n  \\t\\t\\t\\t\\t\\tvar base = this.cellPosition;\\n\\n  \\t\\t\\t\\t\\t\\tvar axis = void 0,\\n  \\t\\t\\t\\t\\t\\t    index = void 0;\\n  \\t\\t\\t\\t\\t\\tvar x = void 0,\\n  \\t\\t\\t\\t\\t\\t    y = void 0,\\n  \\t\\t\\t\\t\\t\\t    z = void 0;\\n  \\t\\t\\t\\t\\t\\tvar c = void 0,\\n  \\t\\t\\t\\t\\t\\t    i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (this.i === this.l) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.l = ++this.c < this.d ? this.lengths[this.c] : 0;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.i = 0;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tif (this.i < this.l) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tc = this.c;\\n  \\t\\t\\t\\t\\t\\t\\t\\ti = this.i;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\taxis = this.axes[c];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tindex = this.indices[c][i];\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.index = index;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tx = index % m;\\n  \\t\\t\\t\\t\\t\\t\\t\\ty = Math.trunc(index % mm / m);\\n  \\t\\t\\t\\t\\t\\t\\t\\tz = Math.trunc(index / mm);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.coordinates.set(x, y, z);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\toffsetA.set(x * s / n, y * s / n, z * s / n);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\toffsetB.set((x + axis[0]) * s / n, (y + axis[1]) * s / n, (z + axis[2]) * s / n);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.a.addVectors(base, offsetA);\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.b.addVectors(base, offsetB);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.t = this.zeroCrossings[c][i];\\n  \\t\\t\\t\\t\\t\\t\\t\\tedge.n.fromArray(this.normals[c], i * 3);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult.value = edge;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t++this.i;\\n  \\t\\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult.value = null;\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult.done = true;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"return\",\\n  \\t\\t\\t\\tvalue: function _return(value) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.result.value = value;\\n  \\t\\t\\t\\t\\t\\tthis.result.done = true;\\n\\n  \\t\\t\\t\\t\\t\\treturn this.result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: Symbol.iterator,\\n  \\t\\t\\t\\tvalue: function value() {\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn EdgeIterator;\\n  }();\\n\\n  var EdgeData = function () {\\n  \\tfunction EdgeData() {\\n  \\t\\tvar x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n  \\t\\tvar y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\\n  \\t\\tvar z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x;\\n  \\t\\tclassCallCheck(this, EdgeData);\\n\\n\\n  \\t\\tthis.indices = x <= 0 ? null : [new Uint32Array(x), new Uint32Array(y), new Uint32Array(z)];\\n\\n  \\t\\tthis.zeroCrossings = x <= 0 ? null : [new Float32Array(x), new Float32Array(y), new Float32Array(z)];\\n\\n  \\t\\tthis.normals = x <= 0 ? null : [new Float32Array(x * 3), new Float32Array(y * 3), new Float32Array(z * 3)];\\n  \\t}\\n\\n  \\tcreateClass(EdgeData, [{\\n  \\t\\tkey: \"serialize\",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\treturn {\\n  \\t\\t\\t\\tedges: this.edges,\\n  \\t\\t\\t\\tzeroCrossings: this.zeroCrossings,\\n  \\t\\t\\t\\tnormals: this.normals\\n  \\t\\t\\t};\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"deserialize\",\\n  \\t\\tvalue: function deserialize(object) {\\n\\n  \\t\\t\\tvar result = this;\\n\\n  \\t\\t\\tif (object !== null) {\\n\\n  \\t\\t\\t\\tthis.edges = object.edges;\\n  \\t\\t\\t\\tthis.zeroCrossings = object.zeroCrossings;\\n  \\t\\t\\t\\tthis.normals = object.normals;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tresult = null;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"createTransferList\",\\n  \\t\\tvalue: function createTransferList() {\\n  \\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\tvar arrays = [this.edges[0], this.edges[1], this.edges[2], this.zeroCrossings[0], this.zeroCrossings[1], this.zeroCrossings[2], this.normals[0], this.normals[1], this.normals[2]];\\n\\n  \\t\\t\\tvar array = void 0;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tfor (i = 0, l = arrays.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tarray = arrays[i];\\n\\n  \\t\\t\\t\\tif (array !== null) {\\n\\n  \\t\\t\\t\\t\\ttransferList.push(array.buffer);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn transferList;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"edges\",\\n  \\t\\tvalue: function edges(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"edgesX\",\\n  \\t\\tvalue: function edgesX(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize, 0, 1);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"edgesY\",\\n  \\t\\tvalue: function edgesY(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize, 1, 2);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"edgesZ\",\\n  \\t\\tvalue: function edgesZ(cellPosition, cellSize) {\\n\\n  \\t\\t\\treturn new EdgeIterator(this, cellPosition, cellSize, 2, 3);\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: \"calculate1DEdgeCount\",\\n  \\t\\tvalue: function calculate1DEdgeCount(n) {\\n\\n  \\t\\t\\treturn Math.pow(n + 1, 2) * n;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn EdgeData;\\n  }();\\n\\n  var Material = {\\n\\n    AIR: 0,\\n    SOLID: 1\\n\\n  };\\n\\n  var resolution = 0;\\n\\n  var indexCount = 0;\\n\\n  function ceil2(n) {\\n\\n  \\treturn Math.pow(2, Math.max(0, Math.ceil(Math.log2(n))));\\n  }\\n\\n  var HermiteData = function () {\\n  \\tfunction HermiteData() {\\n  \\t\\tvar initialise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\\n  \\t\\tclassCallCheck(this, HermiteData);\\n\\n\\n  \\t\\tthis.materials = 0;\\n\\n  \\t\\tthis.materialIndices = initialise ? new Uint8Array(indexCount) : null;\\n\\n  \\t\\tthis.runLengths = null;\\n\\n  \\t\\tthis.edgeData = null;\\n  \\t}\\n\\n  \\tcreateClass(HermiteData, [{\\n  \\t\\tkey: \"set\",\\n  \\t\\tvalue: function set$$1(data) {\\n\\n  \\t\\t\\tthis.materials = data.materials;\\n  \\t\\t\\tthis.materialIndices = data.materialIndices;\\n  \\t\\t\\tthis.runLengths = data.runLengths;\\n  \\t\\t\\tthis.edgeData = data.edgeData;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"clear\",\\n  \\t\\tvalue: function clear() {\\n\\n  \\t\\t\\tthis.materials = 0;\\n  \\t\\t\\tthis.materialIndices = null;\\n  \\t\\t\\tthis.runLengths = null;\\n  \\t\\t\\tthis.edgeData = null;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"setMaterialIndex\",\\n  \\t\\tvalue: function setMaterialIndex(index, value) {\\n  \\t\\t\\tif (this.materialIndices[index] === Material.AIR) {\\n\\n  \\t\\t\\t\\tif (value !== Material.AIR) {\\n\\n  \\t\\t\\t\\t\\t++this.materials;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else if (value === Material.AIR) {\\n\\n  \\t\\t\\t\\t--this.materials;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tthis.materialIndices[index] = value;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"compress\",\\n  \\t\\tvalue: function compress() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\\n\\n\\n  \\t\\t\\tvar encoding = void 0;\\n\\n  \\t\\t\\tif (!this.compressed) {\\n  \\t\\t\\t\\tif (this.full) {\\n  \\t\\t\\t\\t\\tencoding = new RunLengthEncoding([this.materialIndices.length], [Material.SOLID]);\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tencoding = RunLengthEncoding.encode(this.materialIndices);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\ttarget.materialIndices = new Uint8Array(encoding.data);\\n  \\t\\t\\t\\ttarget.runLengths = new Uint32Array(encoding.runLengths);\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttarget.materialIndices = this.materialIndices;\\n  \\t\\t\\t\\ttarget.runLengths = this.runLengths;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\ttarget.materials = this.materials;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"decompress\",\\n  \\t\\tvalue: function decompress() {\\n  \\t\\t\\tvar target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\\n\\n\\n  \\t\\t\\ttarget.materialIndices = !this.compressed ? this.materialIndices : RunLengthEncoding.decode(this.runLengths, this.materialIndices, new Uint8Array(indexCount));\\n\\n  \\t\\t\\ttarget.runLengths = null;\\n  \\t\\t\\ttarget.materials = this.materials;\\n\\n  \\t\\t\\treturn target;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"serialize\",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\treturn {\\n  \\t\\t\\t\\tmaterials: this.materials,\\n  \\t\\t\\t\\tmaterialIndices: this.materialIndices,\\n  \\t\\t\\t\\trunLengths: this.runLengths,\\n  \\t\\t\\t\\tedgeData: this.edgeData !== null ? this.edgeData.serialize() : null\\n  \\t\\t\\t};\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"deserialize\",\\n  \\t\\tvalue: function deserialize(object) {\\n\\n  \\t\\t\\tvar result = this;\\n\\n  \\t\\t\\tif (object !== null) {\\n\\n  \\t\\t\\t\\tthis.materials = object.materials;\\n  \\t\\t\\t\\tthis.materialIndices = object.materialIndices;\\n  \\t\\t\\t\\tthis.runLengths = object.runLengths;\\n\\n  \\t\\t\\t\\tif (object.edgeData !== null) {\\n\\n  \\t\\t\\t\\t\\tif (this.edgeData === null) {\\n  \\t\\t\\t\\t\\t\\tthis.edgeData = new EdgeData();\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\tthis.edgeData.deserialize(object.edgeData);\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tthis.edgeData = null;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tresult = null;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"createTransferList\",\\n  \\t\\tvalue: function createTransferList() {\\n  \\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\tif (this.edgeData !== null) {\\n\\n  \\t\\t\\t\\tthis.edgeData.createTransferList(transferList);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (this.materialIndices !== null) {\\n\\n  \\t\\t\\t\\ttransferList.push(this.materialIndices.buffer);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (this.runLengths !== null) {\\n\\n  \\t\\t\\t\\ttransferList.push(this.runLengths.buffer);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn transferList;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"empty\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.materials === 0;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"full\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.materials === indexCount;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"compressed\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.runLengths !== null;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"neutered\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn !this.empty && this.materialIndices === null;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: \"resolution\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn resolution;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\tresolution = Math.max(1, Math.min(256, ceil2(value)));\\n  \\t\\t\\tindexCount = Math.pow(resolution + 1, 3);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn HermiteData;\\n  }();\\n\\n  var QEFData = function () {\\n  \\t\\tfunction QEFData() {\\n  \\t\\t\\t\\tclassCallCheck(this, QEFData);\\n\\n\\n  \\t\\t\\t\\tthis.ata = new SymmetricMatrix3();\\n\\n  \\t\\t\\t\\tthis.ata.set(0, 0, 0, 0, 0, 0);\\n\\n  \\t\\t\\t\\tthis.atb = new Vector3();\\n\\n  \\t\\t\\t\\tthis.massPointSum = new Vector3();\\n\\n  \\t\\t\\t\\tthis.numPoints = 0;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(QEFData, [{\\n  \\t\\t\\t\\tkey: \"set\",\\n  \\t\\t\\t\\tvalue: function set$$1(ata, atb, massPointSum, numPoints) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.ata.copy(ata);\\n  \\t\\t\\t\\t\\t\\tthis.atb.copy(atb);\\n\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.copy(massPointSum);\\n  \\t\\t\\t\\t\\t\\tthis.numPoints = numPoints;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"copy\",\\n  \\t\\t\\t\\tvalue: function copy(d) {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.set(d.ata, d.atb, d.massPointSum, d.numPoints);\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"add\",\\n  \\t\\t\\t\\tvalue: function add(p, n) {\\n\\n  \\t\\t\\t\\t\\t\\tvar nx = n.x;\\n  \\t\\t\\t\\t\\t\\tvar ny = n.y;\\n  \\t\\t\\t\\t\\t\\tvar nz = n.z;\\n\\n  \\t\\t\\t\\t\\t\\tvar b = p.dot(n);\\n\\n  \\t\\t\\t\\t\\t\\tvar ata = this.ata.elements;\\n  \\t\\t\\t\\t\\t\\tvar atb = this.atb;\\n\\n  \\t\\t\\t\\t\\t\\tata[0] += nx * nx;\\n  \\t\\t\\t\\t\\t\\tata[1] += nx * ny;ata[3] += ny * ny;\\n  \\t\\t\\t\\t\\t\\tata[2] += nx * nz;ata[4] += ny * nz;ata[5] += nz * nz;\\n\\n  \\t\\t\\t\\t\\t\\tatb.x += b * nx;\\n  \\t\\t\\t\\t\\t\\tatb.y += b * ny;\\n  \\t\\t\\t\\t\\t\\tatb.z += b * nz;\\n\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.add(p);\\n\\n  \\t\\t\\t\\t\\t\\t++this.numPoints;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"addData\",\\n  \\t\\t\\t\\tvalue: function addData(d) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.ata.add(d.ata);\\n  \\t\\t\\t\\t\\t\\tthis.atb.add(d.atb);\\n\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.add(d.massPointSum);\\n  \\t\\t\\t\\t\\t\\tthis.numPoints += d.numPoints;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"clear\",\\n  \\t\\t\\t\\tvalue: function clear() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.ata.set(0, 0, 0, 0, 0, 0);\\n\\n  \\t\\t\\t\\t\\t\\tthis.atb.set(0, 0, 0);\\n  \\t\\t\\t\\t\\t\\tthis.massPointSum.set(0, 0, 0);\\n  \\t\\t\\t\\t\\t\\tthis.numPoints = 0;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"clone\",\\n  \\t\\t\\t\\tvalue: function clone() {\\n\\n  \\t\\t\\t\\t\\t\\treturn new this.constructor().copy(this);\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn QEFData;\\n  }();\\n\\n  var coefficients = new Vector2();\\n\\n  var Givens = function () {\\n  \\tfunction Givens() {\\n  \\t\\tclassCallCheck(this, Givens);\\n  \\t}\\n\\n  \\tcreateClass(Givens, null, [{\\n  \\t\\tkey: \"calculateCoefficients\",\\n  \\t\\tvalue: function calculateCoefficients(aPP, aPQ, aQQ) {\\n\\n  \\t\\t\\tvar tau = void 0,\\n  \\t\\t\\t    stt = void 0,\\n  \\t\\t\\t    tan = void 0;\\n\\n  \\t\\t\\tif (aPQ === 0.0) {\\n\\n  \\t\\t\\t\\tcoefficients.x = 1.0;\\n  \\t\\t\\t\\tcoefficients.y = 0.0;\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\ttau = (aQQ - aPP) / (2.0 * aPQ);\\n  \\t\\t\\t\\tstt = Math.sqrt(1.0 + tau * tau);\\n  \\t\\t\\t\\ttan = 1.0 / (tau >= 0.0 ? tau + stt : tau - stt);\\n\\n  \\t\\t\\t\\tcoefficients.x = 1.0 / Math.sqrt(1.0 + tan * tan);\\n  \\t\\t\\t\\tcoefficients.y = tan * coefficients.x;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn coefficients;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Givens;\\n  }();\\n\\n  var Schur = function () {\\n  \\tfunction Schur() {\\n  \\t\\tclassCallCheck(this, Schur);\\n  \\t}\\n\\n  \\tcreateClass(Schur, null, [{\\n  \\t\\tkey: \"rotateXY\",\\n  \\t\\tvalue: function rotateXY(a, coefficients) {\\n\\n  \\t\\t\\tvar c = coefficients.x;\\n  \\t\\t\\tvar s = coefficients.y;\\n\\n  \\t\\t\\tvar u = a.x;\\n  \\t\\t\\tvar v = a.y;\\n\\n  \\t\\t\\ta.set(c * u - s * v, s * u + c * v);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"rotateQXY\",\\n  \\t\\tvalue: function rotateQXY(a, q, coefficients) {\\n\\n  \\t\\t\\tvar c = coefficients.x;\\n  \\t\\t\\tvar s = coefficients.y;\\n  \\t\\t\\tvar cc = c * c;\\n  \\t\\t\\tvar ss = s * s;\\n\\n  \\t\\t\\tvar mx = 2.0 * c * s * q;\\n\\n  \\t\\t\\tvar u = a.x;\\n  \\t\\t\\tvar v = a.y;\\n\\n  \\t\\t\\ta.set(cc * u - mx + ss * v, ss * u + mx + cc * v);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Schur;\\n  }();\\n\\n  var PSEUDOINVERSE_THRESHOLD = 1e-1;\\n\\n  var SVD_SWEEPS = 5;\\n\\n  var sm = new SymmetricMatrix3();\\n\\n  var m$1 = new Matrix3();\\n\\n  var a$3 = new Vector2();\\n\\n  var b$7 = new Vector3();\\n\\n  function rotate01(vtav, v) {\\n\\n  \\tvar se = vtav.elements;\\n  \\tvar ve = v.elements;\\n\\n  \\tvar coefficients = void 0;\\n\\n  \\tif (se[1] !== 0.0) {\\n\\n  \\t\\tcoefficients = Givens.calculateCoefficients(se[0], se[1], se[3]);\\n\\n  \\t\\tSchur.rotateQXY(a$3.set(se[0], se[3]), se[1], coefficients);\\n  \\t\\tse[0] = a$3.x;se[3] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(se[2], se[4]), coefficients);\\n  \\t\\tse[2] = a$3.x;se[4] = a$3.y;\\n\\n  \\t\\tse[1] = 0.0;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[0], ve[3]), coefficients);\\n  \\t\\tve[0] = a$3.x;ve[3] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[1], ve[4]), coefficients);\\n  \\t\\tve[1] = a$3.x;ve[4] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[2], ve[5]), coefficients);\\n  \\t\\tve[2] = a$3.x;ve[5] = a$3.y;\\n  \\t}\\n  }\\n\\n  function rotate02(vtav, v) {\\n\\n  \\tvar se = vtav.elements;\\n  \\tvar ve = v.elements;\\n\\n  \\tvar coefficients = void 0;\\n\\n  \\tif (se[2] !== 0.0) {\\n\\n  \\t\\tcoefficients = Givens.calculateCoefficients(se[0], se[2], se[5]);\\n\\n  \\t\\tSchur.rotateQXY(a$3.set(se[0], se[5]), se[2], coefficients);\\n  \\t\\tse[0] = a$3.x;se[5] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(se[1], se[4]), coefficients);\\n  \\t\\tse[1] = a$3.x;se[4] = a$3.y;\\n\\n  \\t\\tse[2] = 0.0;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[0], ve[6]), coefficients);\\n  \\t\\tve[0] = a$3.x;ve[6] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[1], ve[7]), coefficients);\\n  \\t\\tve[1] = a$3.x;ve[7] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[2], ve[8]), coefficients);\\n  \\t\\tve[2] = a$3.x;ve[8] = a$3.y;\\n  \\t}\\n  }\\n\\n  function rotate12(vtav, v) {\\n\\n  \\tvar se = vtav.elements;\\n  \\tvar ve = v.elements;\\n\\n  \\tvar coefficients = void 0;\\n\\n  \\tif (se[4] !== 0.0) {\\n\\n  \\t\\tcoefficients = Givens.calculateCoefficients(se[3], se[4], se[5]);\\n\\n  \\t\\tSchur.rotateQXY(a$3.set(se[3], se[5]), se[4], coefficients);\\n  \\t\\tse[3] = a$3.x;se[5] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(se[1], se[2]), coefficients);\\n  \\t\\tse[1] = a$3.x;se[2] = a$3.y;\\n\\n  \\t\\tse[4] = 0.0;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[3], ve[6]), coefficients);\\n  \\t\\tve[3] = a$3.x;ve[6] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[4], ve[7]), coefficients);\\n  \\t\\tve[4] = a$3.x;ve[7] = a$3.y;\\n\\n  \\t\\tSchur.rotateXY(a$3.set(ve[5], ve[8]), coefficients);\\n  \\t\\tve[5] = a$3.x;ve[8] = a$3.y;\\n  \\t}\\n  }\\n\\n  function solveSymmetric(vtav, v) {\\n\\n  \\tvar e = vtav.elements;\\n\\n  \\tvar i = void 0;\\n\\n  \\tfor (i = 0; i < SVD_SWEEPS; ++i) {\\n  \\t\\trotate01(vtav, v);\\n  \\t\\trotate02(vtav, v);\\n  \\t\\trotate12(vtav, v);\\n  \\t}\\n\\n  \\treturn b$7.set(e[0], e[3], e[5]);\\n  }\\n\\n  function invert(x) {\\n\\n  \\tvar invX = Math.abs(x) < PSEUDOINVERSE_THRESHOLD ? 0.0 : 1.0 / x;\\n\\n  \\treturn Math.abs(invX) < PSEUDOINVERSE_THRESHOLD ? 0.0 : invX;\\n  }\\n\\n  function pseudoInverse(v, sigma) {\\n\\n  \\tvar ve = v.elements;\\n\\n  \\tvar v00 = ve[0],\\n  \\t    v01 = ve[3],\\n  \\t    v02 = ve[6];\\n  \\tvar v10 = ve[1],\\n  \\t    v11 = ve[4],\\n  \\t    v12 = ve[7];\\n  \\tvar v20 = ve[2],\\n  \\t    v21 = ve[5],\\n  \\t    v22 = ve[8];\\n\\n  \\tvar d0 = invert(sigma.x);\\n  \\tvar d1 = invert(sigma.y);\\n  \\tvar d2 = invert(sigma.z);\\n\\n  \\treturn v.set(v00 * d0 * v00 + v01 * d1 * v01 + v02 * d2 * v02, v00 * d0 * v10 + v01 * d1 * v11 + v02 * d2 * v12, v00 * d0 * v20 + v01 * d1 * v21 + v02 * d2 * v22, v10 * d0 * v00 + v11 * d1 * v01 + v12 * d2 * v02, v10 * d0 * v10 + v11 * d1 * v11 + v12 * d2 * v12, v10 * d0 * v20 + v11 * d1 * v21 + v12 * d2 * v22, v20 * d0 * v00 + v21 * d1 * v01 + v22 * d2 * v02, v20 * d0 * v10 + v21 * d1 * v11 + v22 * d2 * v12, v20 * d0 * v20 + v21 * d1 * v21 + v22 * d2 * v22);\\n  }\\n\\n  var SingularValueDecomposition = function () {\\n  \\tfunction SingularValueDecomposition() {\\n  \\t\\tclassCallCheck(this, SingularValueDecomposition);\\n  \\t}\\n\\n  \\tcreateClass(SingularValueDecomposition, null, [{\\n  \\t\\tkey: \"solve\",\\n  \\t\\tvalue: function solve(ata, atb, x) {\\n\\n  \\t\\t\\tvar sigma = solveSymmetric(sm.copy(ata), m$1.identity());\\n  \\t\\t\\tvar invV = pseudoInverse(m$1, sigma);\\n\\n  \\t\\t\\tx.copy(atb).applyMatrix3(invV);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn SingularValueDecomposition;\\n  }();\\n\\n  var p$2 = new Vector3();\\n\\n  function calculateError(ata, atb, x) {\\n\\n  \\t\\tata.applyToVector3(p$2.copy(x));\\n  \\t\\tp$2.subVectors(atb, p$2);\\n\\n  \\t\\treturn p$2.dot(p$2);\\n  }\\n\\n  var QEFSolver = function () {\\n  \\t\\tfunction QEFSolver() {\\n  \\t\\t\\t\\tclassCallCheck(this, QEFSolver);\\n\\n\\n  \\t\\t\\t\\tthis.data = null;\\n\\n  \\t\\t\\t\\tthis.ata = new SymmetricMatrix3();\\n\\n  \\t\\t\\t\\tthis.atb = new Vector3();\\n\\n  \\t\\t\\t\\tthis.massPoint = new Vector3();\\n\\n  \\t\\t\\t\\tthis.hasSolution = false;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(QEFSolver, [{\\n  \\t\\t\\t\\tkey: \"setData\",\\n  \\t\\t\\t\\tvalue: function setData(d) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.data = d;\\n  \\t\\t\\t\\t\\t\\tthis.hasSolution = false;\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"solve\",\\n  \\t\\t\\t\\tvalue: function solve(x) {\\n\\n  \\t\\t\\t\\t\\t\\tvar data = this.data;\\n  \\t\\t\\t\\t\\t\\tvar massPoint = this.massPoint;\\n  \\t\\t\\t\\t\\t\\tvar ata = this.ata.copy(data.ata);\\n  \\t\\t\\t\\t\\t\\tvar atb = this.atb.copy(data.atb);\\n\\n  \\t\\t\\t\\t\\t\\tvar error = Infinity;\\n\\n  \\t\\t\\t\\t\\t\\tif (!this.hasSolution && data !== null && data.numPoints > 0) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tp$2.copy(data.massPointSum).divideScalar(data.numPoints);\\n  \\t\\t\\t\\t\\t\\t\\t\\tmassPoint.copy(p$2);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tata.applyToVector3(p$2);\\n  \\t\\t\\t\\t\\t\\t\\t\\tatb.sub(p$2);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tSingularValueDecomposition.solve(ata, atb, x);\\n  \\t\\t\\t\\t\\t\\t\\t\\terror = calculateError(ata, atb, x);\\n  \\t\\t\\t\\t\\t\\t\\t\\tx.add(massPoint);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.hasSolution = true;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn error;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn QEFSolver;\\n  }();\\n\\n  var Voxel = function Voxel() {\\n  \\t\\tclassCallCheck(this, Voxel);\\n\\n\\n  \\t\\tthis.materials = 0;\\n\\n  \\t\\tthis.edgeCount = 0;\\n\\n  \\t\\tthis.index = -1;\\n\\n  \\t\\tthis.position = new Vector3();\\n\\n  \\t\\tthis.normal = new Vector3();\\n\\n  \\t\\tthis.qefData = null;\\n  };\\n\\n  var qefSolver = new QEFSolver();\\n\\n  var BIAS = 1e-1;\\n\\n  var errorThreshold = -1;\\n\\n  var VoxelCell = function (_CubicOctant) {\\n  \\tinherits(VoxelCell, _CubicOctant);\\n\\n  \\tfunction VoxelCell(min, size) {\\n  \\t\\tclassCallCheck(this, VoxelCell);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (VoxelCell.__proto__ || Object.getPrototypeOf(VoxelCell)).call(this, min, size));\\n\\n  \\t\\t_this.voxel = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(VoxelCell, [{\\n  \\t\\tkey: \"contains\",\\n  \\t\\tvalue: function contains(p) {\\n\\n  \\t\\t\\tvar min = this.min;\\n  \\t\\t\\tvar size = this.size;\\n\\n  \\t\\t\\treturn p.x >= min.x - BIAS && p.y >= min.y - BIAS && p.z >= min.z - BIAS && p.x <= min.x + size + BIAS && p.y <= min.y + size + BIAS && p.z <= min.z + size + BIAS;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"collapse\",\\n  \\t\\tvalue: function collapse() {\\n\\n  \\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\tvar signs = [-1, -1, -1, -1, -1, -1, -1, -1];\\n\\n  \\t\\t\\tvar position = new Vector3();\\n\\n  \\t\\t\\tvar midSign = -1;\\n  \\t\\t\\tvar collapsible = children !== null;\\n\\n  \\t\\t\\tvar removedVoxels = 0;\\n\\n  \\t\\t\\tvar child = void 0,\\n  \\t\\t\\t    sign = void 0,\\n  \\t\\t\\t    voxel = void 0;\\n  \\t\\t\\tvar qefData = void 0,\\n  \\t\\t\\t    error = void 0;\\n\\n  \\t\\t\\tvar v = void 0,\\n  \\t\\t\\t    i = void 0;\\n\\n  \\t\\t\\tif (collapsible) {\\n\\n  \\t\\t\\t\\tqefData = new QEFData();\\n\\n  \\t\\t\\t\\tfor (v = 0, i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\t\\tchild = children[i];\\n  \\t\\t\\t\\t\\tremovedVoxels += child.collapse();\\n  \\t\\t\\t\\t\\tvoxel = child.voxel;\\n\\n  \\t\\t\\t\\t\\tif (child.children !== null) {\\n  \\t\\t\\t\\t\\t\\tcollapsible = false;\\n  \\t\\t\\t\\t\\t} else if (voxel !== null) {\\n\\n  \\t\\t\\t\\t\\t\\tqefData.addData(voxel.qefData);\\n\\n  \\t\\t\\t\\t\\t\\tmidSign = voxel.materials >> 7 - i & 1;\\n  \\t\\t\\t\\t\\t\\tsigns[i] = voxel.materials >> i & 1;\\n\\n  \\t\\t\\t\\t\\t\\t++v;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (collapsible) {\\n\\n  \\t\\t\\t\\t\\terror = qefSolver.setData(qefData).solve(position);\\n\\n  \\t\\t\\t\\t\\tif (error <= errorThreshold) {\\n\\n  \\t\\t\\t\\t\\t\\tvoxel = new Voxel();\\n  \\t\\t\\t\\t\\t\\tvoxel.position.copy(this.contains(position) ? position : qefSolver.massPoint);\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\tsign = signs[i];\\n  \\t\\t\\t\\t\\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\t\\t\\t\\t\\tif (sign === -1) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tvoxel.materials |= midSign << i;\\n  \\t\\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvoxel.materials |= sign << i;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvoxel.normal.add(child.voxel.normal);\\n  \\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tvoxel.normal.normalize();\\n  \\t\\t\\t\\t\\t\\tvoxel.qefData = qefData;\\n\\n  \\t\\t\\t\\t\\t\\tthis.voxel = voxel;\\n  \\t\\t\\t\\t\\t\\tthis.children = null;\\n\\n  \\t\\t\\t\\t\\t\\tremovedVoxels += v - 1;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn removedVoxels;\\n  \\t\\t}\\n  \\t}], [{\\n  \\t\\tkey: \"errorThreshold\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn errorThreshold;\\n  \\t\\t},\\n  \\t\\tset: function set$$1(value) {\\n\\n  \\t\\t\\terrorThreshold = value;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn VoxelCell;\\n  }(CubicOctant);\\n\\n  var Message = function Message() {\\n  \\t\\tvar action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\tclassCallCheck(this, Message);\\n\\n\\n  \\t\\tthis.action = action;\\n\\n  \\t\\tthis.error = null;\\n  };\\n\\n  var Isosurface = function () {\\n  \\t\\tfunction Isosurface(indices, positions, normals, uvs, materials) {\\n  \\t\\t\\t\\tclassCallCheck(this, Isosurface);\\n\\n\\n  \\t\\t\\t\\tthis.indices = indices;\\n\\n  \\t\\t\\t\\tthis.positions = positions;\\n\\n  \\t\\t\\t\\tthis.normals = normals;\\n\\n  \\t\\t\\t\\tthis.uvs = uvs;\\n\\n  \\t\\t\\t\\tthis.materials = materials;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Isosurface, [{\\n  \\t\\t\\t\\tkey: \"serialize\",\\n  \\t\\t\\t\\tvalue: function serialize() {\\n  \\t\\t\\t\\t\\t\\treturn {\\n  \\t\\t\\t\\t\\t\\t\\t\\tindices: this.indices,\\n  \\t\\t\\t\\t\\t\\t\\t\\tpositions: this.positions,\\n  \\t\\t\\t\\t\\t\\t\\t\\tnormals: this.normals,\\n  \\t\\t\\t\\t\\t\\t\\t\\tuvs: this.uvs,\\n  \\t\\t\\t\\t\\t\\t\\t\\tmaterials: this.materials\\n  \\t\\t\\t\\t\\t\\t};\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"deserialize\",\\n  \\t\\t\\t\\tvalue: function deserialize(object) {\\n\\n  \\t\\t\\t\\t\\t\\tvar result = this;\\n\\n  \\t\\t\\t\\t\\t\\tif (object !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.indices = object.indices;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.positions = object.positions;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.normals = object.normals;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.uvs = object.uvs;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.materials = object.materials;\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult = null;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"createTransferList\",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.indices.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.positions.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.normals.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.uvs.buffer);\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.materials.buffer);\\n\\n  \\t\\t\\t\\t\\t\\treturn transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Isosurface;\\n  }();\\n\\n  var cellProcFaceMask = [new Uint8Array([0, 4, 0]), new Uint8Array([1, 5, 0]), new Uint8Array([2, 6, 0]), new Uint8Array([3, 7, 0]), new Uint8Array([0, 2, 1]), new Uint8Array([4, 6, 1]), new Uint8Array([1, 3, 1]), new Uint8Array([5, 7, 1]), new Uint8Array([0, 1, 2]), new Uint8Array([2, 3, 2]), new Uint8Array([4, 5, 2]), new Uint8Array([6, 7, 2])];\\n\\n  var cellProcEdgeMask = [new Uint8Array([0, 1, 2, 3, 0]), new Uint8Array([4, 5, 6, 7, 0]), new Uint8Array([0, 4, 1, 5, 1]), new Uint8Array([2, 6, 3, 7, 1]), new Uint8Array([0, 2, 4, 6, 2]), new Uint8Array([1, 3, 5, 7, 2])];\\n\\n  var faceProcFaceMask = [[new Uint8Array([4, 0, 0]), new Uint8Array([5, 1, 0]), new Uint8Array([6, 2, 0]), new Uint8Array([7, 3, 0])], [new Uint8Array([2, 0, 1]), new Uint8Array([6, 4, 1]), new Uint8Array([3, 1, 1]), new Uint8Array([7, 5, 1])], [new Uint8Array([1, 0, 2]), new Uint8Array([3, 2, 2]), new Uint8Array([5, 4, 2]), new Uint8Array([7, 6, 2])]];\\n\\n  var faceProcEdgeMask = [[new Uint8Array([1, 4, 0, 5, 1, 1]), new Uint8Array([1, 6, 2, 7, 3, 1]), new Uint8Array([0, 4, 6, 0, 2, 2]), new Uint8Array([0, 5, 7, 1, 3, 2])], [new Uint8Array([0, 2, 3, 0, 1, 0]), new Uint8Array([0, 6, 7, 4, 5, 0]), new Uint8Array([1, 2, 0, 6, 4, 2]), new Uint8Array([1, 3, 1, 7, 5, 2])], [new Uint8Array([1, 1, 0, 3, 2, 0]), new Uint8Array([1, 5, 4, 7, 6, 0]), new Uint8Array([0, 1, 5, 0, 4, 1]), new Uint8Array([0, 3, 7, 2, 6, 1])]];\\n\\n  var edgeProcEdgeMask = [[new Uint8Array([3, 2, 1, 0, 0]), new Uint8Array([7, 6, 5, 4, 0])], [new Uint8Array([5, 1, 4, 0, 1]), new Uint8Array([7, 3, 6, 2, 1])], [new Uint8Array([6, 4, 2, 0, 2]), new Uint8Array([7, 5, 3, 1, 2])]];\\n\\n  var procEdgeMask = [new Uint8Array([3, 2, 1, 0]), new Uint8Array([7, 5, 6, 4]), new Uint8Array([11, 10, 9, 8])];\\n\\n  var MAX_VERTEX_COUNT = Math.pow(2, 16) - 1;\\n\\n  function contourProcessEdge(octants, dir, indexBuffer) {\\n\\n  \\tvar indices = [-1, -1, -1, -1];\\n  \\tvar signChange = [false, false, false, false];\\n\\n  \\tvar minSize = Infinity;\\n  \\tvar minIndex = 0;\\n  \\tvar flip = false;\\n\\n  \\tvar c1 = void 0,\\n  \\t    c2 = void 0,\\n  \\t    m1 = void 0,\\n  \\t    m2 = void 0;\\n  \\tvar octant = void 0,\\n  \\t    edge = void 0;\\n  \\tvar i = void 0;\\n\\n  \\tfor (i = 0; i < 4; ++i) {\\n\\n  \\t\\toctant = octants[i];\\n  \\t\\tedge = procEdgeMask[dir][i];\\n\\n  \\t\\tc1 = edges[edge][0];\\n  \\t\\tc2 = edges[edge][1];\\n\\n  \\t\\tm1 = octant.voxel.materials >> c1 & 1;\\n  \\t\\tm2 = octant.voxel.materials >> c2 & 1;\\n\\n  \\t\\tif (octant.size < minSize) {\\n\\n  \\t\\t\\tminSize = octant.size;\\n  \\t\\t\\tminIndex = i;\\n  \\t\\t\\tflip = m1 !== Material.AIR;\\n  \\t\\t}\\n\\n  \\t\\tindices[i] = octant.voxel.index;\\n  \\t\\tsignChange[i] = m1 !== m2;\\n  \\t}\\n\\n  \\tif (signChange[minIndex]) {\\n\\n  \\t\\tif (!flip) {\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[1]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n  \\t\\t\\tindexBuffer.push(indices[2]);\\n  \\t\\t} else {\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n  \\t\\t\\tindexBuffer.push(indices[1]);\\n\\n  \\t\\t\\tindexBuffer.push(indices[0]);\\n  \\t\\t\\tindexBuffer.push(indices[2]);\\n  \\t\\t\\tindexBuffer.push(indices[3]);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function contourEdgeProc(octants, dir, indexBuffer) {\\n\\n  \\tvar c = [0, 0, 0, 0];\\n\\n  \\tvar edgeOctants = void 0;\\n  \\tvar octant = void 0;\\n  \\tvar i = void 0,\\n  \\t    j = void 0;\\n\\n  \\tif (octants[0].voxel !== null && octants[1].voxel !== null && octants[2].voxel !== null && octants[3].voxel !== null) {\\n\\n  \\t\\tcontourProcessEdge(octants, dir, indexBuffer);\\n  \\t} else {\\n\\n  \\t\\tfor (i = 0; i < 2; ++i) {\\n\\n  \\t\\t\\tc[0] = edgeProcEdgeMask[dir][i][0];\\n  \\t\\t\\tc[1] = edgeProcEdgeMask[dir][i][1];\\n  \\t\\t\\tc[2] = edgeProcEdgeMask[dir][i][2];\\n  \\t\\t\\tc[3] = edgeProcEdgeMask[dir][i][3];\\n\\n  \\t\\t\\tedgeOctants = [];\\n\\n  \\t\\t\\tfor (j = 0; j < 4; ++j) {\\n\\n  \\t\\t\\t\\toctant = octants[j];\\n\\n  \\t\\t\\t\\tif (octant.voxel !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant;\\n  \\t\\t\\t\\t} else if (octant.children !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant.children[c[j]];\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (j === 4) {\\n\\n  \\t\\t\\t\\tcontourEdgeProc(edgeOctants, edgeProcEdgeMask[dir][i][4], indexBuffer);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function contourFaceProc(octants, dir, indexBuffer) {\\n\\n  \\tvar c = [0, 0, 0, 0];\\n\\n  \\tvar orders = [[0, 0, 1, 1], [0, 1, 0, 1]];\\n\\n  \\tvar faceOctants = void 0,\\n  \\t    edgeOctants = void 0;\\n  \\tvar order = void 0,\\n  \\t    octant = void 0;\\n  \\tvar i = void 0,\\n  \\t    j = void 0;\\n\\n  \\tif (octants[0].children !== null || octants[1].children !== null) {\\n\\n  \\t\\tfor (i = 0; i < 4; ++i) {\\n\\n  \\t\\t\\tc[0] = faceProcFaceMask[dir][i][0];\\n  \\t\\t\\tc[1] = faceProcFaceMask[dir][i][1];\\n\\n  \\t\\t\\tfaceOctants = [octants[0].children === null ? octants[0] : octants[0].children[c[0]], octants[1].children === null ? octants[1] : octants[1].children[c[1]]];\\n\\n  \\t\\t\\tcontourFaceProc(faceOctants, faceProcFaceMask[dir][i][2], indexBuffer);\\n  \\t\\t}\\n\\n  \\t\\tfor (i = 0; i < 4; ++i) {\\n\\n  \\t\\t\\tc[0] = faceProcEdgeMask[dir][i][1];\\n  \\t\\t\\tc[1] = faceProcEdgeMask[dir][i][2];\\n  \\t\\t\\tc[2] = faceProcEdgeMask[dir][i][3];\\n  \\t\\t\\tc[3] = faceProcEdgeMask[dir][i][4];\\n\\n  \\t\\t\\torder = orders[faceProcEdgeMask[dir][i][0]];\\n\\n  \\t\\t\\tedgeOctants = [];\\n\\n  \\t\\t\\tfor (j = 0; j < 4; ++j) {\\n\\n  \\t\\t\\t\\toctant = octants[order[j]];\\n\\n  \\t\\t\\t\\tif (octant.voxel !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant;\\n  \\t\\t\\t\\t} else if (octant.children !== null) {\\n\\n  \\t\\t\\t\\t\\tedgeOctants[j] = octant.children[c[j]];\\n  \\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\tbreak;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tif (j === 4) {\\n\\n  \\t\\t\\t\\tcontourEdgeProc(edgeOctants, faceProcEdgeMask[dir][i][5], indexBuffer);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function contourCellProc(octant, indexBuffer) {\\n\\n  \\tvar children = octant.children;\\n  \\tvar c = [0, 0, 0, 0];\\n\\n  \\tvar faceOctants = void 0,\\n  \\t    edgeOctants = void 0;\\n  \\tvar i = void 0;\\n\\n  \\tif (children !== null) {\\n\\n  \\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\tcontourCellProc(children[i], indexBuffer);\\n  \\t\\t}\\n\\n  \\t\\tfor (i = 0; i < 12; ++i) {\\n\\n  \\t\\t\\tc[0] = cellProcFaceMask[i][0];\\n  \\t\\t\\tc[1] = cellProcFaceMask[i][1];\\n\\n  \\t\\t\\tfaceOctants = [children[c[0]], children[c[1]]];\\n\\n  \\t\\t\\tcontourFaceProc(faceOctants, cellProcFaceMask[i][2], indexBuffer);\\n  \\t\\t}\\n\\n  \\t\\tfor (i = 0; i < 6; ++i) {\\n\\n  \\t\\t\\tc[0] = cellProcEdgeMask[i][0];\\n  \\t\\t\\tc[1] = cellProcEdgeMask[i][1];\\n  \\t\\t\\tc[2] = cellProcEdgeMask[i][2];\\n  \\t\\t\\tc[3] = cellProcEdgeMask[i][3];\\n\\n  \\t\\t\\tedgeOctants = [children[c[0]], children[c[1]], children[c[2]], children[c[3]]];\\n\\n  \\t\\t\\tcontourEdgeProc(edgeOctants, cellProcEdgeMask[i][4], indexBuffer);\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function generateVertexIndices(octant, positions, normals, index) {\\n\\n  \\tvar i = void 0,\\n  \\t    voxel = void 0;\\n\\n  \\tif (octant.children !== null) {\\n\\n  \\t\\tfor (i = 0; i < 8; ++i) {\\n\\n  \\t\\t\\tindex = generateVertexIndices(octant.children[i], positions, normals, index);\\n  \\t\\t}\\n  \\t} else if (octant.voxel !== null) {\\n\\n  \\t\\tvoxel = octant.voxel;\\n  \\t\\tvoxel.index = index;\\n\\n  \\t\\tpositions[index * 3] = voxel.position.x;\\n  \\t\\tpositions[index * 3 + 1] = voxel.position.y;\\n  \\t\\tpositions[index * 3 + 2] = voxel.position.z;\\n\\n  \\t\\tnormals[index * 3] = voxel.normal.x;\\n  \\t\\tnormals[index * 3 + 1] = voxel.normal.y;\\n  \\t\\tnormals[index * 3 + 2] = voxel.normal.z;\\n\\n  \\t\\t++index;\\n  \\t}\\n\\n  \\treturn index;\\n  }\\n\\n  var DualContouring = function () {\\n  \\tfunction DualContouring() {\\n  \\t\\tclassCallCheck(this, DualContouring);\\n  \\t}\\n\\n  \\tcreateClass(DualContouring, null, [{\\n  \\t\\tkey: \"run\",\\n  \\t\\tvalue: function run(svo) {\\n\\n  \\t\\t\\tvar indexBuffer = [];\\n\\n  \\t\\t\\tvar vertexCount = svo.voxelCount;\\n\\n  \\t\\t\\tvar result = null;\\n  \\t\\t\\tvar positions = null;\\n  \\t\\t\\tvar normals = null;\\n  \\t\\t\\tvar uvs = null;\\n  \\t\\t\\tvar materials = null;\\n\\n  \\t\\t\\tif (vertexCount > MAX_VERTEX_COUNT) {\\n\\n  \\t\\t\\t\\tconsole.warn(\"Could not create geometry for cell at position\", svo.min, \"(vertex count of\", vertexCount, \"exceeds limit of \", MAX_VERTEX_COUNT, \")\");\\n  \\t\\t\\t} else if (vertexCount > 0) {\\n\\n  \\t\\t\\t\\tpositions = new Float32Array(vertexCount * 3);\\n  \\t\\t\\t\\tnormals = new Float32Array(vertexCount * 3);\\n  \\t\\t\\t\\tuvs = new Float32Array(vertexCount * 2);\\n  \\t\\t\\t\\tmaterials = new Uint8Array(vertexCount);\\n\\n  \\t\\t\\t\\tgenerateVertexIndices(svo.root, positions, normals, 0);\\n  \\t\\t\\t\\tcontourCellProc(svo.root, indexBuffer);\\n\\n  \\t\\t\\t\\tresult = new Isosurface(new Uint16Array(indexBuffer), positions, normals, uvs, materials);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn DualContouring;\\n  }();\\n\\n  function getCell(cell, n, x, y, z) {\\n\\n  \\t\\tvar i = 0;\\n\\n  \\t\\tfor (n = n >> 1; n > 0; n >>= 1, i = 0) {\\n  \\t\\t\\t\\tif (x >= n) {\\n\\n  \\t\\t\\t\\t\\t\\ti += 4;x -= n;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (y >= n) {\\n\\n  \\t\\t\\t\\t\\t\\ti += 2;y -= n;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (z >= n) {\\n\\n  \\t\\t\\t\\t\\t\\ti += 1;z -= n;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (cell.children === null) {\\n\\n  \\t\\t\\t\\t\\t\\tcell.split();\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tcell = cell.children[i];\\n  \\t\\t}\\n\\n  \\t\\treturn cell;\\n  }\\n\\n  function createVoxel(n, x, y, z, materialIndices) {\\n\\n  \\t\\tvar m = n + 1;\\n  \\t\\tvar mm = m * m;\\n\\n  \\t\\tvar voxel = new Voxel();\\n\\n  \\t\\tvar materials = void 0,\\n  \\t\\t    edgeCount = void 0;\\n  \\t\\tvar material = void 0,\\n  \\t\\t    offset = void 0,\\n  \\t\\t    index = void 0;\\n  \\t\\tvar c1 = void 0,\\n  \\t\\t    c2 = void 0,\\n  \\t\\t    m1 = void 0,\\n  \\t\\t    m2 = void 0;\\n\\n  \\t\\tvar i = void 0;\\n\\n  \\t\\tfor (materials = 0, i = 0; i < 8; ++i) {\\n  \\t\\t\\t\\toffset = pattern[i];\\n  \\t\\t\\t\\tindex = (z + offset[2]) * mm + (y + offset[1]) * m + (x + offset[0]);\\n\\n  \\t\\t\\t\\tmaterial = Math.min(materialIndices[index], Material.SOLID);\\n\\n  \\t\\t\\t\\tmaterials |= material << i;\\n  \\t\\t}\\n\\n  \\t\\tfor (edgeCount = 0, i = 0; i < 12; ++i) {\\n\\n  \\t\\t\\t\\tc1 = edges[i][0];\\n  \\t\\t\\t\\tc2 = edges[i][1];\\n\\n  \\t\\t\\t\\tm1 = materials >> c1 & 1;\\n  \\t\\t\\t\\tm2 = materials >> c2 & 1;\\n\\n  \\t\\t\\t\\tif (m1 !== m2) {\\n\\n  \\t\\t\\t\\t\\t\\t++edgeCount;\\n  \\t\\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\tvoxel.materials = materials;\\n  \\t\\tvoxel.edgeCount = edgeCount;\\n  \\t\\tvoxel.qefData = new QEFData();\\n\\n  \\t\\treturn voxel;\\n  }\\n\\n  var SparseVoxelOctree = function (_Octree) {\\n  \\t\\tinherits(SparseVoxelOctree, _Octree);\\n\\n  \\t\\tfunction SparseVoxelOctree(data) {\\n  \\t\\t\\t\\tvar min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\\n  \\t\\t\\t\\tvar size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n  \\t\\t\\t\\tclassCallCheck(this, SparseVoxelOctree);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (SparseVoxelOctree.__proto__ || Object.getPrototypeOf(SparseVoxelOctree)).call(this));\\n\\n  \\t\\t\\t\\t_this.root = new VoxelCell(min, size);\\n\\n  \\t\\t\\t\\t_this.voxelCount = 0;\\n\\n  \\t\\t\\t\\tif (data !== null && data.edgeData !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.construct(data);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tif (VoxelCell.errorThreshold >= 0) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.simplify();\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SparseVoxelOctree, [{\\n  \\t\\t\\t\\tkey: \"simplify\",\\n  \\t\\t\\t\\tvalue: function simplify() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.voxelCount -= this.root.collapse();\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"construct\",\\n  \\t\\t\\t\\tvalue: function construct(data) {\\n\\n  \\t\\t\\t\\t\\t\\tvar n = HermiteData.resolution;\\n  \\t\\t\\t\\t\\t\\tvar edgeData = data.edgeData;\\n  \\t\\t\\t\\t\\t\\tvar materialIndices = data.materialIndices;\\n\\n  \\t\\t\\t\\t\\t\\tvar qefSolver = new QEFSolver();\\n  \\t\\t\\t\\t\\t\\tvar intersection = new Vector3();\\n\\n  \\t\\t\\t\\t\\t\\tvar edgeIterators = [edgeData.edgesX(this.min, this.root.size), edgeData.edgesY(this.min, this.root.size), edgeData.edgesZ(this.min, this.root.size)];\\n\\n  \\t\\t\\t\\t\\t\\tvar sequences = [new Uint8Array([0, 1, 2, 3]), new Uint8Array([0, 1, 4, 5]), new Uint8Array([0, 2, 4, 6])];\\n\\n  \\t\\t\\t\\t\\t\\tvar voxelCount = 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar edges = void 0,\\n  \\t\\t\\t\\t\\t\\t    edge = void 0;\\n  \\t\\t\\t\\t\\t\\tvar sequence = void 0,\\n  \\t\\t\\t\\t\\t\\t    offset = void 0;\\n  \\t\\t\\t\\t\\t\\tvar cell = void 0,\\n  \\t\\t\\t\\t\\t\\t    voxel = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar x = void 0,\\n  \\t\\t\\t\\t\\t\\t    y = void 0,\\n  \\t\\t\\t\\t\\t\\t    z = void 0;\\n  \\t\\t\\t\\t\\t\\tvar d = void 0,\\n  \\t\\t\\t\\t\\t\\t    i = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tfor (d = 0; d < 3; ++d) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tsequence = sequences[d];\\n  \\t\\t\\t\\t\\t\\t\\t\\tedges = edgeIterators[d];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar _iteratorNormalCompletion = true;\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar _didIteratorError = false;\\n  \\t\\t\\t\\t\\t\\t\\t\\tvar _iteratorError = undefined;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\ttry {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfor (var _iterator = edges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedge = _step.value;\\n\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tedge.computeZeroCrossingPosition(intersection);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfor (i = 0; i < 4; ++i) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\toffset = pattern[sequence[i]];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tx = edge.coordinates.x - offset[0];\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ty = edge.coordinates.y - offset[1];\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tz = edge.coordinates.z - offset[2];\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (x >= 0 && y >= 0 && z >= 0 && x < n && y < n && z < n) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcell = getCell(this.root, n, x, y, z);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (cell.voxel === null) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcell.voxel = createVoxel(n, x, y, z, materialIndices);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++voxelCount;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel = cell.voxel;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.normal.add(edge.n);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.qefData.add(intersection, edge.n);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (voxel.qefData.numPoints === voxel.edgeCount) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tqefSolver.setData(voxel.qefData).solve(voxel.position);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (!cell.contains(voxel.position)) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.position.copy(qefSolver.massPoint);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvoxel.normal.normalize();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t} catch (err) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_didIteratorError = true;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_iteratorError = err;\\n  \\t\\t\\t\\t\\t\\t\\t\\t} finally {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (!_iteratorNormalCompletion && _iterator.return) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t_iterator.return();\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} finally {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (_didIteratorError) {\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow _iteratorError;\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tthis.voxelCount = voxelCount;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SparseVoxelOctree;\\n  }(Octree);\\n\\n  var Action = {\\n\\n    EXTRACT: \"worker.extract\",\\n    MODIFY: \"worker.modify\",\\n    CONFIGURE: \"worker.config\",\\n    CLOSE: \"worker.close\"\\n\\n  };\\n\\n  var DataMessage = function (_Message) {\\n  \\tinherits(DataMessage, _Message);\\n\\n  \\tfunction DataMessage() {\\n  \\t\\tvar action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n  \\t\\tclassCallCheck(this, DataMessage);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (DataMessage.__proto__ || Object.getPrototypeOf(DataMessage)).call(this, action));\\n\\n  \\t\\t_this.data = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\treturn DataMessage;\\n  }(Message);\\n\\n  var ExtractionResponse = function (_DataMessage) {\\n  \\tinherits(ExtractionResponse, _DataMessage);\\n\\n  \\tfunction ExtractionResponse() {\\n  \\t\\tclassCallCheck(this, ExtractionResponse);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (ExtractionResponse.__proto__ || Object.getPrototypeOf(ExtractionResponse)).call(this, Action.EXTRACT));\\n\\n  \\t\\t_this.isosurface = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\treturn ExtractionResponse;\\n  }(DataMessage);\\n\\n  var data = new HermiteData(false);\\n\\n  var DataProcessor = function () {\\n  \\tfunction DataProcessor() {\\n  \\t\\tclassCallCheck(this, DataProcessor);\\n\\n\\n  \\t\\tthis.data = null;\\n\\n  \\t\\tthis.response = null;\\n  \\t}\\n\\n  \\tcreateClass(DataProcessor, [{\\n  \\t\\tkey: \"getData\",\\n  \\t\\tvalue: function getData() {\\n\\n  \\t\\t\\treturn this.data;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"respond\",\\n  \\t\\tvalue: function respond() {\\n\\n  \\t\\t\\tthis.response.data = this.data.serialize();\\n\\n  \\t\\t\\treturn this.response;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"createTransferList\",\\n  \\t\\tvalue: function createTransferList() {\\n  \\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\tif (this.data !== null) {\\n\\n  \\t\\t\\t\\tthis.data.createTransferList(transferList);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn transferList;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"process\",\\n  \\t\\tvalue: function process(request) {\\n\\n  \\t\\t\\tthis.data = data.deserialize(request.data);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn DataProcessor;\\n  }();\\n\\n  var SurfaceExtractor = function (_DataProcessor) {\\n  \\t\\tinherits(SurfaceExtractor, _DataProcessor);\\n\\n  \\t\\tfunction SurfaceExtractor() {\\n  \\t\\t\\t\\tclassCallCheck(this, SurfaceExtractor);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (SurfaceExtractor.__proto__ || Object.getPrototypeOf(SurfaceExtractor)).call(this));\\n\\n  \\t\\t\\t\\t_this.response = new ExtractionResponse();\\n\\n  \\t\\t\\t\\t_this.decompressionTarget = new HermiteData(false);\\n\\n  \\t\\t\\t\\t_this.isosurface = null;\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SurfaceExtractor, [{\\n  \\t\\t\\t\\tkey: \"respond\",\\n  \\t\\t\\t\\tvalue: function respond() {\\n\\n  \\t\\t\\t\\t\\t\\tvar response = get(SurfaceExtractor.prototype.__proto__ || Object.getPrototypeOf(SurfaceExtractor.prototype), \"respond\", this).call(this);\\n\\n  \\t\\t\\t\\t\\t\\tresponse.isosurface = this.isosurface !== null ? this.isosurface.serialise() : null;\\n\\n  \\t\\t\\t\\t\\t\\treturn response;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"createTransferList\",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\tget(SurfaceExtractor.prototype.__proto__ || Object.getPrototypeOf(SurfaceExtractor.prototype), \"createTransferList\", this).call(this, transferList);\\n\\n  \\t\\t\\t\\t\\t\\treturn this.isosurface !== null ? this.isosurface.createTransferList(transferList) : transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"process\",\\n  \\t\\t\\t\\tvalue: function process(request) {\\n  \\t\\t\\t\\t\\t\\tvar data = get(SurfaceExtractor.prototype.__proto__ || Object.getPrototypeOf(SurfaceExtractor.prototype), \"process\", this).call(this, request).getData();\\n\\n  \\t\\t\\t\\t\\t\\tvar svo = new SparseVoxelOctree(data.decompress(this.decompressionTarget));\\n\\n  \\t\\t\\t\\t\\t\\tthis.isosurface = DualContouring.run(svo);\\n\\n  \\t\\t\\t\\t\\t\\tthis.decompressionTarget.clear();\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SurfaceExtractor;\\n  }(DataProcessor);\\n\\n  var OperationType = {\\n\\n    UNION: \"csg.union\",\\n    DIFFERENCE: \"csg.difference\",\\n    INTERSECTION: \"csg.intersection\",\\n    DENSITY_FUNCTION: \"csg.densityfunction\"\\n\\n  };\\n\\n  var Operation = function () {\\n  \\t\\tfunction Operation(type) {\\n  \\t\\t\\t\\tclassCallCheck(this, Operation);\\n\\n\\n  \\t\\t\\t\\tthis.type = type;\\n\\n  \\t\\t\\t\\tfor (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n  \\t\\t\\t\\t\\t\\tchildren[_key - 1] = arguments[_key];\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tthis.children = children;\\n\\n  \\t\\t\\t\\tthis.bbox = null;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Operation, [{\\n  \\t\\t\\t\\tkey: \"computeBoundingBox\",\\n  \\t\\t\\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\t\\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tthis.bbox = new Box3();\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.bbox.union(children[i].boundingBox);\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this.bbox;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"boundingBox\",\\n  \\t\\t\\t\\tget: function get$$1() {\\n\\n  \\t\\t\\t\\t\\t\\treturn this.bbox !== null ? this.bbox : this.computeBoundingBox();\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Operation;\\n  }();\\n\\n  var Union = function (_Operation) {\\n  \\tinherits(Union, _Operation);\\n\\n  \\tfunction Union() {\\n  \\t\\tvar _ref;\\n\\n  \\t\\tclassCallCheck(this, Union);\\n\\n  \\t\\tfor (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\\n  \\t\\t\\tchildren[_key] = arguments[_key];\\n  \\t\\t}\\n\\n  \\t\\treturn possibleConstructorReturn(this, (_ref = Union.__proto__ || Object.getPrototypeOf(Union)).call.apply(_ref, [this, OperationType.UNION].concat(children)));\\n  \\t}\\n\\n  \\tcreateClass(Union, [{\\n  \\t\\tkey: \"updateMaterialIndex\",\\n  \\t\\tvalue: function updateMaterialIndex(index, data0, data1) {\\n\\n  \\t\\t\\tvar materialIndex = data1.materialIndices[index];\\n\\n  \\t\\t\\tif (materialIndex !== Material.AIR) {\\n\\n  \\t\\t\\t\\tdata0.setMaterialIndex(index, materialIndex);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"selectEdge\",\\n  \\t\\tvalue: function selectEdge(edge0, edge1, s) {\\n\\n  \\t\\t\\treturn s ? edge0.t > edge1.t ? edge0 : edge1 : edge0.t < edge1.t ? edge0 : edge1;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Union;\\n  }(Operation);\\n\\n  var Difference = function (_Operation) {\\n  \\tinherits(Difference, _Operation);\\n\\n  \\tfunction Difference() {\\n  \\t\\tvar _ref;\\n\\n  \\t\\tclassCallCheck(this, Difference);\\n\\n  \\t\\tfor (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\\n  \\t\\t\\tchildren[_key] = arguments[_key];\\n  \\t\\t}\\n\\n  \\t\\treturn possibleConstructorReturn(this, (_ref = Difference.__proto__ || Object.getPrototypeOf(Difference)).call.apply(_ref, [this, OperationType.DIFFERENCE].concat(children)));\\n  \\t}\\n\\n  \\tcreateClass(Difference, [{\\n  \\t\\tkey: \"updateMaterialIndex\",\\n  \\t\\tvalue: function updateMaterialIndex(index, data0, data1) {\\n\\n  \\t\\t\\tif (data1.materialIndices[index] !== Material.AIR) {\\n\\n  \\t\\t\\t\\tdata0.setMaterialIndex(index, Material.AIR);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"selectEdge\",\\n  \\t\\tvalue: function selectEdge(edge0, edge1, s) {\\n\\n  \\t\\t\\treturn s ? edge0.t < edge1.t ? edge0 : edge1 : edge0.t > edge1.t ? edge0 : edge1;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Difference;\\n  }(Operation);\\n\\n  var Intersection = function (_Operation) {\\n  \\tinherits(Intersection, _Operation);\\n\\n  \\tfunction Intersection() {\\n  \\t\\tvar _ref;\\n\\n  \\t\\tclassCallCheck(this, Intersection);\\n\\n  \\t\\tfor (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\\n  \\t\\t\\tchildren[_key] = arguments[_key];\\n  \\t\\t}\\n\\n  \\t\\treturn possibleConstructorReturn(this, (_ref = Intersection.__proto__ || Object.getPrototypeOf(Intersection)).call.apply(_ref, [this, OperationType.INTERSECTION].concat(children)));\\n  \\t}\\n\\n  \\tcreateClass(Intersection, [{\\n  \\t\\tkey: \"updateMaterialIndex\",\\n  \\t\\tvalue: function updateMaterialIndex(index, data0, data1) {\\n\\n  \\t\\t\\tvar materialIndex = data1.materialIndices[index];\\n\\n  \\t\\t\\tdata0.setMaterialIndex(index, data0.materialIndices[index] !== Material.AIR && materialIndex !== Material.AIR ? materialIndex : Material.AIR);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"selectEdge\",\\n  \\t\\tvalue: function selectEdge(edge0, edge1, s) {\\n\\n  \\t\\t\\treturn s ? edge0.t < edge1.t ? edge0 : edge1 : edge0.t > edge1.t ? edge0 : edge1;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn Intersection;\\n  }(Operation);\\n\\n  var cellSize = 0;\\n\\n  var cellPosition = new Vector3();\\n\\n  function computeIndexBounds(operation) {\\n\\n  \\tvar s = cellSize;\\n  \\tvar n = HermiteData.resolution;\\n\\n  \\tvar min = new Vector3(0, 0, 0);\\n  \\tvar max = new Vector3(n, n, n);\\n\\n  \\tvar region = new Box3(cellPosition, cellPosition.clone().addScalar(cellSize));\\n\\n  \\tif (operation.type !== OperationType.INTERSECTION) {\\n\\n  \\t\\tif (operation.boundingBox.intersectsBox(region)) {\\n\\n  \\t\\t\\tmin.copy(operation.boundingBox.min).max(region.min).sub(region.min);\\n\\n  \\t\\t\\tmin.x = Math.ceil(min.x * n / s);\\n  \\t\\t\\tmin.y = Math.ceil(min.y * n / s);\\n  \\t\\t\\tmin.z = Math.ceil(min.z * n / s);\\n\\n  \\t\\t\\tmax.copy(operation.boundingBox.max).min(region.max).sub(region.min);\\n\\n  \\t\\t\\tmax.x = Math.floor(max.x * n / s);\\n  \\t\\t\\tmax.y = Math.floor(max.y * n / s);\\n  \\t\\t\\tmax.z = Math.floor(max.z * n / s);\\n  \\t\\t} else {\\n  \\t\\t\\tmin.set(n, n, n);\\n  \\t\\t\\tmax.set(0, 0, 0);\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn new Box3(min, max);\\n  }\\n\\n  function combineMaterialIndices(operation, data0, data1, bounds) {\\n\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar X = bounds.max.x;\\n  \\tvar Y = bounds.max.y;\\n  \\tvar Z = bounds.max.z;\\n\\n  \\tvar x = void 0,\\n  \\t    y = void 0,\\n  \\t    z = void 0;\\n\\n  \\tfor (z = bounds.min.z; z <= Z; ++z) {\\n\\n  \\t\\tfor (y = bounds.min.y; y <= Y; ++y) {\\n\\n  \\t\\t\\tfor (x = bounds.min.x; x <= X; ++x) {\\n\\n  \\t\\t\\t\\toperation.updateMaterialIndex(z * mm + y * m + x, data0, data1);\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n  }\\n\\n  function generateMaterialIndices(operation, data, bounds) {\\n\\n  \\tvar s = cellSize;\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar materialIndices = data.materialIndices;\\n\\n  \\tvar base = cellPosition;\\n  \\tvar offset = new Vector3();\\n  \\tvar position = new Vector3();\\n\\n  \\tvar X = bounds.max.x;\\n  \\tvar Y = bounds.max.y;\\n  \\tvar Z = bounds.max.z;\\n\\n  \\tvar materialIndex = void 0;\\n  \\tvar materials = 0;\\n\\n  \\tvar x = void 0,\\n  \\t    y = void 0,\\n  \\t    z = void 0;\\n\\n  \\tfor (z = bounds.min.z; z <= Z; ++z) {\\n\\n  \\t\\toffset.z = z * s / n;\\n\\n  \\t\\tfor (y = bounds.min.y; y <= Y; ++y) {\\n\\n  \\t\\t\\toffset.y = y * s / n;\\n\\n  \\t\\t\\tfor (x = bounds.min.x; x <= X; ++x) {\\n\\n  \\t\\t\\t\\toffset.x = x * s / n;\\n\\n  \\t\\t\\t\\tmaterialIndex = operation.generateMaterialIndex(position.addVectors(base, offset));\\n\\n  \\t\\t\\t\\tif (materialIndex !== Material.AIR) {\\n\\n  \\t\\t\\t\\t\\tmaterialIndices[z * mm + y * m + x] = materialIndex;\\n\\n  \\t\\t\\t\\t\\t++materials;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n  \\t}\\n\\n  \\tdata.materials = materials;\\n  }\\n\\n  function combineEdges(operation, data0, data1) {\\n\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar indexOffsets = new Uint32Array([1, m, mm]);\\n  \\tvar materialIndices = data0.materialIndices;\\n\\n  \\tvar edge1 = new Edge();\\n  \\tvar edge0 = new Edge();\\n\\n  \\tvar edgeData1 = data1.edgeData;\\n  \\tvar edgeData0 = data0.edgeData;\\n\\n  \\tvar lengths = new Uint32Array(3);\\n  \\tvar edgeCount = EdgeData.calculate1DEdgeCount(n);\\n\\n  \\tvar edgeData = new EdgeData(Math.min(edgeCount, edgeData0.indices[0].length + edgeData1.indices[0].length), Math.min(edgeCount, edgeData0.indices[1].length + edgeData1.indices[1].length), Math.min(edgeCount, edgeData0.indices[2].length + edgeData1.indices[2].length));\\n\\n  \\tvar edges1 = void 0,\\n  \\t    zeroCrossings1 = void 0,\\n  \\t    normals1 = void 0;\\n  \\tvar edges0 = void 0,\\n  \\t    zeroCrossings0 = void 0,\\n  \\t    normals0 = void 0;\\n  \\tvar edges = void 0,\\n  \\t    zeroCrossings = void 0,\\n  \\t    normals = void 0;\\n  \\tvar indexOffset = void 0;\\n\\n  \\tvar indexA1 = void 0,\\n  \\t    indexB1 = void 0;\\n  \\tvar indexA0 = void 0,\\n  \\t    indexB0 = void 0;\\n\\n  \\tvar m1 = void 0,\\n  \\t    m2 = void 0;\\n  \\tvar edge = void 0;\\n\\n  \\tvar c = void 0,\\n  \\t    d = void 0,\\n  \\t    i = void 0,\\n  \\t    j = void 0,\\n  \\t    il = void 0,\\n  \\t    jl = void 0;\\n\\n  \\tfor (c = 0, d = 0; d < 3; c = 0, ++d) {\\n\\n  \\t\\tedges1 = edgeData1.indices[d];\\n  \\t\\tedges0 = edgeData0.indices[d];\\n  \\t\\tedges = edgeData.indices[d];\\n\\n  \\t\\tzeroCrossings1 = edgeData1.zeroCrossings[d];\\n  \\t\\tzeroCrossings0 = edgeData0.zeroCrossings[d];\\n  \\t\\tzeroCrossings = edgeData.zeroCrossings[d];\\n\\n  \\t\\tnormals1 = edgeData1.normals[d];\\n  \\t\\tnormals0 = edgeData0.normals[d];\\n  \\t\\tnormals = edgeData.normals[d];\\n\\n  \\t\\tindexOffset = indexOffsets[d];\\n\\n  \\t\\til = edges1.length;\\n  \\t\\tjl = edges0.length;\\n\\n  \\t\\tfor (i = 0, j = 0; i < il; ++i) {\\n\\n  \\t\\t\\tindexA1 = edges1[i];\\n  \\t\\t\\tindexB1 = indexA1 + indexOffset;\\n\\n  \\t\\t\\tm1 = materialIndices[indexA1];\\n  \\t\\t\\tm2 = materialIndices[indexB1];\\n\\n  \\t\\t\\tif (m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\\n\\n  \\t\\t\\t\\tedge1.t = zeroCrossings1[i];\\n  \\t\\t\\t\\tedge1.n.x = normals1[i * 3];\\n  \\t\\t\\t\\tedge1.n.y = normals1[i * 3 + 1];\\n  \\t\\t\\t\\tedge1.n.z = normals1[i * 3 + 2];\\n\\n  \\t\\t\\t\\tif (operation.type === OperationType.DIFFERENCE) {\\n\\n  \\t\\t\\t\\t\\tedge1.n.negate();\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tedge = edge1;\\n\\n  \\t\\t\\t\\twhile (j < jl && edges0[j] <= indexA1) {\\n\\n  \\t\\t\\t\\t\\tindexA0 = edges0[j];\\n  \\t\\t\\t\\t\\tindexB0 = indexA0 + indexOffset;\\n\\n  \\t\\t\\t\\t\\tedge0.t = zeroCrossings0[j];\\n  \\t\\t\\t\\t\\tedge0.n.x = normals0[j * 3];\\n  \\t\\t\\t\\t\\tedge0.n.y = normals0[j * 3 + 1];\\n  \\t\\t\\t\\t\\tedge0.n.z = normals0[j * 3 + 2];\\n\\n  \\t\\t\\t\\t\\tm1 = materialIndices[indexA0];\\n\\n  \\t\\t\\t\\t\\tif (indexA0 < indexA1) {\\n\\n  \\t\\t\\t\\t\\t\\tm2 = materialIndices[indexB0];\\n\\n  \\t\\t\\t\\t\\t\\tif (m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\\n  \\t\\t\\t\\t\\t\\t\\tedges[c] = indexA0;\\n  \\t\\t\\t\\t\\t\\t\\tzeroCrossings[c] = edge0.t;\\n  \\t\\t\\t\\t\\t\\t\\tnormals[c * 3] = edge0.n.x;\\n  \\t\\t\\t\\t\\t\\t\\tnormals[c * 3 + 1] = edge0.n.y;\\n  \\t\\t\\t\\t\\t\\t\\tnormals[c * 3 + 2] = edge0.n.z;\\n\\n  \\t\\t\\t\\t\\t\\t\\t++c;\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t\\t} else {\\n  \\t\\t\\t\\t\\t\\tedge = operation.selectEdge(edge0, edge1, m1 === Material.SOLID);\\n  \\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t++j;\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tedges[c] = indexA1;\\n  \\t\\t\\t\\tzeroCrossings[c] = edge.t;\\n  \\t\\t\\t\\tnormals[c * 3] = edge.n.x;\\n  \\t\\t\\t\\tnormals[c * 3 + 1] = edge.n.y;\\n  \\t\\t\\t\\tnormals[c * 3 + 2] = edge.n.z;\\n\\n  \\t\\t\\t\\t++c;\\n  \\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\twhile (j < jl) {\\n\\n  \\t\\t\\tindexA0 = edges0[j];\\n  \\t\\t\\tindexB0 = indexA0 + indexOffset;\\n\\n  \\t\\t\\tm1 = materialIndices[indexA0];\\n  \\t\\t\\tm2 = materialIndices[indexB0];\\n\\n  \\t\\t\\tif (m1 !== m2 && (m1 === Material.AIR || m2 === Material.AIR)) {\\n\\n  \\t\\t\\t\\tedges[c] = indexA0;\\n  \\t\\t\\t\\tzeroCrossings[c] = zeroCrossings0[j];\\n  \\t\\t\\t\\tnormals[c * 3] = normals0[j * 3];\\n  \\t\\t\\t\\tnormals[c * 3 + 1] = normals0[j * 3 + 1];\\n  \\t\\t\\t\\tnormals[c * 3 + 2] = normals0[j * 3 + 2];\\n\\n  \\t\\t\\t\\t++c;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\t++j;\\n  \\t\\t}\\n\\n  \\t\\tlengths[d] = c;\\n  \\t}\\n\\n  \\treturn { edgeData: edgeData, lengths: lengths };\\n  }\\n\\n  function generateEdges(operation, data, bounds) {\\n\\n  \\tvar s = cellSize;\\n  \\tvar n = HermiteData.resolution;\\n  \\tvar m = n + 1;\\n  \\tvar mm = m * m;\\n\\n  \\tvar indexOffsets = new Uint32Array([1, m, mm]);\\n  \\tvar materialIndices = data.materialIndices;\\n\\n  \\tvar base = cellPosition;\\n  \\tvar offsetA = new Vector3();\\n  \\tvar offsetB = new Vector3();\\n  \\tvar edge = new Edge();\\n\\n  \\tvar lengths = new Uint32Array(3);\\n  \\tvar edgeData = new EdgeData(EdgeData.calculate1DEdgeCount(n));\\n\\n  \\tvar edges = void 0,\\n  \\t    zeroCrossings = void 0,\\n  \\t    normals = void 0,\\n  \\t    indexOffset = void 0;\\n  \\tvar indexA = void 0,\\n  \\t    indexB = void 0;\\n\\n  \\tvar minX = void 0,\\n  \\t    minY = void 0,\\n  \\t    minZ = void 0;\\n  \\tvar maxX = void 0,\\n  \\t    maxY = void 0,\\n  \\t    maxZ = void 0;\\n\\n  \\tvar c = void 0,\\n  \\t    d = void 0,\\n  \\t    a = void 0,\\n  \\t    axis = void 0;\\n  \\tvar x = void 0,\\n  \\t    y = void 0,\\n  \\t    z = void 0;\\n\\n  \\tfor (a = 4, c = 0, d = 0; d < 3; a >>= 1, c = 0, ++d) {\\n  \\t\\taxis = pattern[a];\\n\\n  \\t\\tedges = edgeData.indices[d];\\n  \\t\\tzeroCrossings = edgeData.zeroCrossings[d];\\n  \\t\\tnormals = edgeData.normals[d];\\n  \\t\\tindexOffset = indexOffsets[d];\\n\\n  \\t\\tminX = bounds.min.x;maxX = bounds.max.x;\\n  \\t\\tminY = bounds.min.y;maxY = bounds.max.y;\\n  \\t\\tminZ = bounds.min.z;maxZ = bounds.max.z;\\n\\n  \\t\\tswitch (d) {\\n\\n  \\t\\t\\tcase 0:\\n  \\t\\t\\t\\tminX = Math.max(minX - 1, 0);\\n  \\t\\t\\t\\tmaxX = Math.min(maxX, n - 1);\\n  \\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\tcase 1:\\n  \\t\\t\\t\\tminY = Math.max(minY - 1, 0);\\n  \\t\\t\\t\\tmaxY = Math.min(maxY, n - 1);\\n  \\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\tcase 2:\\n  \\t\\t\\t\\tminZ = Math.max(minZ - 1, 0);\\n  \\t\\t\\t\\tmaxZ = Math.min(maxZ, n - 1);\\n  \\t\\t\\t\\tbreak;\\n\\n  \\t\\t}\\n\\n  \\t\\tfor (z = minZ; z <= maxZ; ++z) {\\n\\n  \\t\\t\\tfor (y = minY; y <= maxY; ++y) {\\n\\n  \\t\\t\\t\\tfor (x = minX; x <= maxX; ++x) {\\n\\n  \\t\\t\\t\\t\\tindexA = z * mm + y * m + x;\\n  \\t\\t\\t\\t\\tindexB = indexA + indexOffset;\\n\\n  \\t\\t\\t\\t\\tif (materialIndices[indexA] !== materialIndices[indexB]) {\\n\\n  \\t\\t\\t\\t\\t\\toffsetA.set(x * s / n, y * s / n, z * s / n);\\n\\n  \\t\\t\\t\\t\\t\\toffsetB.set((x + axis[0]) * s / n, (y + axis[1]) * s / n, (z + axis[2]) * s / n);\\n\\n  \\t\\t\\t\\t\\t\\tedge.a.addVectors(base, offsetA);\\n  \\t\\t\\t\\t\\t\\tedge.b.addVectors(base, offsetB);\\n\\n  \\t\\t\\t\\t\\t\\toperation.generateEdge(edge);\\n\\n  \\t\\t\\t\\t\\t\\tedges[c] = indexA;\\n  \\t\\t\\t\\t\\t\\tzeroCrossings[c] = edge.t;\\n  \\t\\t\\t\\t\\t\\tnormals[c * 3] = edge.n.x;\\n  \\t\\t\\t\\t\\t\\tnormals[c * 3 + 1] = edge.n.y;\\n  \\t\\t\\t\\t\\t\\tnormals[c * 3 + 2] = edge.n.z;\\n\\n  \\t\\t\\t\\t\\t\\t++c;\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t}\\n  \\t\\t}\\n\\n  \\t\\tlengths[d] = c;\\n  \\t}\\n\\n  \\treturn { edgeData: edgeData, lengths: lengths };\\n  }\\n\\n  function update(operation, data0, data1) {\\n\\n  \\tvar bounds = computeIndexBounds(operation);\\n\\n  \\tvar result = void 0,\\n  \\t    edgeData = void 0,\\n  \\t    lengths = void 0,\\n  \\t    d = void 0;\\n  \\tvar done = false;\\n\\n  \\tif (operation.type === OperationType.DENSITY_FUNCTION) {\\n\\n  \\t\\tgenerateMaterialIndices(operation, data0, bounds);\\n  \\t} else if (data0.empty) {\\n\\n  \\t\\tif (operation.type === OperationType.UNION) {\\n\\n  \\t\\t\\tdata0.set(data1);\\n  \\t\\t\\tdone = true;\\n  \\t\\t}\\n  \\t} else {\\n\\n  \\t\\tif (!(data0.full && operation.type === OperationType.UNION)) {\\n\\n  \\t\\t\\tcombineMaterialIndices(operation, data0, data1, bounds);\\n  \\t\\t}\\n  \\t}\\n\\n  \\tif (!done && !data0.empty && !data0.full) {\\n\\n  \\t\\tresult = operation.type === OperationType.DENSITY_FUNCTION ? generateEdges(operation, data0, bounds) : combineEdges(operation, data0, data1);\\n\\n  \\t\\tedgeData = result.edgeData;\\n  \\t\\tlengths = result.lengths;\\n\\n  \\t\\tfor (d = 0; d < 3; ++d) {\\n\\n  \\t\\t\\tedgeData.indices[d] = edgeData.indices[d].slice(0, lengths[d]);\\n  \\t\\t\\tedgeData.zeroCrossings[d] = edgeData.zeroCrossings[d].slice(0, lengths[d]);\\n  \\t\\t\\tedgeData.normals[d] = edgeData.normals[d].slice(0, lengths[d] * 3);\\n  \\t\\t}\\n\\n  \\t\\tdata0.edgeData = edgeData;\\n  \\t}\\n  }\\n\\n  function execute(operation) {\\n\\n  \\tvar children = operation.children;\\n\\n  \\tvar result = void 0,\\n  \\t    data = void 0;\\n  \\tvar i = void 0,\\n  \\t    l = void 0;\\n\\n  \\tif (operation.type === OperationType.DENSITY_FUNCTION) {\\n  \\t\\tresult = new HermiteData();\\n\\n  \\t\\tupdate(operation, result);\\n  \\t}\\n\\n  \\tfor (i = 0, l = children.length; i < l; ++i) {\\n  \\t\\tdata = execute(children[i]);\\n\\n  \\t\\tif (result === undefined) {\\n\\n  \\t\\t\\tresult = data;\\n  \\t\\t} else if (data !== null) {\\n\\n  \\t\\t\\tif (result === null) {\\n\\n  \\t\\t\\t\\tif (operation.type === OperationType.UNION) {\\n  \\t\\t\\t\\t\\tresult = data;\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n  \\t\\t\\t\\tupdate(operation, result, data);\\n  \\t\\t\\t}\\n  \\t\\t} else if (operation.type === OperationType.INTERSECTION) {\\n  \\t\\t\\tresult = null;\\n  \\t\\t}\\n\\n  \\t\\tif (result === null && operation.type !== OperationType.UNION) {\\n  \\t\\t\\tbreak;\\n  \\t\\t}\\n  \\t}\\n\\n  \\treturn result !== null && result.empty ? null : result;\\n  }\\n\\n  var ConstructiveSolidGeometry = function () {\\n  \\tfunction ConstructiveSolidGeometry() {\\n  \\t\\tclassCallCheck(this, ConstructiveSolidGeometry);\\n  \\t}\\n\\n  \\tcreateClass(ConstructiveSolidGeometry, null, [{\\n  \\t\\tkey: \"run\",\\n  \\t\\tvalue: function run(min, size, data, sdf) {\\n\\n  \\t\\t\\tcellPosition.fromArray(min);\\n  \\t\\t\\tcellSize = size;\\n\\n  \\t\\t\\tif (data === null) {\\n\\n  \\t\\t\\t\\tif (sdf.operation === OperationType.UNION) {\\n  \\t\\t\\t\\t\\tdata = new HermiteData(false);\\n  \\t\\t\\t\\t}\\n  \\t\\t\\t} else {\\n\\n  \\t\\t\\t\\tdata.decompress();\\n  \\t\\t\\t}\\n\\n  \\t\\t\\tvar operation = sdf.toCSG();\\n\\n  \\t\\t\\tvar generatedData = data !== null ? execute(operation) : null;\\n\\n  \\t\\t\\tif (generatedData !== null) {\\n  \\t\\t\\t\\tswitch (sdf.operation) {\\n\\n  \\t\\t\\t\\t\\tcase OperationType.UNION:\\n  \\t\\t\\t\\t\\t\\toperation = new Union(operation);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase OperationType.DIFFERENCE:\\n  \\t\\t\\t\\t\\t\\toperation = new Difference(operation);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\tcase OperationType.INTERSECTION:\\n  \\t\\t\\t\\t\\t\\toperation = new Intersection(operation);\\n  \\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\tupdate(operation, data, generatedData);\\n\\n  \\t\\t\\t\\tdata.contoured = false;\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn data !== null && data.empty ? null : data;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn ConstructiveSolidGeometry;\\n  }();\\n\\n  var ISOVALUE = 0.0;\\n\\n  var DensityFunction = function (_Operation) {\\n  \\tinherits(DensityFunction, _Operation);\\n\\n  \\tfunction DensityFunction(sdf) {\\n  \\t\\tclassCallCheck(this, DensityFunction);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (DensityFunction.__proto__ || Object.getPrototypeOf(DensityFunction)).call(this, OperationType.DENSITY_FUNCTION));\\n\\n  \\t\\t_this.sdf = sdf;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(DensityFunction, [{\\n  \\t\\tkey: \"computeBoundingBox\",\\n  \\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\tthis.bbox = this.sdf.computeBoundingBox();\\n\\n  \\t\\t\\treturn this.bbox;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"generateMaterialIndex\",\\n  \\t\\tvalue: function generateMaterialIndex(position) {\\n\\n  \\t\\t\\treturn this.sdf.sample(position) <= ISOVALUE ? this.sdf.material : Material.AIR;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"generateEdge\",\\n  \\t\\tvalue: function generateEdge(edge) {\\n\\n  \\t\\t\\tedge.approximateZeroCrossing(this.sdf);\\n  \\t\\t\\tedge.computeSurfaceNormal(this.sdf);\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn DensityFunction;\\n  }(Operation);\\n\\n  var SignedDistanceFunction = function () {\\n  \\tfunction SignedDistanceFunction(type) {\\n  \\t\\tvar material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Material.SOLID;\\n  \\t\\tclassCallCheck(this, SignedDistanceFunction);\\n\\n\\n  \\t\\tthis.type = type;\\n\\n  \\t\\tthis.operation = null;\\n\\n  \\t\\tthis.material = Math.min(255, Math.max(Material.SOLID, Math.trunc(material)));\\n\\n  \\t\\tthis.children = [];\\n\\n  \\t\\tthis.bbox = null;\\n  \\t}\\n\\n  \\tcreateClass(SignedDistanceFunction, [{\\n  \\t\\tkey: \"setOperationType\",\\n  \\t\\tvalue: function setOperationType(operation) {\\n\\n  \\t\\t\\tthis.operation = operation;\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"union\",\\n  \\t\\tvalue: function union(sdf) {\\n\\n  \\t\\t\\tsdf.operation = OperationType.UNION;\\n  \\t\\t\\tthis.children.push(sdf);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"subtract\",\\n  \\t\\tvalue: function subtract(sdf) {\\n\\n  \\t\\t\\tsdf.operation = OperationType.DIFFERENCE;\\n  \\t\\t\\tthis.children.push(sdf);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"intersect\",\\n  \\t\\tvalue: function intersect(sdf) {\\n\\n  \\t\\t\\tsdf.operation = OperationType.INTERSECTION;\\n  \\t\\t\\tthis.children.push(sdf);\\n\\n  \\t\\t\\treturn this;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toCSG\",\\n  \\t\\tvalue: function toCSG() {\\n\\n  \\t\\t\\tvar children = this.children;\\n\\n  \\t\\t\\tvar operation = new DensityFunction(this);\\n  \\t\\t\\tvar operationType = void 0;\\n  \\t\\t\\tvar child = void 0;\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tchild = children[i];\\n\\n  \\t\\t\\t\\tif (operationType !== child.operation) {\\n\\n  \\t\\t\\t\\t\\toperationType = child.operation;\\n\\n  \\t\\t\\t\\t\\tswitch (operationType) {\\n\\n  \\t\\t\\t\\t\\t\\tcase OperationType.UNION:\\n  \\t\\t\\t\\t\\t\\t\\toperation = new Union(operation);\\n  \\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\tcase OperationType.DIFFERENCE:\\n  \\t\\t\\t\\t\\t\\t\\toperation = new Difference(operation);\\n  \\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\tcase OperationType.INTERSECTION:\\n  \\t\\t\\t\\t\\t\\t\\toperation = new Intersection(operation);\\n  \\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\toperation.children.push(child.toCSG());\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn operation;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"serialize\",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\tvar deflate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n\\n  \\t\\t\\tvar result = {\\n  \\t\\t\\t\\ttype: this.type,\\n  \\t\\t\\t\\toperation: this.operation,\\n  \\t\\t\\t\\tmaterial: this.material,\\n  \\t\\t\\t\\tparameters: null,\\n  \\t\\t\\t\\tchildren: []\\n  \\t\\t\\t};\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tfor (i = 0, l = this.children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tresult.children.push(this.children[i].serialize(deflate));\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"createTransferList\",\\n  \\t\\tvalue: function createTransferList() {\\n  \\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\treturn transferList;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"toJSON\",\\n  \\t\\tvalue: function toJSON() {\\n\\n  \\t\\t\\treturn this.serialize(true);\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"computeBoundingBox\",\\n  \\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\tthrow new Error(\"SignedDistanceFunction#computeBoundingBox method not implemented!\");\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"sample\",\\n  \\t\\tvalue: function sample(position) {\\n\\n  \\t\\t\\tthrow new Error(\"SignedDistanceFunction#sample method not implemented!\");\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"boundingBox\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\treturn this.bbox !== null ? this.bbox : this.computeBoundingBox();\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"completeBoundingBox\",\\n  \\t\\tget: function get$$1() {\\n\\n  \\t\\t\\tvar children = this.children;\\n  \\t\\t\\tvar bbox = this.boundingBox.clone();\\n\\n  \\t\\t\\tvar i = void 0,\\n  \\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\tfor (i = 0, l = children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\tbbox.union(children[i].completeBoundingBox);\\n  \\t\\t\\t}\\n\\n  \\t\\t\\treturn bbox;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn SignedDistanceFunction;\\n  }();\\n\\n  var SDFType = {\\n\\n    HEIGHTFIELD: \"sdf.heightfield\",\\n    FRACTAL_NOISE: \"sdf.fractalnoise\",\\n    SUPER_PRIMITIVE: \"sdf.superprimitive\"\\n\\n  };\\n\\n  var FractalNoise = function (_SignedDistanceFuncti) {\\n  \\tinherits(FractalNoise, _SignedDistanceFuncti);\\n\\n  \\tfunction FractalNoise() {\\n  \\t\\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  \\t\\tvar material = arguments[1];\\n  \\t\\tclassCallCheck(this, FractalNoise);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (FractalNoise.__proto__ || Object.getPrototypeOf(FractalNoise)).call(this, SDFType.PERLIN_NOISE, material));\\n\\n  \\t\\t_this.min = new (Function.prototype.bind.apply(Vector3, [null].concat(toConsumableArray(parameters.min))))();\\n\\n  \\t\\t_this.max = new (Function.prototype.bind.apply(Vector3, [null].concat(toConsumableArray(parameters.max))))();\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\tcreateClass(FractalNoise, [{\\n  \\t\\tkey: \"computeBoundingBox\",\\n  \\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\tthis.bbox = new Box3(this.min, this.max);\\n\\n  \\t\\t\\treturn this.bbox;\\n  \\t\\t}\\n  \\t}, {\\n  \\t\\tkey: \"sample\",\\n  \\t\\tvalue: function sample(position) {}\\n  \\t}, {\\n  \\t\\tkey: \"serialize\",\\n  \\t\\tvalue: function serialize() {\\n  \\t\\t\\tvar result = get(FractalNoise.prototype.__proto__ || Object.getPrototypeOf(FractalNoise.prototype), \"serialize\", this).call(this);\\n\\n  \\t\\t\\tresult.parameters = {\\n  \\t\\t\\t\\tmin: this.min.toArray(),\\n  \\t\\t\\t\\tmax: this.max.toArray()\\n  \\t\\t\\t};\\n\\n  \\t\\t\\treturn result;\\n  \\t\\t}\\n  \\t}]);\\n  \\treturn FractalNoise;\\n  }(SignedDistanceFunction);\\n\\n  function readImageData(image) {\\n\\n  \\t\\tvar canvas = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\\n  \\t\\tvar context = canvas.getContext(\"2d\");\\n\\n  \\t\\tcontext.drawImage(image, 0, 0);\\n\\n  \\t\\treturn context.getImageData(0, 0, image.width, image.height);\\n  }\\n\\n  var Heightfield = function (_SignedDistanceFuncti) {\\n  \\t\\tinherits(Heightfield, _SignedDistanceFuncti);\\n\\n  \\t\\tfunction Heightfield() {\\n  \\t\\t\\t\\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  \\t\\t\\t\\tvar material = arguments[1];\\n  \\t\\t\\t\\tclassCallCheck(this, Heightfield);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (Heightfield.__proto__ || Object.getPrototypeOf(Heightfield)).call(this, SDFType.HEIGHTFIELD, material));\\n\\n  \\t\\t\\t\\t_this.min = new Vector3(0, 0, 0);\\n\\n  \\t\\t\\t\\tif (parameters.min !== undefined) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.min.fromArray(parameters.min);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t_this.size = new Vector3(1, 1, 1);\\n\\n  \\t\\t\\t\\tif (parameters.size !== undefined) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.size.fromArray(parameters.size);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t_this.scale = new Vector3(1, 1, 1);\\n\\n  \\t\\t\\t\\tif (parameters.scale !== undefined) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.scale.fromArray(parameters.scale);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t_this.dimensions = new Vector3();\\n  \\t\\t\\t\\t_this.dimensions.multiplyVectors(_this.size, _this.scale);\\n\\n  \\t\\t\\t\\t_this.data = parameters.data;\\n\\n  \\t\\t\\t\\t_this.heightmap = null;\\n\\n  \\t\\t\\t\\tif (parameters.image !== undefined) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.fromImage(parameters.image);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(Heightfield, [{\\n  \\t\\t\\t\\tkey: \"fromImage\",\\n  \\t\\t\\t\\tvalue: function fromImage(image) {\\n\\n  \\t\\t\\t\\t\\t\\tvar imageData = typeof document === \"undefined\" ? null : readImageData(image);\\n\\n  \\t\\t\\t\\t\\t\\tvar result = null;\\n  \\t\\t\\t\\t\\t\\tvar data = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tvar i = void 0,\\n  \\t\\t\\t\\t\\t\\t    j = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tif (imageData !== null) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tdata = imageData.data;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tresult = new Uint8ClampedArray(data.length / 4);\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tfor (i = 0, j = 0, l = data.length; i < l; ++i, j += 4) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresult[i] = data[j];\\n  \\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.heightmap = image;\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.size.set(imageData.width, 1.0, imageData.height);\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.dimensions.multiplyVectors(this.size, this.scale);\\n  \\t\\t\\t\\t\\t\\t\\t\\tthis.data = result;\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"computeBoundingBox\",\\n  \\t\\t\\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\t\\t\\t\\tthis.bbox = new Box3();\\n\\n  \\t\\t\\t\\t\\t\\tthis.bbox.min.copy(this.min);\\n  \\t\\t\\t\\t\\t\\tthis.bbox.max.addVectors(this.min, this.dimensions);\\n\\n  \\t\\t\\t\\t\\t\\treturn this.bbox;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"sample\",\\n  \\t\\t\\t\\tvalue: function sample(position) {\\n\\n  \\t\\t\\t\\t\\t\\tvar scale = this.scale;\\n  \\t\\t\\t\\t\\t\\tvar x = position.x / scale.x;\\n  \\t\\t\\t\\t\\t\\tvar z = position.z / scale.z;\\n  \\t\\t\\t\\t\\t\\tvar h = this.min.y + this.data[z * this.size.x + x] / 255 * this.dimensions.y;\\n\\n  \\t\\t\\t\\t\\t\\treturn position.y - h;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"serialize\",\\n  \\t\\t\\t\\tvalue: function serialize() {\\n  \\t\\t\\t\\t\\t\\tvar deflate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar result = get(Heightfield.prototype.__proto__ || Object.getPrototypeOf(Heightfield.prototype), \"serialize\", this).call(this);\\n\\n  \\t\\t\\t\\t\\t\\tresult.parameters = {\\n  \\t\\t\\t\\t\\t\\t\\t\\tmin: this.min.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tscale: this.scale.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tsize: this.size.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tdata: deflate ? null : this.data,\\n  \\t\\t\\t\\t\\t\\t\\t\\tdataUrl: deflate && this.heightmap !== null ? this.heightmap.toDataUrl() : null,\\n  \\t\\t\\t\\t\\t\\t\\t\\timage: null\\n  \\t\\t\\t\\t\\t\\t};\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"createTransferList\",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\ttransferList.push(this.data.buffer);\\n\\n  \\t\\t\\t\\t\\t\\treturn transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn Heightfield;\\n  }(SignedDistanceFunction);\\n\\n  var SuperPrimitive = function (_SignedDistanceFuncti) {\\n  \\t\\tinherits(SuperPrimitive, _SignedDistanceFuncti);\\n\\n  \\t\\tfunction SuperPrimitive() {\\n  \\t\\t\\t\\tvar parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  \\t\\t\\t\\tvar material = arguments[1];\\n  \\t\\t\\t\\tclassCallCheck(this, SuperPrimitive);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (SuperPrimitive.__proto__ || Object.getPrototypeOf(SuperPrimitive)).call(this, SDFType.SUPER_PRIMITIVE, material));\\n\\n  \\t\\t\\t\\t_this.origin = new Vector3();\\n\\n  \\t\\t\\t\\tif (parameters.origin !== undefined) {\\n\\n  \\t\\t\\t\\t\\t\\t_this.origin.fromArray(parameters.origin);\\n  \\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t_this.scale = parameters.scale !== undefined ? parameters.scale : 1.0;\\n\\n  \\t\\t\\t\\t_this.s0 = new (Function.prototype.bind.apply(Vector4, [null].concat(toConsumableArray(parameters.s))))();\\n\\n  \\t\\t\\t\\t_this.r0 = new (Function.prototype.bind.apply(Vector3, [null].concat(toConsumableArray(parameters.r))))();\\n\\n  \\t\\t\\t\\t_this.s = _this.s0.clone().multiplyScalar(_this.scale);\\n\\n  \\t\\t\\t\\t_this.r = _this.r0.clone().multiplyScalar(_this.scale);\\n\\n  \\t\\t\\t\\t_this.ba = new Vector2();\\n\\n  \\t\\t\\t\\t_this.offset = 0;\\n\\n  \\t\\t\\t\\t_this.precompute();\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SuperPrimitive, [{\\n  \\t\\t\\t\\tkey: \"setScale\",\\n  \\t\\t\\t\\tvalue: function setScale(s) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.scale = s;\\n  \\t\\t\\t\\t\\t\\tthis.s.copy(this.s0).multiplyScalar(s);\\n  \\t\\t\\t\\t\\t\\tthis.r.copy(this.r0).multiplyScalar(s);\\n  \\t\\t\\t\\t\\t\\tthis.computeBoundingBox();\\n  \\t\\t\\t\\t\\t\\tthis.precompute();\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"setGenus\",\\n  \\t\\t\\t\\tvalue: function setGenus(w) {\\n\\n  \\t\\t\\t\\t\\t\\tthis.s0.w = w;\\n  \\t\\t\\t\\t\\t\\tthis.s.copy(this.s0).multiplyScalar(this.scale);\\n  \\t\\t\\t\\t\\t\\tthis.r.copy(this.r0).multiplyScalar(this.scale);\\n  \\t\\t\\t\\t\\t\\tthis.precompute();\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"computeBoundingBox\",\\n  \\t\\t\\t\\tvalue: function computeBoundingBox() {\\n\\n  \\t\\t\\t\\t\\t\\tvar s = this.scale * 2.0;\\n  \\t\\t\\t\\t\\t\\tvar o = this.origin;\\n\\n  \\t\\t\\t\\t\\t\\tthis.bbox = new Box3();\\n  \\t\\t\\t\\t\\t\\tthis.bbox.min.set(o.x - s, o.y - s, o.z - s);\\n  \\t\\t\\t\\t\\t\\tthis.bbox.max.set(o.x + s, o.y + s, o.z + s);\\n\\n  \\t\\t\\t\\t\\t\\treturn this.bbox;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"precompute\",\\n  \\t\\t\\t\\tvalue: function precompute() {\\n\\n  \\t\\t\\t\\t\\t\\tvar s = this.s;\\n  \\t\\t\\t\\t\\t\\tvar r = this.r;\\n  \\t\\t\\t\\t\\t\\tvar ba = this.ba;\\n\\n  \\t\\t\\t\\t\\t\\tvar divisor = void 0;\\n\\n  \\t\\t\\t\\t\\t\\ts.x -= r.x;\\n  \\t\\t\\t\\t\\t\\ts.y -= r.x;\\n\\n  \\t\\t\\t\\t\\t\\tr.x -= s.w;\\n  \\t\\t\\t\\t\\t\\ts.w -= r.y;\\n\\n  \\t\\t\\t\\t\\t\\ts.z -= r.y;\\n\\n  \\t\\t\\t\\t\\t\\tthis.offset = -2.0 * s.z;\\n\\n  \\t\\t\\t\\t\\t\\tba.set(r.z, this.offset);\\n  \\t\\t\\t\\t\\t\\tdivisor = ba.dot(ba);\\n\\n  \\t\\t\\t\\t\\t\\tif (divisor === 0.0) {\\n  \\t\\t\\t\\t\\t\\t\\t\\tba.set(0.0, -1.0);\\n  \\t\\t\\t\\t\\t\\t} else {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tba.divideScalar(divisor);\\n  \\t\\t\\t\\t\\t\\t}\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"sample\",\\n  \\t\\t\\t\\tvalue: function sample(position) {\\n\\n  \\t\\t\\t\\t\\t\\tvar o = this.origin;\\n  \\t\\t\\t\\t\\t\\tvar s = this.s;\\n  \\t\\t\\t\\t\\t\\tvar r = this.r;\\n  \\t\\t\\t\\t\\t\\tvar ba = this.ba;\\n\\n  \\t\\t\\t\\t\\t\\tvar px = position.x - o.x;\\n  \\t\\t\\t\\t\\t\\tvar py = position.y - o.y;\\n  \\t\\t\\t\\t\\t\\tvar pz = position.z - o.z;\\n\\n  \\t\\t\\t\\t\\t\\tvar dx = Math.abs(px) - s.x;\\n  \\t\\t\\t\\t\\t\\tvar dy = Math.abs(py) - s.y;\\n  \\t\\t\\t\\t\\t\\tvar dz = Math.abs(pz) - s.z;\\n\\n  \\t\\t\\t\\t\\t\\tvar mx0 = Math.max(dx, 0.0);\\n  \\t\\t\\t\\t\\t\\tvar my0 = Math.max(dy, 0.0);\\n  \\t\\t\\t\\t\\t\\tvar l0 = Math.sqrt(mx0 * mx0 + my0 * my0);\\n\\n  \\t\\t\\t\\t\\t\\tvar p = pz - s.z;\\n  \\t\\t\\t\\t\\t\\tvar q = Math.abs(l0 + Math.min(0.0, Math.max(dx, dy)) - r.x) - s.w;\\n\\n  \\t\\t\\t\\t\\t\\tvar c = Math.min(Math.max(q * ba.x + p * ba.y, 0.0), 1.0);\\n  \\t\\t\\t\\t\\t\\tvar diagX = q - r.z * c;\\n  \\t\\t\\t\\t\\t\\tvar diagY = p - this.offset * c;\\n\\n  \\t\\t\\t\\t\\t\\tvar hx0 = Math.max(q - r.z, 0.0);\\n  \\t\\t\\t\\t\\t\\tvar hy0 = pz + s.z;\\n  \\t\\t\\t\\t\\t\\tvar hx1 = Math.max(q, 0.0);\\n\\n\\n  \\t\\t\\t\\t\\t\\tvar diagSq = diagX * diagX + diagY * diagY;\\n  \\t\\t\\t\\t\\t\\tvar h0Sq = hx0 * hx0 + hy0 * hy0;\\n  \\t\\t\\t\\t\\t\\tvar h1Sq = hx1 * hx1 + p * p;\\n  \\t\\t\\t\\t\\t\\tvar paBa = q * -ba.y + p * ba.x;\\n\\n  \\t\\t\\t\\t\\t\\tvar l1 = Math.sqrt(Math.min(diagSq, Math.min(h0Sq, h1Sq)));\\n\\n  \\t\\t\\t\\t\\t\\treturn l1 * Math.sign(Math.max(paBa, dz)) - r.y;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"serialize\",\\n  \\t\\t\\t\\tvalue: function serialize() {\\n  \\t\\t\\t\\t\\t\\tvar result = get(SuperPrimitive.prototype.__proto__ || Object.getPrototypeOf(SuperPrimitive.prototype), \"serialize\", this).call(this);\\n\\n  \\t\\t\\t\\t\\t\\tresult.parameters = {\\n  \\t\\t\\t\\t\\t\\t\\t\\torigin: this.origin.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tscale: this.scale,\\n  \\t\\t\\t\\t\\t\\t\\t\\ts: this.s0.toArray(),\\n  \\t\\t\\t\\t\\t\\t\\t\\tr: this.r0.toArray()\\n  \\t\\t\\t\\t\\t\\t};\\n\\n  \\t\\t\\t\\t\\t\\treturn result;\\n  \\t\\t\\t\\t}\\n  \\t\\t}], [{\\n  \\t\\t\\t\\tkey: \"create\",\\n  \\t\\t\\t\\tvalue: function create(preset) {\\n\\n  \\t\\t\\t\\t\\t\\tvar parameters = superPrimitivePresets[preset];\\n\\n  \\t\\t\\t\\t\\t\\treturn new SuperPrimitive({\\n  \\t\\t\\t\\t\\t\\t\\t\\ts: parameters[0],\\n  \\t\\t\\t\\t\\t\\t\\t\\tr: parameters[1]\\n  \\t\\t\\t\\t\\t\\t});\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SuperPrimitive;\\n  }(SignedDistanceFunction);\\n\\n  var superPrimitivePresets = [[new Float32Array([1.0, 1.0, 1.0, 1.0]), new Float32Array([0.0, 0.0, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 0.0, 0.0])], [new Float32Array([0.0, 0.0, 1.0, 1.0]), new Float32Array([0.0, 0.0, 1.0])], [new Float32Array([1.0, 1.0, 2.0, 1.0]), new Float32Array([1.0, 1.0, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 1.0]), new Float32Array([1.0, 1.0, 0.0])], [new Float32Array([1.0, 1.0, 0.25, 1.0]), new Float32Array([1.0, 0.25, 0.0])], [new Float32Array([1.0, 1.0, 0.25, 0.25]), new Float32Array([1.0, 0.25, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 0.25]), new Float32Array([1.0, 0.1, 0.0])], [new Float32Array([1.0, 1.0, 1.0, 0.25]), new Float32Array([0.1, 0.1, 0.0])]];\\n\\n  var SDFReviver = function () {\\n  \\t\\tfunction SDFReviver() {\\n  \\t\\t\\t\\tclassCallCheck(this, SDFReviver);\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(SDFReviver, [{\\n  \\t\\t\\t\\tkey: \"revive\",\\n  \\t\\t\\t\\tvalue: function revive(description) {\\n\\n  \\t\\t\\t\\t\\t\\tvar sdf = void 0,\\n  \\t\\t\\t\\t\\t\\t    i = void 0,\\n  \\t\\t\\t\\t\\t\\t    l = void 0;\\n\\n  \\t\\t\\t\\t\\t\\tswitch (description.type) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase SDFType.FRACTAL_NOISE:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsdf = new FractalNoise(description.parameters, description.material);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase SDFType.HEIGHTFIELD:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsdf = new Heightfield(description.parameters, description.material);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tcase SDFType.SUPER_PRIMITIVE:\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsdf = new SuperPrimitive(description.parameters, description.material);\\n  \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\tsdf.operation = description.operation;\\n\\n  \\t\\t\\t\\t\\t\\tfor (i = 0, l = description.children.length; i < l; ++i) {\\n\\n  \\t\\t\\t\\t\\t\\t\\t\\tsdf.children.push(this.revive(description.children[i]));\\n  \\t\\t\\t\\t\\t\\t}\\n\\n  \\t\\t\\t\\t\\t\\treturn sdf;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn SDFReviver;\\n  }();\\n\\n  var ModificationResponse = function (_DataMessage) {\\n  \\tinherits(ModificationResponse, _DataMessage);\\n\\n  \\tfunction ModificationResponse() {\\n  \\t\\tclassCallCheck(this, ModificationResponse);\\n\\n  \\t\\tvar _this = possibleConstructorReturn(this, (ModificationResponse.__proto__ || Object.getPrototypeOf(ModificationResponse)).call(this, Action.MODIFY));\\n\\n  \\t\\t_this.sdf = null;\\n\\n  \\t\\treturn _this;\\n  \\t}\\n\\n  \\treturn ModificationResponse;\\n  }(DataMessage);\\n\\n  var VolumeModifier = function (_DataProcessor) {\\n  \\t\\tinherits(VolumeModifier, _DataProcessor);\\n\\n  \\t\\tfunction VolumeModifier() {\\n  \\t\\t\\t\\tclassCallCheck(this, VolumeModifier);\\n\\n  \\t\\t\\t\\tvar _this = possibleConstructorReturn(this, (VolumeModifier.__proto__ || Object.getPrototypeOf(VolumeModifier)).call(this));\\n\\n  \\t\\t\\t\\t_this.response = new ModificationResponse();\\n\\n  \\t\\t\\t\\t_this.sdf = null;\\n\\n  \\t\\t\\t\\treturn _this;\\n  \\t\\t}\\n\\n  \\t\\tcreateClass(VolumeModifier, [{\\n  \\t\\t\\t\\tkey: \"respond\",\\n  \\t\\t\\t\\tvalue: function respond() {\\n  \\t\\t\\t\\t\\t\\tvar response = get(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), \"respond\", this).call(this);\\n\\n  \\t\\t\\t\\t\\t\\tresponse.sdf = this.sdf !== null ? this.sdf.serialize() : null;\\n\\n  \\t\\t\\t\\t\\t\\treturn response;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"createTransferList\",\\n  \\t\\t\\t\\tvalue: function createTransferList() {\\n  \\t\\t\\t\\t\\t\\tvar transferList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n\\n  \\t\\t\\t\\t\\t\\tget(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), \"createTransferList\", this).call(this, transferList);\\n\\n  \\t\\t\\t\\t\\t\\treturn this.sdf !== null ? this.sdf.createTransferList(transferList) : transferList;\\n  \\t\\t\\t\\t}\\n  \\t\\t}, {\\n  \\t\\t\\t\\tkey: \"process\",\\n  \\t\\t\\t\\tvalue: function process(request) {\\n  \\t\\t\\t\\t\\t\\tvar data = get(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), \"process\", this).call(this, request).getData();\\n\\n  \\t\\t\\t\\t\\t\\tvar sdf = this.sdf = SDFReviver.revive(request.sdf);\\n\\n  \\t\\t\\t\\t\\t\\tvar result = ConstructiveSolidGeometry.run(request.cellPosition, request.cellSize, data, sdf);\\n\\n  \\t\\t\\t\\t\\t\\tset(VolumeModifier.prototype.__proto__ || Object.getPrototypeOf(VolumeModifier.prototype), \"data\", result !== null ? result.compress() : null, this);\\n\\n  \\t\\t\\t\\t\\t\\treturn this;\\n  \\t\\t\\t\\t}\\n  \\t\\t}]);\\n  \\t\\treturn VolumeModifier;\\n  }(DataProcessor);\\n\\n  var volumeModifier = new VolumeModifier();\\n\\n  var surfaceExtractor = new SurfaceExtractor();\\n\\n  var action = null;\\n\\n  self.addEventListener(\"message\", function onMessage(event) {\\n  \\tvar request = event.data;\\n  \\taction = request.action;\\n\\n  \\tswitch (action) {\\n\\n  \\t\\tcase Action.MODIFY:\\n  \\t\\t\\tpostMessage(volumeModifier.process(request).respond(), volumeModifier.createTransferList());\\n  \\t\\t\\tbreak;\\n\\n  \\t\\tcase Action.EXTRACT:\\n  \\t\\t\\tpostMessage(surfaceExtractor.process(request).respond(), surfaceExtractor.createTransferList());\\n  \\t\\t\\tbreak;\\n\\n  \\t\\tcase Action.CONFIGURE:\\n  \\t\\t\\tHermiteData.resolution = request.resolution;\\n  \\t\\t\\tVoxelCell.errorThreshold = request.errorThreshold;\\n  \\t\\t\\tbreak;\\n\\n  \\t\\tcase Action.CLOSE:\\n  \\t\\tdefault:\\n  \\t\\t\\tclose();\\n\\n  \\t}\\n  });\\n\\n  self.addEventListener(\"error\", function onError(event) {\\n\\n  \\tvar processor = action === Action.MODIFY ? volumeModifier : action === Action.EXTRACT ? surfaceExtractor : null;\\n\\n  \\tvar response = void 0;\\n\\n  \\tif (processor !== null) {\\n  \\t\\tresponse = processor.respond();\\n\\n  \\t\\tresponse.action = Action.CLOSE;\\n  \\t\\tresponse.error = event;\\n\\n  \\t\\tpostMessage(response, processor.createTransferList());\\n  \\t} else {\\n  \\t\\tresponse = new Message(Action.CLOSE);\\n  \\t\\tresponse.error = event;\\n\\n  \\t\\tpostMessage(response);\\n  \\t}\\n\\n  \\tclose();\\n  });\\n\\n}());\\n',Ln=function(e){i(r,l);function r(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:navigator.hardwareConcurrency;t(this,r);var e=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return e.workerURL=URL.createObjectURL(new Blob([Un],{type:\"text/javascript\"})),e.maxWorkers=Math.min(navigator.hardwareConcurrency,Math.max(n,1)),e.workers=[],e.busyWorkers=new WeakSet,e.configurationMessage=new Tn,e}return n(r,[{key:\"handleEvent\",value:function(t){switch(t.type){case\"message\":this.busyWorkers.delete(t.target),Rn.worker=t.target,Rn.response=t.data,this.dispatchEvent(Rn),this.workers.length>this.maxWorkers&&this.closeWorker(t.target);break;case\"error\":console.error(\"Encountered an unexpected error\",t)}}},{key:\"closeWorker\",value:function(t){var n=this.workers.indexOf(t);this.busyWorkers.has(t)?(this.busyWorkers.delete(t),t.terminate()):t.postMessage(new In(qn.CLOSE)),t.removeEventListener(\"message\",this),t.removeEventListener(\"error\",this),n>=0&&this.workers.splice(n,1)}},{key:\"createWorker\",value:function(){var t=new Worker(this.workerURL);return this.workers.push(t),t.addEventListener(\"message\",this),t.addEventListener(\"error\",this),t.postMessage(this.configurationMessage),t}},{key:\"getWorker\",value:function(){var t=null,n=void 0,e=void 0;for(n=0,e=this.workers.length;n<e;++n)if(!this.busyWorkers.has(this.workers[n])){t=this.workers[n],this.busyWorkers.add(t);break}return null===t&&this.workers.length<this.maxWorkers&&null!==this.workerURL&&(t=this.createWorker(),this.busyWorkers.add(t)),t}},{key:\"clear\",value:function(){for(;this.workers.length>0;)this.closeWorker(this.workers.pop())}},{key:\"dispose\",value:function(){this.clear(),URL.revokeObjectURL(this.workerURL),this.workerURL=null}}]),r}(),Bn=function(n){i(e,o);function e(n){t(this,e);var i=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,n));return i.octant=null,i.octantId=null,i.error=null,i}return e}(),$n=(new Bn(\"modificationstart\"),new Bn(\"modificationend\"),new Bn(\"extractionstart\"),new Bn(\"extractionend\"),new Bn(\"load\")),Nn=(new Bn(\"error\"),function(e){i(r,l);function r(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t(this,r);var e=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return Gt.resolution=void 0!==n.resolution?n.resolution:32,e.object=null,e.world=new Cn(n.cellSize,n.levels,n.keyDesign),e.clipmap=new _n(e.world),e.clipmap.addEventListener(\"shellupdate\",e),e.threadPool=new Ln(n.workers),e.threadPool.addEventListener(\"message\",e),e.tasks=new WeakMap,e.sdfLoader=new lt,e.sdfLoader.addEventListener(\"load\",e),e.history=[],e.dtSq=e.world.getCellSize(),e}n(r,[{key:\"handleEvent\",value:function(t){switch(t.type){case\"shellupdate\":case\"message\":break;case\"load\":this.revive(t.descriptions),this.dispatchEvent($n)}}},{key:\"applyCSG\",value:function(t){this.world.applyCSG(t),this.history.push(t)}},{key:\"union\",value:function(t){this.applyCSG(t.setOperationType(u.UNION))}},{key:\"subtract\",value:function(t){this.applyCSG(t.setOperationType(u.DIFFERENCE))}},{key:\"intersect\",value:function(t){this.applyCSG(t.setOperationType(u.INTERSECTION))}},{key:\"update\",value:function(t){this.clipmap.position.distanceToSquared(t)>=this.dtSq&&this.clipmap.update(t)}},{key:\"raycast\",value:function(t){return this.world.raycast(t)}},{key:\"clear\",value:function(){this.world.clear(),this.clipmap.clear(),this.threadPool.clear(),this.sdfLoader.clear(),this.tasks=new WeakMap,this.history=[]}},{key:\"dispose\",value:function(){this.threadPool.dispose()}},{key:\"revive\",value:function(t){var n=void 0,e=void 0;for(n=0,e=t.length;n<e;++n)this.applyCSG(st.revive(t[n]))}},{key:\"save\",value:function(){return 0===this.history.length?null:URL.createObjectURL(new Blob([JSON.stringify(this.history)],{type:\"text/json\"}))}},{key:\"load\",value:function(t){var n=JSON.parse(t);this.clear(),this.sdfLoader.load(n)}}])}(),function(){function e(n,i,a,r,s){t(this,e),this.indices=n,this.positions=i,this.normals=a,this.uvs=r,this.materials=s}return n(e,[{key:\"serialize\",value:function(){return{indices:this.indices,positions:this.positions,normals:this.normals,uvs:this.uvs,materials:this.materials}}},{key:\"deserialize\",value:function(t){var n=this;return null!==t?(this.indices=t.indices,this.positions=t.positions,this.normals=t.normals,this.uvs=t.uvs,this.materials=t.materials):n=null,n}},{key:\"createTransferList\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return t.push(this.indices.buffer),t.push(this.positions.buffer),t.push(this.normals.buffer),t.push(this.uvs.buffer),t.push(this.materials.buffer),t}}]),e}()),jn=[new Uint8Array([0,4,0]),new Uint8Array([1,5,0]),new Uint8Array([2,6,0]),new Uint8Array([3,7,0]),new Uint8Array([0,2,1]),new Uint8Array([4,6,1]),new Uint8Array([1,3,1]),new Uint8Array([5,7,1]),new Uint8Array([0,1,2]),new Uint8Array([2,3,2]),new Uint8Array([4,5,2]),new Uint8Array([6,7,2])],Xn=[new Uint8Array([0,1,2,3,0]),new Uint8Array([4,5,6,7,0]),new Uint8Array([0,4,1,5,1]),new Uint8Array([2,6,3,7,1]),new Uint8Array([0,2,4,6,2]),new Uint8Array([1,3,5,7,2])],Yn=[[new Uint8Array([4,0,0]),new Uint8Array([5,1,0]),new Uint8Array([6,2,0]),new Uint8Array([7,3,0])],[new Uint8Array([2,0,1]),new Uint8Array([6,4,1]),new Uint8Array([3,1,1]),new Uint8Array([7,5,1])],[new Uint8Array([1,0,2]),new Uint8Array([3,2,2]),new Uint8Array([5,4,2]),new Uint8Array([7,6,2])]],Zn=[[new Uint8Array([1,4,0,5,1,1]),new Uint8Array([1,6,2,7,3,1]),new Uint8Array([0,4,6,0,2,2]),new Uint8Array([0,5,7,1,3,2])],[new Uint8Array([0,2,3,0,1,0]),new Uint8Array([0,6,7,4,5,0]),new Uint8Array([1,2,0,6,4,2]),new Uint8Array([1,3,1,7,5,2])],[new Uint8Array([1,1,0,3,2,0]),new Uint8Array([1,5,4,7,6,0]),new Uint8Array([0,1,5,0,4,1]),new Uint8Array([0,3,7,2,6,1])]],Hn=[[new Uint8Array([3,2,1,0,0]),new Uint8Array([7,6,5,4,0])],[new Uint8Array([5,1,4,0,1]),new Uint8Array([7,3,6,2,1])],[new Uint8Array([6,4,2,0,2]),new Uint8Array([7,5,3,1,2])]],Qn=[new Uint8Array([3,2,1,0]),new Uint8Array([7,5,6,4]),new Uint8Array([11,10,9,8])],Gn=Math.pow(2,16)-1;function Kn(t,n,e){var i=[0,0,0,0],a=void 0,r=void 0,s=void 0,o=void 0;if(null!==t[0].voxel&&null!==t[1].voxel&&null!==t[2].voxel&&null!==t[3].voxel)!function(t,n,e){var i=[-1,-1,-1,-1],a=[!1,!1,!1,!1],r=1/0,s=0,o=!1,l=void 0,u=void 0,h=void 0,c=void 0,d=void 0,v=void 0,m=void 0;for(m=0;m<4;++m)d=t[m],v=Qn[n][m],l=mt[v][0],u=mt[v][1],h=d.voxel.materials>>l&1,c=d.voxel.materials>>u&1,d.size<r&&(r=d.size,s=m,o=h!==Y.AIR),i[m]=d.voxel.index,a[m]=h!==c;a[s]&&(o?(e.push(i[0]),e.push(i[3]),e.push(i[1]),e.push(i[0]),e.push(i[2]),e.push(i[3])):(e.push(i[0]),e.push(i[1]),e.push(i[3]),e.push(i[0]),e.push(i[3]),e.push(i[2])))}(t,n,e);else for(s=0;s<2;++s){for(i[0]=Hn[n][s][0],i[1]=Hn[n][s][1],i[2]=Hn[n][s][2],i[3]=Hn[n][s][3],a=[],o=0;o<4;++o)if(null!==(r=t[o]).voxel)a[o]=r;else{if(null===r.children)break;a[o]=r.children[i[o]]}4===o&&Kn(a,Hn[n][s][4],e)}}function Wn(t,n,e){var i=[0,0,0,0],a=[[0,0,1,1],[0,1,0,1]],r=void 0,s=void 0,o=void 0,l=void 0,u=void 0;if(null!==t[0].children||null!==t[1].children){for(l=0;l<4;++l)i[0]=Yn[n][l][0],i[1]=Yn[n][l][1],Wn([null===t[0].children?t[0]:t[0].children[i[0]],null===t[1].children?t[1]:t[1].children[i[1]]],Yn[n][l][2],e);for(l=0;l<4;++l){for(i[0]=Zn[n][l][1],i[1]=Zn[n][l][2],i[2]=Zn[n][l][3],i[3]=Zn[n][l][4],s=a[Zn[n][l][0]],r=[],u=0;u<4;++u)if(null!==(o=t[s[u]]).voxel)r[u]=o;else{if(null===o.children)break;r[u]=o.children[i[u]]}4===u&&Kn(r,Zn[n][l][5],e)}}}var Jn=function(){function e(){t(this,e)}return n(e,null,[{key:\"run\",value:function(t){var n=[],e=t.voxelCount,i=null,a=null,r=null,s=null,o=null;return e>Gn?console.warn(\"Could not create geometry for cell at position\",t.min,\"(vertex count of\",e,\"exceeds limit of \",Gn,\")\"):e>0&&(a=new Float32Array(3*e),r=new Float32Array(3*e),s=new Float32Array(2*e),o=new Uint8Array(e),function t(n,e,i,a){var r=void 0,s=void 0;if(null!==n.children)for(r=0;r<8;++r)a=t(n.children[r],e,i,a);else null!==n.voxel&&((s=n.voxel).index=a,e[3*a]=s.position.x,e[3*a+1]=s.position.y,e[3*a+2]=s.position.z,i[3*a]=s.normal.x,i[3*a+1]=s.normal.y,i[3*a+2]=s.normal.z,++a);return a}(t.root,a,r,0),function t(n,e){var i=n.children,a=[0,0,0,0],r=void 0;if(null!==i){for(r=0;r<8;++r)t(i[r],e);for(r=0;r<12;++r)a[0]=jn[r][0],a[1]=jn[r][1],Wn([i[a[0]],i[a[1]]],jn[r][2],e);for(r=0;r<6;++r)a[0]=Xn[r][0],a[1]=Xn[r][1],a[2]=Xn[r][2],a[3]=Xn[r][3],Kn([i[a[0]],i[a[1]],i[a[2]],i[a[3]]],Xn[r][4],e)}}(t.root,n),i=new Nn(new Uint16Array(n),a,r,s,o)),i}}]),e}(),te=new y,ne=function(){function e(){t(this,e)}return n(e,null,[{key:\"calculateCoefficients\",value:function(t,n,e){var i=void 0,a=void 0,r=void 0;return 0===n?(te.x=1,te.y=0):(i=(e-t)/(2*n),a=Math.sqrt(1+i*i),r=1/(i>=0?i+a:i-a),te.x=1/Math.sqrt(1+r*r),te.y=r*te.x),te}}]),e}(),ee=function(){function e(){t(this,e)}return n(e,null,[{key:\"rotateXY\",value:function(t,n){var e=n.x,i=n.y,a=t.x,r=t.y;t.set(e*a-i*r,i*a+e*r)}},{key:\"rotateQXY\",value:function(t,n,e){var i=e.x,a=e.y,r=i*i,s=a*a,o=2*i*a*n,l=t.x,u=t.y;t.set(r*l-o+s*u,s*l+o+r*u)}}]),e}(),ie=.1,ae=5,re=new j,se=new p,oe=new y,le=new h;function ue(t,n){var e=t.elements,i=n.elements,a=void 0;0!==e[1]&&(a=ne.calculateCoefficients(e[0],e[1],e[3]),ee.rotateQXY(oe.set(e[0],e[3]),e[1],a),e[0]=oe.x,e[3]=oe.y,ee.rotateXY(oe.set(e[2],e[4]),a),e[2]=oe.x,e[4]=oe.y,e[1]=0,ee.rotateXY(oe.set(i[0],i[3]),a),i[0]=oe.x,i[3]=oe.y,ee.rotateXY(oe.set(i[1],i[4]),a),i[1]=oe.x,i[4]=oe.y,ee.rotateXY(oe.set(i[2],i[5]),a),i[2]=oe.x,i[5]=oe.y)}function he(t,n){var e=t.elements,i=n.elements,a=void 0;0!==e[2]&&(a=ne.calculateCoefficients(e[0],e[2],e[5]),ee.rotateQXY(oe.set(e[0],e[5]),e[2],a),e[0]=oe.x,e[5]=oe.y,ee.rotateXY(oe.set(e[1],e[4]),a),e[1]=oe.x,e[4]=oe.y,e[2]=0,ee.rotateXY(oe.set(i[0],i[6]),a),i[0]=oe.x,i[6]=oe.y,ee.rotateXY(oe.set(i[1],i[7]),a),i[1]=oe.x,i[7]=oe.y,ee.rotateXY(oe.set(i[2],i[8]),a),i[2]=oe.x,i[8]=oe.y)}function ce(t,n){var e=t.elements,i=n.elements,a=void 0;0!==e[4]&&(a=ne.calculateCoefficients(e[3],e[4],e[5]),ee.rotateQXY(oe.set(e[3],e[5]),e[4],a),e[3]=oe.x,e[5]=oe.y,ee.rotateXY(oe.set(e[1],e[2]),a),e[1]=oe.x,e[2]=oe.y,e[4]=0,ee.rotateXY(oe.set(i[3],i[6]),a),i[3]=oe.x,i[6]=oe.y,ee.rotateXY(oe.set(i[4],i[7]),a),i[4]=oe.x,i[7]=oe.y,ee.rotateXY(oe.set(i[5],i[8]),a),i[5]=oe.x,i[8]=oe.y)}function de(t){var n=Math.abs(t)<ie?0:1/t;return Math.abs(n)<ie?0:n}var ve=function(){function e(){t(this,e)}return n(e,null,[{key:\"solve\",value:function(t,n,e){var i=function(t,n){var e=t.elements,i=void 0;for(i=0;i<ae;++i)ue(t,n),he(t,n),ce(t,n);return le.set(e[0],e[3],e[5])}(re.copy(t),se.identity()),a=function(t,n){var e=t.elements,i=e[0],a=e[3],r=e[6],s=e[1],o=e[4],l=e[7],u=e[2],h=e[5],c=e[8],d=de(n.x),v=de(n.y),m=de(n.z);return t.set(i*d*i+a*v*a+r*m*r,i*d*s+a*v*o+r*m*l,i*d*u+a*v*h+r*m*c,s*d*i+o*v*a+l*m*r,s*d*s+o*v*o+l*m*l,s*d*u+o*v*h+l*m*c,u*d*i+h*v*a+c*m*r,u*d*s+h*v*o+c*m*l,u*d*u+h*v*h+c*m*c)}(se,i);e.copy(n).applyMatrix3(a)}}]),e}(),me=new h;var ye=function(){function e(){t(this,e),this.data=null,this.ata=new j,this.atb=new h,this.massPoint=new h,this.hasSolution=!1}return n(e,[{key:\"setData\",value:function(t){return this.data=t,this.hasSolution=!1,this}},{key:\"solve\",value:function(t){var n=this.data,e=this.massPoint,i=this.ata.copy(n.ata),a=this.atb.copy(n.atb),r=1/0;!this.hasSolution&&null!==n&&n.numPoints>0&&(me.copy(n.massPointSum).divideScalar(n.numPoints),e.copy(me),i.applyToVector3(me),a.sub(me),ve.solve(i,a,t),s=a,o=t,i.applyToVector3(me.copy(o)),me.subVectors(s,me),r=me.dot(me),t.add(e),this.hasSolution=!0);var s,o;return r}}]),e}(),fe=function(){function e(){t(this,e),this.ata=new j,this.ata.set(0,0,0,0,0,0),this.atb=new h,this.massPointSum=new h,this.numPoints=0}return n(e,[{key:\"set\",value:function(t,n,e,i){return this.ata.copy(t),this.atb.copy(n),this.massPointSum.copy(e),this.numPoints=i,this}},{key:\"copy\",value:function(t){return this.set(t.ata,t.atb,t.massPointSum,t.numPoints)}},{key:\"add\",value:function(t,n){var e=n.x,i=n.y,a=n.z,r=t.dot(n),s=this.ata.elements,o=this.atb;s[0]+=e*e,s[1]+=e*i,s[3]+=i*i,s[2]+=e*a,s[4]+=i*a,s[5]+=a*a,o.x+=r*e,o.y+=r*i,o.z+=r*a,this.massPointSum.add(t),++this.numPoints}},{key:\"addData\",value:function(t){this.ata.add(t.ata),this.atb.add(t.atb),this.massPointSum.add(t.massPointSum),this.numPoints+=t.numPoints}},{key:\"clear\",value:function(){this.ata.set(0,0,0,0,0,0),this.atb.set(0,0,0),this.massPointSum.set(0,0,0),this.numPoints=0}},{key:\"clone\",value:function(){return(new this.constructor).copy(this)}}]),e}(),pe=function n(){t(this,n),this.materials=0,this.edgeCount=0,this.index=-1,this.position=new h,this.normal=new h,this.qefData=null},xe=new ye,ge=-1,ke=function(e){i(r,ft);function r(n,e){t(this,r);var i=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,n,e));return i.voxel=null,i}return n(r,[{key:\"contains\",value:function(t){var n=this.min,e=this.size;return t.x>=n.x-.1&&t.y>=n.y-.1&&t.z>=n.z-.1&&t.x<=n.x+e+.1&&t.y<=n.y+e+.1&&t.z<=n.z+e+.1}},{key:\"collapse\",value:function(){var t=this.children,n=[-1,-1,-1,-1,-1,-1,-1,-1],e=new h,i=-1,a=null!==t,r=0,s=void 0,o=void 0,l=void 0,u=void 0,c=void 0,d=void 0;if(a){for(u=new fe,c=0,d=0;d<8;++d)r+=(s=t[d]).collapse(),l=s.voxel,null!==s.children?a=!1:null!==l&&(u.addData(l.qefData),i=l.materials>>7-d&1,n[d]=l.materials>>d&1,++c);if(a&&xe.setData(u).solve(e)<=ge){for((l=new pe).position.copy(this.contains(e)?e:xe.massPoint),d=0;d<8;++d)o=n[d],s=t[d],-1===o?l.materials|=i<<d:(l.materials|=o<<d,l.normal.add(s.voxel.normal));l.normal.normalize(),l.qefData=u,this.voxel=l,this.children=null,r+=c-1}}return r}}],[{key:\"errorThreshold\",get:function(){return ge},set:function(t){ge=t}}]),r}();function ze(t,n,e,i,a){var r=0;for(n>>=1;n>0;n>>=1,r=0)e>=n&&(r+=4,e-=n),i>=n&&(r+=2,i-=n),a>=n&&(r+=1,a-=n),null===t.children&&t.split(),t=t.children[r];return t}function be(t,n,e,i,a){var r=t+1,s=r*r,o=new pe,l=void 0,u=void 0,h=void 0,c=void 0,d=void 0;for(l=0,d=0;d<8;++d)c=(i+(h=vt[d])[2])*s+(e+h[1])*r+(n+h[0]),l|=Math.min(a[c],Y.SOLID)<<d;for(u=0,d=0;d<12;++d)(l>>mt[d][0]&1)!==(l>>mt[d][1]&1)&&++u;return o.materials=l,o.edgeCount=u,o.qefData=new fe,o}var we=function(e){i(r,Ot);function r(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;t(this,r);var s=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this));return s.root=new ke(e,i),s.voxelCount=0,null!==n&&null!==n.edgeData&&s.construct(n),ke.errorThreshold>=0&&s.simplify(),s}return n(r,[{key:\"simplify\",value:function(){this.voxelCount-=this.root.collapse()}},{key:\"construct\",value:function(t){var n=Gt.resolution,e=t.edgeData,i=t.materialIndices,a=new ye,r=new h,s=[e.edgesX(this.min,this.root.size),e.edgesY(this.min,this.root.size),e.edgesZ(this.min,this.root.size)],o=[new Uint8Array([0,1,2,3]),new Uint8Array([0,1,4,5]),new Uint8Array([0,2,4,6])],l=0,u=void 0,c=void 0,d=void 0,v=void 0,m=void 0,y=void 0,f=void 0,p=void 0,x=void 0,g=void 0,k=void 0;for(g=0;g<3;++g){d=o[g],u=s[g];var z=!0,b=!1,w=void 0;try{for(var M,S=u[Symbol.iterator]();!(z=(M=S.next()).done);z=!0)for((c=M.value).computeZeroCrossingPosition(r),k=0;k<4;++k)v=vt[d[k]],f=c.coordinates.x-v[0],p=c.coordinates.y-v[1],x=c.coordinates.z-v[2],f>=0&&p>=0&&x>=0&&f<n&&p<n&&x<n&&(null===(m=ze(this.root,n,f,p,x)).voxel&&(m.voxel=be(n,f,p,x,i),++l),(y=m.voxel).normal.add(c.n),y.qefData.add(r,c.n),y.qefData.numPoints===y.edgeCount&&(a.setData(y.qefData).solve(y.position),m.contains(y.position)||y.position.copy(a.massPoint),y.normal.normalize()))}catch(t){b=!0,w=t}finally{try{!z&&S.return&&S.return()}finally{if(b)throw w}}}this.voxelCount=l}}]),r}(),Me=0,Se=new h;function Ce(t,n,e){var i=function(t){var n=Me,e=Gt.resolution,i=new h(0,0,0),a=new h(e,e,e),r=new d(Se,Se.clone().addScalar(Me));return t.type!==u.INTERSECTION&&(t.boundingBox.intersectsBox(r)?(i.copy(t.boundingBox.min).max(r.min).sub(r.min),i.x=Math.ceil(i.x*e/n),i.y=Math.ceil(i.y*e/n),i.z=Math.ceil(i.z*e/n),a.copy(t.boundingBox.max).min(r.max).sub(r.min),a.x=Math.floor(a.x*e/n),a.y=Math.floor(a.y*e/n),a.z=Math.floor(a.z*e/n)):(i.set(e,e,e),a.set(0,0,0))),new d(i,a)}(t),a=void 0,r=void 0,s=void 0,o=void 0,l=!1;if(t.type===u.DENSITY_FUNCTION?function(t,n,e){var i=Me,a=Gt.resolution,r=a+1,s=r*r,o=n.materialIndices,l=Se,u=new h,c=new h,d=e.max.x,v=e.max.y,m=e.max.z,y=void 0,f=0,p=void 0,x=void 0,g=void 0;for(g=e.min.z;g<=m;++g)for(u.z=g*i/a,x=e.min.y;x<=v;++x)for(u.y=x*i/a,p=e.min.x;p<=d;++p)u.x=p*i/a,(y=t.generateMaterialIndex(c.addVectors(l,u)))!==Y.AIR&&(o[g*s+x*r+p]=y,++f);n.materials=f}(t,n,i):n.empty?t.type===u.UNION&&(n.set(e),l=!0):n.full&&t.type===u.UNION||function(t,n,e,i){var a=Gt.resolution+1,r=a*a,s=i.max.x,o=i.max.y,l=i.max.z,u=void 0,h=void 0,c=void 0;for(c=i.min.z;c<=l;++c)for(h=i.min.y;h<=o;++h)for(u=i.min.x;u<=s;++u)t.updateMaterialIndex(c*r+h*a+u,n,e)}(t,n,e,i),!l&&!n.empty&&!n.full){for(r=(a=t.type===u.DENSITY_FUNCTION?function(t,n,e){var i=Me,a=Gt.resolution,r=a+1,s=r*r,o=new Uint32Array([1,r,s]),l=n.materialIndices,u=Se,c=new h,d=new h,v=new $t,m=new Uint32Array(3),y=new Zt(Zt.calculate1DEdgeCount(a)),f=void 0,p=void 0,x=void 0,g=void 0,k=void 0,z=void 0,b=void 0,w=void 0,M=void 0,S=void 0,C=void 0,O=void 0,D=void 0,P=void 0,A=void 0,_=void 0,q=void 0,I=void 0,E=void 0;for(A=4,D=0,P=0;P<3;A>>=1,D=0,++P){switch(_=vt[A],f=y.indices[P],p=y.zeroCrossings[P],x=y.normals[P],g=o[P],b=e.min.x,S=e.max.x,w=e.min.y,C=e.max.y,M=e.min.z,O=e.max.z,P){case 0:b=Math.max(b-1,0),S=Math.min(S,a-1);break;case 1:w=Math.max(w-1,0),C=Math.min(C,a-1);break;case 2:M=Math.max(M-1,0),O=Math.min(O,a-1)}for(E=M;E<=O;++E)for(I=w;I<=C;++I)for(q=b;q<=S;++q)z=(k=E*s+I*r+q)+g,l[k]!==l[z]&&(c.set(q*i/a,I*i/a,E*i/a),d.set((q+_[0])*i/a,(I+_[1])*i/a,(E+_[2])*i/a),v.a.addVectors(u,c),v.b.addVectors(u,d),t.generateEdge(v),f[D]=k,p[D]=v.t,x[3*D]=v.n.x,x[3*D+1]=v.n.y,x[3*D+2]=v.n.z,++D);m[P]=D}return{edgeData:y,lengths:m}}(t,n,i):function(t,n,e){var i=Gt.resolution,a=i+1,r=new Uint32Array([1,a,a*a]),s=n.materialIndices,o=new $t,l=new $t,h=e.edgeData,c=n.edgeData,d=new Uint32Array(3),v=Zt.calculate1DEdgeCount(i),m=new Zt(Math.min(v,c.indices[0].length+h.indices[0].length),Math.min(v,c.indices[1].length+h.indices[1].length),Math.min(v,c.indices[2].length+h.indices[2].length)),y=void 0,f=void 0,p=void 0,x=void 0,g=void 0,k=void 0,z=void 0,b=void 0,w=void 0,M=void 0,S=void 0,C=void 0,O=void 0,D=void 0,P=void 0,A=void 0,_=void 0,q=void 0,I=void 0,E=void 0,T=void 0,V=void 0,F=void 0;for(q=0,I=0;I<3;q=0,++I){for(y=h.indices[I],x=c.indices[I],z=m.indices[I],f=h.zeroCrossings[I],g=c.zeroCrossings[I],b=m.zeroCrossings[I],p=h.normals[I],k=c.normals[I],w=m.normals[I],M=r[I],V=y.length,F=x.length,E=0,T=0;E<V;++E)if(C=(S=y[E])+M,(P=s[S])!==(A=s[C])&&(P===Y.AIR||A===Y.AIR)){for(o.t=f[E],o.n.x=p[3*E],o.n.y=p[3*E+1],o.n.z=p[3*E+2],t.type===u.DIFFERENCE&&o.n.negate(),_=o;T<F&&x[T]<=S;)D=(O=x[T])+M,l.t=g[T],l.n.x=k[3*T],l.n.y=k[3*T+1],l.n.z=k[3*T+2],P=s[O],O<S?P===(A=s[D])||P!==Y.AIR&&A!==Y.AIR||(z[q]=O,b[q]=l.t,w[3*q]=l.n.x,w[3*q+1]=l.n.y,w[3*q+2]=l.n.z,++q):_=t.selectEdge(l,o,P===Y.SOLID),++T;z[q]=S,b[q]=_.t,w[3*q]=_.n.x,w[3*q+1]=_.n.y,w[3*q+2]=_.n.z,++q}for(;T<F;)D=(O=x[T])+M,(P=s[O])===(A=s[D])||P!==Y.AIR&&A!==Y.AIR||(z[q]=O,b[q]=g[T],w[3*q]=k[3*T],w[3*q+1]=k[3*T+1],w[3*q+2]=k[3*T+2],++q),++T;d[I]=q}return{edgeData:m,lengths:d}}(t,n,e)).edgeData,s=a.lengths,o=0;o<3;++o)r.indices[o]=r.indices[o].slice(0,s[o]),r.zeroCrossings[o]=r.zeroCrossings[o].slice(0,s[o]),r.normals[o]=r.normals[o].slice(0,3*s[o]);n.edgeData=r}}var Oe=function(){function e(){t(this,e)}return n(e,null,[{key:\"run\",value:function(t,n,e,i){Se.fromArray(t),Me=n,null===e?i.operation===u.UNION&&(e=new Gt(!1)):e.decompress();var a=i.toCSG(),r=null!==e?function t(n){var e=n.children,i=void 0,a=void 0,r=void 0,s=void 0;for(n.type===u.DENSITY_FUNCTION&&Ce(n,i=new Gt),r=0,s=e.length;r<s&&(a=t(e[r]),void 0===i?i=a:null!==a?null===i?n.type===u.UNION&&(i=a):Ce(n,i,a):n.type===u.INTERSECTION&&(i=null),null!==i||n.type===u.UNION);++r);return null!==i&&i.empty?null:i}(a):null;if(null!==r){switch(i.operation){case u.UNION:a=new H(a);break;case u.DIFFERENCE:a=new Q(a);break;case u.INTERSECTION:a=new G(a)}Ce(a,e,r),e.contoured=!1}return null!==e&&e.empty?null:e}}]),e}(),De=new Gt(!1),Pe=function(){function e(){t(this,e),this.data=null,this.response=null}return n(e,[{key:\"getData\",value:function(){return this.data}},{key:\"respond\",value:function(){return this.response.data=this.data.serialize(),this.response}},{key:\"createTransferList\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return null!==this.data&&this.data.createTransferList(t),t}},{key:\"process\",value:function(t){return this.data=De.deserialize(t.data),this}}]),e}(),Ae=(function(r){i(s,Pe);function s(){t(this,s);var n=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this));return n.response=new Vn,n.decompressionTarget=new Gt(!1),n.isosurface=null,n}n(s,[{key:\"respond\",value:function(){var t=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"respond\",this).call(this);return t.isosurface=null!==this.isosurface?this.isosurface.serialise():null,t}},{key:\"createTransferList\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"createTransferList\",this).call(this,t),null!==this.isosurface?this.isosurface.createTransferList(t):t}},{key:\"process\",value:function(t){var n=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"process\",this).call(this,t).getData(),i=new we(n.decompress(this.decompressionTarget));return this.isosurface=Jn.run(i),this.decompressionTarget.clear(),this}}])}(),function(r){i(s,Pe);function s(){t(this,s);var n=a(this,(s.__proto__||Object.getPrototypeOf(s)).call(this));return n.response=new Fn,n.sdf=null,n}n(s,[{key:\"respond\",value:function(){var t=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"respond\",this).call(this);return t.sdf=null!==this.sdf?this.sdf.serialize():null,t}},{key:\"createTransferList\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"createTransferList\",this).call(this,t),null!==this.sdf?this.sdf.createTransferList(t):t}},{key:\"process\",value:function(t){var n=e(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"process\",this).call(this,t).getData(),i=this.sdf=st.revive(t.sdf),a=Oe.run(t.cellPosition,t.cellSize,n,i);return function t(n,e,i,a){var r=Object.getOwnPropertyDescriptor(n,e);if(void 0===r){var s=Object.getPrototypeOf(n);null!==s&&t(s,e,i,a)}else if(\"value\"in r&&r.writable)r.value=i;else{var o=r.set;void 0!==o&&o.call(a,i)}return i}(s.prototype.__proto__||Object.getPrototypeOf(s.prototype),\"data\",null!==a?a.compress():null,this),this}}])}(),function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"Report\";t(this,e),this.name=n,this.lines=[],this.data=[]}return n(e,[{key:\"clear\",value:function(){this.data=[]}},{key:\"addLine\",value:function(t){this.lines.push(t)}},{key:\"addValue\",value:function(t){this.data.push(t)}},{key:\"toString\",value:function(){var t=this.lines,n=this.data,e=this.name+\"\\n\\n\",i=void 0,a=void 0;for(i=0,a=t.length;i<a;++i)e+=t[i]+\"\\n\";for(e+=\"\\nValues:\\n\",e+=\"i, ms\\n\",i=0,a=n.length;i<a;++i)e+=i+1+\", \"+n[i]+\"\\n\";return e}}]),e}()),_e=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;t(this,e),this.name=n}return n(e,[{key:\"initialize\",value:function(){throw new Error(\"Test#initialize method not implemented!\")}},{key:\"clear\",value:function(){throw new Error(\"Test#clear method not implemented!\")}},{key:\"run\",value:function(){throw new Error(\"Test#run method not implemented!\")}}]),e}(),qe=function(e){i(r,_e);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,\"Compression Test\"));return n.data=null,n.targetContainer=new Gt(!1),n}return n(r,[{key:\"initialize\",value:function(){var t=[-.5,-.5,-.5],n=et.create(rt);return n.origin.set(0,0,0),n.setScale(.425),this.data=Oe.run(t,1,null,n.setOperationType(u.UNION)),this}},{key:\"clear\",value:function(){return this.data=null,this.targetContainer.clear(),this}},{key:\"run\",value:function(){var t=new Ae(\"Compression Report\"),n=this.targetContainer,e=this.data,i=Gt.resolution,a=Math.pow(i+1,3),r=3*Math.pow(i+1,2)*i,s=void 0,o=void 0,l=void 0,u=void 0,h=void 0,c=void 0,d=void 0;for(t.addLine(\"Performing 200 compression tasks\"),d=0;d<200;++d)c=performance.now(),e.compress(n),t.addValue(performance.now()-c);return o=n.materials,l=n.materialIndices.length,u=n.runLengths.length,h=(s=e.edgeData).indices[0].length+s.indices[1].length+s.indices[2].length,t.addLine(\"Material Statistics\"),t.addLine(\"Total Materials: \"+a+\" (\"+o+\" solid)\"),t.addLine(\"Compressed Materials: \"+l+\" (+ \"+u+\" run-lengths)\"),t.addLine(\"Compression Ratio: \"+(a/(l+4*u)).toFixed(2)),t.addLine(\"Space Savings: \"+(100*(1-(l+4*u)/a)).toFixed(2)+\"%\"),t.addLine(\"Maximum Memory Usage: \"+(8*a/8/1024).toFixed(2)+\" KB\"),t.addLine(\"Estimated Memory Usage: \"+((8*l+32*u)/8/1024).toFixed(2)+\" KB\\n\"),t.addLine(\"Edge Data Statistics\"),t.addLine(\"Total Edges: \"+h+\" (\"+r+\" max)\"),t.addLine(\"Compression Ratio: \"+(r/h).toFixed(2)),t.addLine(\"Space Savings: \"+(100*(1-h/r)).toFixed(2)+\"%\"),t.addLine(\"Maximum Memory Usage: \"+((32*r+32*r+3*r*32)/8/1024/1024).toFixed(2)+\" MB\"),t.addLine(\"Estimated Memory Usage: \"+((32*h+32*h+3*h*32)/8/1024).toFixed(2)+\" KB\"),console.log(\"Compressed data\",n),t}}]),r}(),Ie=function(e){i(r,_e);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,\"Decompression Test\"));return n.data=null,n.targetContainer=new Gt(!1),n}return n(r,[{key:\"initialize\",value:function(){var t=[-.5,-.5,-.5],n=et.create(rt);return n.origin.set(0,0,0),n.setScale(.425),this.data=Oe.run(t,1,null,n.setOperationType(u.UNION)),this.data.compress(),this}},{key:\"clear\",value:function(){return this.data=null,this.targetContainer.clear(),this}},{key:\"run\",value:function(){var t=new Ae(\"Decompression Report\"),n=this.targetContainer,e=this.data,i=void 0,a=void 0;for(t.addLine(\"Performing 200 decompression tasks\"),a=0;a<200;++a)i=performance.now(),e.decompress(n),t.addValue(performance.now()-i);return console.log(\"Decompressed data\",n),t}}]),r}(),Ee=function(e){i(r,_e);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,\"CSG Test\"));return n.data=null,n.cellSize=1,n.cellPosition=[-.5,-.5,-.5],n.sdf=null,n}return n(r,[{key:\"initialize\",value:function(){var t=this.cellSize/2-.075,n=et.create(at).setOperationType(u.UNION),e=et.create(rt).setOperationType(u.UNION);return n.origin.set(0,0,0),e.origin.set(0,0,0),n.setScale(t),e.setScale(t),this.data=Oe.run(this.cellPosition,this.cellSize,null,n),this.sdf=e,this}},{key:\"clear\",value:function(){return this.data=null,this.sdf=null,this}},{key:\"run\",value:function(){var t=new Ae(\"CSG Report\"),n=this.cellPosition,e=this.cellSize,i=this.data,a=this.sdf,r=void 0,s=void 0,o=void 0;for(t.addLine(\"Executing 200 CSG Union operations on existing data\"),t.addLine(\"Initial material count: \"+i.materials),t.addLine(\"Initial edge count: \"+(i.edgeData.indices[0].length+i.edgeData.indices[1].length+i.edgeData.indices[2].length)),o=0;o<200;++o)s=performance.now(),r=Oe.run(n,e,i,a),t.addValue(performance.now()-s);return t.addLine(\"Final material count: \"+r.materials),t.addLine(\"Final edge count: \"+(r.edgeData.indices[0].length+r.edgeData.indices[1].length+r.edgeData.indices[2].length)),console.log(\"Generated data\",r),t}}]),r}(),Te=function(e){i(r,_e);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,\"SVO Test\"));return n.data=null,n.cellSize=1,n.cellPosition=new h(-.5,-.5,-.5),n}return n(r,[{key:\"initialize\",value:function(){var t=this.cellSize/2-.075,n=et.create(rt);return n.origin.set(0,0,0),n.setScale(t),ke.errorThreshold=.01,this.data=Oe.run(this.cellPosition.toArray(),this.cellSize,null,n.setOperationType(u.UNION)),this}},{key:\"clear\",value:function(){return this.data=null,this}},{key:\"run\",value:function(){var t=new Ae(\"SVO Report\"),n=this.cellPosition,e=this.cellSize,i=this.data,a=void 0,r=void 0,s=void 0;for(t.addLine(\"Building 200 sparse voxel octrees\"),t.addLine(\"Material count: \"+i.materials),t.addLine(\"Edge count: \"+(i.edgeData.indices[0].length+i.edgeData.indices[1].length+i.edgeData.indices[2].length)),s=0;s<200;++s)r=performance.now(),a=new we(i,n,e),t.addValue(performance.now()-r);return t.addLine(\"Final voxel count: \"+a.voxelCount),console.log(\"Sparse voxel octree\",a),t}}]),r}(),Ve=function(e){i(r,_e);function r(){t(this,r);var n=a(this,(r.__proto__||Object.getPrototypeOf(r)).call(this,\"Contouring Test\"));return n.svo=null,n}return n(r,[{key:\"initialize\",value:function(){var t=new h(-.5,-.5,-.5),n=et.create(rt);return n.origin.set(0,0,0),n.setScale(.425),ke.errorThreshold=.01,this.svo=new we(Oe.run(t.toArray(),1,null,n.setOperationType(u.UNION)),t,1),this}},{key:\"clear\",value:function(){return this.svo=null,this}},{key:\"run\",value:function(){var t=new Ae(\"Contouring Report\"),n=this.svo,e=void 0,i=void 0,a=void 0;for(t.addLine(\"Performing 200 contouring tasks\"),t.addLine(\"Voxel count: \"+n.voxelCount),a=0;a<200;++a)i=performance.now(),e=Jn.run(n),t.addValue(performance.now()-i);return t.addLine(\"Generated vertices: \"+e.positions.length/3),t.addLine(\"Generated triangle indices: \"+e.indices.length),console.log(\"Extracted isosurface\",e),t}}]),r}(),Fe=\"worker.config\",Re=\"worker.test\",Ue=new Map([[\"Compression\",new qe],[\"Decompression\",new Ie],[\"Contouring\",new Ve],[\"CSG\",new Ee],[\"SVO\",new Te]]);self.addEventListener(\"message\",function(t){var n=t.data,e=void 0,i=void 0;switch(n.action){case Fe:Gt.resolution=n.resolution,console.log(\"Setting Hermite data resolution to\",n.resolution);break;case Re:i=(e=Ue.get(n.id).initialize()).run(),e.clear(),postMessage({reportName:i.name,reportURL:URL.createObjectURL(new Blob([i.toString()],{type:\"text/plain\"}))})}})}();";

  var workerURL = URL.createObjectURL(new Blob([workerCode], { type: "text/javascript" }));

  var worker = null;

  var tests = ["Compression", "Decompression", "Contouring", "CSG", "SVO"];

  function configure(event) {

  	worker.postMessage({
  		action: Action.CONFIGURE,
  		resolution: Number.parseInt(event.target.value)
  	});
  }

  function runTest(event) {

  	var id = event.target.id;
  	var h3 = document.createElement("h3");

  	h3.appendChild(document.createTextNode("Running " + id + " Test\u2026"));
  	document.getElementById("aside").appendChild(h3);
  	document.getElementById("mask").removeAttribute("class");

  	worker.postMessage({
  		action: Action.TEST,
  		id: id
  	});
  }

  function showResult(event) {

  	var response = event.data;
  	var div = document.createElement("div");
  	var span = document.createElement("span");
  	var a = document.createElement("a");

  	a.href = response.reportURL;
  	a.setAttribute("download", response.reportName + ".log");
  	a.setAttribute("class", "report");
  	a.appendChild(document.createTextNode("Report \u2B73"));

  	span.appendChild(document.createTextNode("Test complete"));
  	span.setAttribute("class", "status");
  	span.appendChild(a);

  	div.setAttribute("class", "result");
  	div.appendChild(span);
  	div.appendChild(a);

  	document.getElementById("aside").appendChild(div);
  	document.getElementById("mask").setAttribute("class", "hidden");
  }

  function showAvailableTests() {

  	var main = document.getElementById("main");
  	var ul = document.createElement("ul");

  	var test = void 0,
  	    li = void 0,
  	    a = void 0;

  	var _iteratorNormalCompletion = true;
  	var _didIteratorError = false;
  	var _iteratorError = undefined;

  	try {
  		for (var _iterator = tests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
  			test = _step.value;


  			li = document.createElement("li");

  			a = document.createElement("a");
  			a.appendChild(document.createTextNode(test));
  			a.setAttribute("href", "#" + test);
  			a.setAttribute("id", test);
  			a.addEventListener("click", runTest);

  			li.appendChild(a);
  			ul.appendChild(li);
  		}
  	} catch (err) {
  		_didIteratorError = true;
  		_iteratorError = err;
  	} finally {
  		try {
  			if (!_iteratorNormalCompletion && _iterator.return) {
  				_iterator.return();
  			}
  		} finally {
  			if (_didIteratorError) {
  				throw _iteratorError;
  			}
  		}
  	}

  	main.appendChild(ul);
  }

  function handleEvent(event) {

  	switch (event.type) {

  		case "message":
  			showResult(event);
  			break;

  		case "error":
  			console.error("Encountered an unexpected error", event);
  			break;

  	}
  }

  window.addEventListener("load", function main(event) {

  	window.removeEventListener("load", main);
  	document.getElementById("resolution").addEventListener("change", configure);

  	worker = new Worker(workerURL);
  	worker.addEventListener("message", handleEvent);
  	worker.addEventListener("error", handleEvent);
  	worker.postMessage({
  		action: Action.CONFIGURE,
  		resolution: 64
  	});

  	showAvailableTests();
  });

}());
