<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\volume\csg\constructive-solid-geometry.js - rabbit-hole</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="rabbit-hole" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Action.html">Action</a></li>
                                <li><a href="../classes/Box.html">Box</a></li>
                                <li><a href="../classes/Box3.html">Box3</a></li>
                                <li><a href="../classes/Chunk.html">Chunk</a></li>
                                <li><a href="../classes/ConstructiveSolidGeometry.html">ConstructiveSolidGeometry</a></li>
                                <li><a href="../classes/Density.html">Density</a></li>
                                <li><a href="../classes/DensityFunction.html">DensityFunction</a></li>
                                <li><a href="../classes/Difference.html">Difference</a></li>
                                <li><a href="../classes/DualContouring.html">DualContouring</a></li>
                                <li><a href="../classes/Edge.html">Edge</a></li>
                                <li><a href="../classes/Givens.html">Givens</a></li>
                                <li><a href="../classes/HermiteData.html">HermiteData</a></li>
                                <li><a href="../classes/Intersection.html">Intersection</a></li>
                                <li><a href="../classes/IteratorResult.html">IteratorResult</a></li>
                                <li><a href="../classes/Matrix3.html">Matrix3</a></li>
                                <li><a href="../classes/Operation.html">Operation</a></li>
                                <li><a href="../classes/OperationType.html">OperationType</a></li>
                                <li><a href="../classes/Plane.html">Plane</a></li>
                                <li><a href="../classes/PriorityQueue.html">PriorityQueue</a></li>
                                <li><a href="../classes/QEFData.html">QEFData</a></li>
                                <li><a href="../classes/QEFSolver.html">QEFSolver</a></li>
                                <li><a href="../classes/Queue.html">Queue</a></li>
                                <li><a href="../classes/RunLengthEncoding.html">RunLengthEncoding</a></li>
                                <li><a href="../classes/Scheduler.html">Scheduler</a></li>
                                <li><a href="../classes/Schur.html">Schur</a></li>
                                <li><a href="../classes/SDFType.html">SDFType</a></li>
                                <li><a href="../classes/SignedDistanceFunction.html">SignedDistanceFunction</a></li>
                                <li><a href="../classes/SingularValueDecomposition.html">SingularValueDecomposition</a></li>
                                <li><a href="../classes/Sphere.html">Sphere</a></li>
                                <li><a href="../classes/SurfaceExtractor.html">SurfaceExtractor</a></li>
                                <li><a href="../classes/SymmetricMatrix3.html">SymmetricMatrix3</a></li>
                                <li><a href="../classes/Task.html">Task</a></li>
                                <li><a href="../classes/Terrain.html">Terrain</a></li>
                                <li><a href="../classes/TerrainMaterial.html">TerrainMaterial</a></li>
                                <li><a href="../classes/ThreadPool.html">ThreadPool</a></li>
                                <li><a href="../classes/Torus.html">Torus</a></li>
                                <li><a href="../classes/Union.html">Union</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Volume.html">Volume</a></li>
                                <li><a href="../classes/VolumeModifier.html">VolumeModifier</a></li>
                                <li><a href="../classes/Voxel.html">Voxel</a></li>
                                <li><a href="../classes/VoxelBlock.html">VoxelBlock</a></li>
                                <li><a href="../classes/VoxelCell.html">VoxelCell</a></li>
                                <li><a href="../classes/VoxelIterator.html">VoxelIterator</a></li>
                                <li><a href="../classes/Worker.html">Worker</a></li>
                                <li><a href="../classes/WorkerTask.html">WorkerTask</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/core.html">core</a></li>
                                <li><a href="../modules/csg.html">csg</a></li>
                                <li><a href="../modules/isosurface.html">isosurface</a></li>
                                <li><a href="../modules/materials.html">materials</a></li>
                                <li><a href="../modules/math.html">math</a></li>
                                <li><a href="../modules/octree.html">octree</a></li>
                                <li><a href="../modules/rabbit-hole.html">rabbit-hole</a></li>
                                <li><a href="../modules/sdf.html">sdf</a></li>
                                <li><a href="../modules/volume.html">volume</a></li>
                                <li><a href="../modules/worker.html">worker</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\volume\csg\constructive-solid-geometry.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { PATTERN } from &quot;sparse-octree&quot;;
import { Box3, Vector3 } from &quot;../../math&quot;;
import { SDFType, Sphere, Box, Plane, Torus, Heightfield } from &quot;../sdf&quot;;
import { Edge } from &quot;../edge.js&quot;;
import { HermiteData } from &quot;./hermite-data.js&quot;;
import { OperationType } from &quot;./operation-type.js&quot;;
import { Union } from &quot;./union.js&quot;;
import { Difference } from &quot;./difference.js&quot;;
import { Intersection } from &quot;./intersection.js&quot;;

/**
 * Finds out which grid points lie inside the area of the given operation.
 *
 * @method computeIndexBounds
 * @private
 * @static
 * @param {Chunk} chunk - A volume chunk.
 * @param {Operation} operation - A CSG operation.
 * @return {Box3} The index bounds.
 */

function computeIndexBounds(chunk, operation) {

	const s = chunk.size;
	const n = chunk.resolution;

	const min = new Vector3(0, 0, 0);
	const max = new Vector3(n, n, n);

	const region = new Box3(chunk.min, chunk.max);

	if(operation.type !== OperationType.INTERSECTION) {

		if(operation.boundingBox.intersectsBox(region)) {

			min.copy(operation.boundingBox.min).max(region.min).sub(region.min);

			min.x = Math.ceil(min.x * s / n);
			min.y = Math.ceil(min.y * s / n);
			min.z = Math.ceil(min.z * s / n);

			max.copy(operation.boundingBox.max).min(region.max).sub(region.min);

			max.x = Math.floor(max.x * s / n);
			max.y = Math.floor(max.y * s / n);
			max.z = Math.floor(max.z * s / n);

		} else {

			// The chunk is unaffected by this operation.
			min.set(n, n, n);
			max.set(0, 0, 0);

		}

	}

	return new Box3(min, max);

}

/**
 * Combines material indices.
 *
 * @method combine
 * @private
 * @static
 * @param {Chunk} chunk - A volume chunk
 * @param {Operation} operation - A CSG operation.
 * @param {HermiteData} data0 - A target data set.
 * @param {HermiteData} data1 - A predominant data set.
 * @param {Box3} bounds - Grid iteration limits.
 */

function updateMaterialIndices(chunk, operation, data0, data1, bounds) {

	const m = chunk.resolution + 1;
	const mm = m * m;

	const X = bounds.max.x;
	const Y = bounds.max.y;
	const Z = bounds.max.z;

	let x, y, z;

	for(z = bounds.min.z; z &lt;= Z; ++z) {

		for(y = bounds.min.y; y &lt;= Y; ++y) {

			for(x = bounds.min.x; x &lt;= X; ++x) {

				operation.updateMaterialIndex((z * mm + y * m + x), data0, data1);

			}

		}

	}

}

/**
 * Generates material indices.
 *
 * @method generateMaterialIndices
 * @private
 * @static
 * @param {Chunk} chunk - A volume chunk
 * @param {DensityFunction} operation - A CSG operation.
 * @param {HermiteData} data - A target data set.
 * @param {Box3} bounds - Grid iteration limits.
 */

function generateMaterialIndices(chunk, operation, data, bounds) {

	const s = chunk.size;
	const n = chunk.resolution;

	const m = n + 1;
	const mm = m * m;

	const base = chunk.min;
	const offset = new Vector3();

	const X = bounds.max.x;
	const Y = bounds.max.y;
	const Z = bounds.max.z;

	let x, y, z;

	for(z = bounds.min.z; z &lt;= Z; ++z) {

		offset.z = z * s / n;

		for(y = bounds.min.y; y &lt;= Y; ++y) {

			offset.y = y * s / n;

			for(x = bounds.min.x; x &lt;= X; ++x) {

				offset.x = x * s / n;

				position.addVectors(base, offset);
				operation.generateMaterialIndex((z * mm + y * m + x), position, data);

			}

		}

	}

}

/**
 * Combines edges.
 *
 * @method combineEdges
 * @private
 * @static
 * @param {Chunk} chunk - A volume chunk
 * @param {Operation} operation - A CSG operation.
 * @param {HermiteData} data0 - A target data set.
 * @param {HermiteData} data1 - A predominant data set.
 * @param {Box3} bounds - Grid iteration limits.
 * @return {Object} The generated edge data.
 */

function combineEdges(chunk, operation, data0, data1, bounds) {

	const n = chunk.resolution;
	const m = n + 1;
	const maxEdges = 3 * m * m * n;

	//const materialIndices = data.materialIndices;
	//const edge = new Edge();

	// Allocate space for the maximum amount of edges.
	const edges = new Uint32Array(maxEdges * 2);
	const t = new Float32Array(maxEdges);
	const normals = new Float32Array(maxEdges * 3);

	const edges0 = data0.edges;
	const t0 = data0.t;
	const normals0 = data0.normals;

	const edges1 = data1.edges;
	const t1 = data1.t;
	const normals1 = data1.normals;

	let edgeCount = 0;

	let i0 = 0;
	let i1 = 0;
	let i2 = 0;

	let i3 = 0;
	let i4 = 0;
	let i5 = 0;

	let l = data.edges.length;

	while(i0 &lt; l) {

		indexA = data.edges[i0++];
		indexB = data.edges[i0++];

		

	}

	if(operation.type === OperationType.UNION || operation.type === OperationType.DIFFERENCE) {

		// Collect remaining edges.
		edges.set(edges0.subarray(i4), i1);
		t.set(t0.subarray(i3), i0);
		normals.set(normals0.subarray(i5), i2);

		edgeCount

	}

	return {
		edges: edges,
		t: t,
		normals: normals,
		edgeCount: i0
	};

}

/**
 * Generates edge data.
 *
 * @method generateEdges
 * @private
 * @static
 * @param {Chunk} chunk - A volume chunk
 * @param {DensityFunction} operation - A CSG operation.
 * @param {HermiteData} data - A target data set.
 * @param {Box3} bounds - Grid iteration limits.
 * @return {Object} The generated edge data.
 */

function generateEdges(chunk, operation, data, bounds) {

	const s = chunk.size;
	const n = chunk.resolution;

	const m = n + 1;
	const mm = m * m;
	const maxEdges = 3 * mm * n;

	const base = chunk.min;
	const offsetA = new Vector3();
	const offsetB = new Vector3();

	const indexOffsets = new Uint32Array([1, m, mm]);

	const materialIndices = data.materialIndices;
	const edge = new Edge();

	// Allocate space for the maximum amount of edges.
	const edges = new Uint32Array(maxEdges * 2);
	const t = new Float32Array(maxEdges);
	const normals = new Float32Array(maxEdges * 3);

	// Include edges that straddle the bounding box.
	bounds.min.set(
		Math.max(bounds.min.x - 1, 0),
		Math.max(bounds.min.y - 1, 0),
		Math.max(bounds.min.z - 1, 0)
	);

	const X = bounds.max.x;
	const Y = bounds.max.y;
	const Z = bounds.max.z;

	let edgeCount = 0;

	let i0 = 0;
	let i1 = 0;
	let i2 = 0;

	let x, y, z;

	let c, plane, xyz;
	let combination;

	for(z = bounds.min.z; z &lt;= Z; ++z) {

		offsetA.z = z * s / n;

		for(y = bounds.min.y; y &lt;= Y; ++y) {

			offsetA.y = y * s / n;

			for(x = bounds.min.x; x &lt;= X; ++x) {

				offsetA.x = x * s / n;

				indexA = z * mm + y * m + x;
				edge.a.addVectors(base, offsetA);

				// Process the edge in the X-plane, then Y and finally Z.
				for(c = 0, plane = 4; c &lt; 3; ++c, plane &gt;&gt;= 1) {

					// Select the grid point index of the current plane.
					switch(c) {

						case 0: xyz = x; break;
						case 1: xyz = y; break;
						case 2: xyz = z; break;

					}

					// Check if an edge exists in this plane.
					if(xyz &lt; n) {

						indexB = indexA + indexOffsets[c];

						// Check if the edge exhibits a material change.
						if(materialIndices[indexA] !== materialIndices[indexB]) {

							// X: [1, 0, 0] Y: [0, 1, 0] Z: [0, 0, 1].
							combination = PATTERN[plane];

							offsetB.set(
								(x + combination[0]) * s / n,
								(y + combination[1]) * s / n,
								(z + combination[2]) * s / n
							);

							edge.b.addVectors(base, offsetB);
							operation.generateEdge(edge);

							// Push the created edge data.
							edges[i1++] = indexA;
							edges[i1++] = indexB;

							t[i0++] = edge.t;

							normals[i2++] = edge.n.x;
							normals[i2++] = edge.n.y;
							normals[i2++] = edge.n.z;

						}

					}

				}

			}

		}

	}

	return {
		edges: edges,
		t: t,
		normals: normals,
		edgeCount: i0
	};

}

/**
 * Either generates or combines volume data based on the operation type.
 *
 * @method update
 * @private
 * @static
 * @param {Chunk} chunk - A volume chunk.
 * @param {Operation} operation - A CSG operation.
 * @param {HermiteData} data0 - A target data set.
 * @param {HermiteData} [data1] - Predominant data set.
 */

function update(chunk, operation, data0, data1) {

	const bounds = computeIndexBounds(chunk, operation);

	let edgeData;

	if(operation.type === OperationType.DENSITY_FUNCTION) {

		generateMaterialIndices(chunk, operation, data0, bounds);

	} else {

		combineMaterialIndices(chunk, operation, data0, data1, bounds);

	}

	if(!data.empty &amp;&amp; !data.full) {

		edgeData = (operation.type === OperationType.DENSITY_FUNCTION) ?
			generateEdges(chunk, operation, bounds) :
			combineEdges(chunk, operation, data0, data1, bounds);

		// Cut off empty data.
		data0.edges = edgeData.edges.slice(0, edgeData.edgeCount * 2);
		data0.t = edgeData.t.slice(0, edgeData.edgeCount);
		data0.normals = edgeData.normals.slice(0, edgeData.edgeCount * 3);

	}

}

/**
 * Executes the given operation.
 *
 * @method execute
 * @private
 * @static
 * @param {Chunk} chunk - A volume chunk.
 * @param {Operation} operation - An operation.
 * @return {HermiteData} The generated data or null if the data is empty.
 */

function execute(chunk, operation) {

	const children = operation.children;

	let result, data;
	let i, l;

	if(operation.type === OperationType.DENSITY_FUNCTION) {

		// Create a data target.
		result = new HermiteData();

		// Use the density function to generate data.
		update(chunk, operation, result);

	}

	// Union, Difference or Intersection.
	for(i = 0, l = children.length; i &lt; l; ++i) {

		data = execute(chunk, children[i]);

		if(result === undefined) {

			result = data;

		} else if(data !== null) {

			if(result === null) {

				if(operation.type === OperationType.UNION) {

					// Build upon the first non-empty data.
					result = data;

				}

			} else {

				// Combine the two data sets.
				update(chunk, operation, result, data);

			}

		} else if(operation.type === OperationType.INTERSECTION) {

			// An intersection with nothing results in nothing.
			result = null;

		}

		if(result === null &amp;&amp; operation.type !== OperationType.UNION) {

			// Further subtractions and intersections would have no effect.
			break;

		}

	}

	return (result !== null &amp;&amp; result.empty) ? null : result;

}

/**
 * Constructive Solid Geometry combines Signed Distance Functions by using
 * boolean operators to generate and transform volume data.
 *
 * @class ConstructiveSolidGeometry
 * @submodule csg
 * @static
 */

export class ConstructiveSolidGeometry {

	/**
	 * Transforms the given chunk of hermite data in two steps:
	 *
	 *  1. Generate data by executing the given SDF.
	 *  2. Combine the generated data with the chunk data.
	 *
	 * @method run
	 * @static
	 * @param {Chunk} chunk - The volume chunk that should be modified.
	 * @param {SignedDistanceFunction} sdf - An SDF.
	 */

	static run(chunk, sdf) {

		if(chunk.data === null) {

			if(sdf.operation !== OperationType.DIFFERENCE) {

				chunk.data = new HermiteData();

			}

		} else {

			chunk.data.decompress();

		}

		// Step 1.
		let operation = sdf.toCSG();

		const data = (chunk.data !== null) ? execute(chunk, operation) : null;

		if(data !== null) {

			// Wrap the operation in a super operation.
			switch(sdf.operation) {

				case OperationType.UNION:
					operation = new Union(operation);
					break;

				case OperationType.DIFFERENCE:
					operation = new Difference(operation);
					break;

				case OperationType.INTERSECTION:
					operation = new Intersection(operation);
					break;

			}

			// Step 2.
			update(chunk, operation, chunk.data, data);

			// Provoke a geometry extraction.
			chunk.data.lod = -1;

		}

		if(chunk.data.empty) {

			chunk.data = null;

		} else {

			chunk.data.compress();

		}

	}

	/**
	 * Creates an SDF from the given description.
	 *
	 * @method reviveSDF
	 * @static
	 * @param {Object} description - A description.
	 * @return {SignedDistanceFunction} An SDF.
	 * @todo Use a single abstract SDF and serialise sampling method with expressions.
	 */

	static reviveSDF(description) {

		let sdf, i, l;

		switch(description.type) {

			case SDFType.SPHERE:
				sdf = new Sphere(description.parameters, description.material);
				break;

			case SDFType.BOX:
				sdf = new Box(description.parameters, description.material);
				break;

			case SDFType.TORUS:
				sdf = new Torus(description.parameters, description.material);
				break;

			case SDFType.PLANE:
				sdf = new Plane(description.parameters, description.material);
				break;

			case SDFType.HEIGHTFIELD:
				sdf = new Heightfield(description.parameters, description.material);
				break;

		}

		for(i = 0, l = description.children.length; i &lt; l; ++i) {

			sdf.children.push(this.reviveSDF(description.children[i]));

		}

		return sdf;

	}

}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
